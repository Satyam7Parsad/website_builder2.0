// ImGui Website Designer - Creates ImGui WebAssembly Websites
// Same UI as Website Builder V1, but exports ImGui C++ code that runs in browser
// Version 1.0

#define GL_SILENCE_DEPRECATION
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include <GLFW/glfw3.h>
#include <stdio.h>
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <chrono>
#include <sys/stat.h>
#include <dirent.h>
#include <iomanip>
#include <unistd.h>

// PostgreSQL Database Support
#include <libpq-fe.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// CSS Layout Engine (Flexbox, Grid, Animations)
#include "layout_engine.h"

// macOS Native File Dialog using AppleScript
std::string OpenImageFileDialog() {
    char buffer[1024] = {0};
    FILE* pipe = popen("osascript -e 'set theFile to choose file of type {\"public.image\"} with prompt \"Select an image file\"' -e 'POSIX path of theFile' 2>/dev/null", "r");
    if (pipe) {
        if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            // Remove trailing newline
            size_t len = strlen(buffer);
            if (len > 0 && buffer[len-1] == '\n') buffer[len-1] = '\0';
        }
        pclose(pipe);
    }
    return std::string(buffer);
}

// ============================================================================
// SECTION TYPES
// ============================================================================
enum SectionType {
    SEC_HERO, SEC_NAVBAR, SEC_ABOUT, SEC_SERVICES, SEC_CARDS, SEC_TEAM,
    SEC_PRICING, SEC_TESTIMONIALS, SEC_GALLERY, SEC_BLOG, SEC_CONTACT,
    SEC_FOOTER, SEC_FAQ, SEC_CTA, SEC_FEATURES, SEC_STATS, SEC_LOGIN, SEC_IMAGE, SEC_TEXTBOX, SEC_CUSTOM,
    // Basic Elements (for Free Design Mode)
    SEC_LOGO, SEC_HEADING, SEC_TEXT_ELEMENT, SEC_BUTTON_ELEMENT,
    // Connector Elements (reusable website components)
    SEC_TEXT_CONNECTOR,      // Rich text blocks with bold/normal segments
    SEC_BAR_CONNECTOR,       // Colored heading bars (section dividers)
    SEC_FOOTER_CONNECTOR,    // Multi-column footer with headings + subitems
    SEC_CARD_CONNECTOR,      // Image thumbnail cards with heading + description
    SEC_VERTICAL_CONNECTOR,  // Vertical layout with text + positioned images
    SEC_NAVBAR_CONNECTOR,    // Advanced navbar with hover dropdowns
    SEC_COPYRIGHT_CONNECTOR, // Copyright footer bar with links
    SEC_ARTICLE_CONNECTOR,   // Article/Blog post cards with clickable heading & read more
    SEC_CONTACT_FORM_CONNECTOR, // Contact form with input fields and submit button
    SEC_SEARCH_CONNECTOR,      // Search bar with input and button
    SEC_LOGO_CONNECTOR,        // Logo image with size and link controls
    SEC_BULLET_CONNECTOR,      // Bullet point columns with heading and subheadings
    SEC_ICON,                  // Icon element with selectable icons
    SEC_SERVICE_CARD_CONNECTOR, // Service cards with image, badge tag, and title
    SEC_GLASS_BAR_CONNECTOR,   // Glass effect text bar
    SEC_STORY_CONNECTOR,       // About/Story section with image collage and stats
    SEC_SERVICES_SECTION_CONNECTOR, // Services section with image cards and bullet lists
    SEC_CLIENTS_GRID_CONNECTOR,    // Client/partner logo grid
    SEC_FEATURES_GRID_CONNECTOR,   // Feature cards with icons and checkmark lists
    SEC_PROCESS_TIMELINE_CONNECTOR, // Horizontal process timeline with steps
    SEC_HERO_SECTION_CONNECTOR     // Full hero section with badge, buttons, stats
};

// ============================================================================
// ICON TYPES
// ============================================================================
enum IconType {
    ICON_AVATAR = 0,
    ICON_CHECK,
    ICON_INCREASE,
    ICON_PHONE,
    ICON_CALENDAR,
    ICON_WIFI,
    ICON_LOCK,
    ICON_THUMBUP,
    ICON_CLOCK,
    ICON_PLAY,
    ICON_HOURGLASS,
    ICON_LOCATION,
    ICON_SHOPPING,
    ICON_UPLOAD,
    ICON_LAPTOP,
    ICON_PIECHART,
    ICON_MAIL,
    ICON_BULB,
    ICON_CROSS,
    ICON_LOGIN,
    ICON_HEART,
    ICON_STAR,
    ICON_SEARCH,
    ICON_HOME,
    ICON_SETTINGS,
    ICON_USER,
    ICON_DOWNLOAD,
    ICON_SHARE,
    ICON_BOOKMARK,
    ICON_CAMERA,
    ICON_COUNT  // Total count of icons
};

// Icon names for display
static const char* g_IconNames[] = {
    "Avatar", "Check", "Increase", "Phone", "Calendar",
    "Wifi", "Lock", "Thumb Up", "Clock", "Play",
    "Hourglass", "Location", "Shopping", "Upload", "Laptop",
    "Pie Chart", "Mail", "Bulb", "Cross", "Login",
    "Heart", "Star", "Search", "Home", "Settings",
    "User", "Download", "Share", "Bookmark", "Camera"
};

// Helper: Draw icon at specified position
inline void DrawIcon(ImDrawList* dl, int iconType, float cx, float cy, float size, ImU32 color, float strokeWidth = 2.0f) {
    float r = size * 0.4f;  // Radius for circular icons
    float hw = size * 0.4f; // Half width for rectangular icons

    switch (iconType) {
        case ICON_AVATAR: {
            dl->AddCircle(ImVec2(cx, cy - r*0.3f), r*0.4f, color, 24, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - r*0.7f, cy + r*0.8f), ImVec2(cx, cy + r*0.2f), ImVec2(cx + r*0.7f, cy + r*0.8f), color, strokeWidth);
            break;
        }
        case ICON_CHECK: {
            dl->AddCircle(ImVec2(cx, cy), r, color, 32, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.4f, cy), ImVec2(cx - r*0.1f, cy + r*0.3f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.1f, cy + r*0.3f), ImVec2(cx + r*0.4f, cy - r*0.3f), color, strokeWidth);
            break;
        }
        case ICON_INCREASE: {
            dl->AddLine(ImVec2(cx - hw, cy + hw*0.5f), ImVec2(cx, cy - hw*0.2f), color, strokeWidth);
            dl->AddLine(ImVec2(cx, cy - hw*0.2f), ImVec2(cx + hw, cy - hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.3f, cy - hw*0.7f), ImVec2(cx + hw, cy - hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw, cy - hw*0.7f), ImVec2(cx + hw, cy - hw*0.0f), color, strokeWidth);
            break;
        }
        case ICON_PHONE: {
            dl->AddBezierQuadratic(ImVec2(cx - r*0.5f, cy - r*0.8f), ImVec2(cx - r*0.8f, cy), ImVec2(cx - r*0.5f, cy + r*0.8f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx + r*0.5f, cy - r*0.8f), ImVec2(cx + r*0.8f, cy), ImVec2(cx + r*0.5f, cy + r*0.8f), color, strokeWidth);
            break;
        }
        case ICON_CALENDAR: {
            dl->AddRect(ImVec2(cx - hw, cy - hw*0.7f), ImVec2(cx + hw, cy + hw), color, 2.0f, 0, strokeWidth);
            dl->AddLine(ImVec2(cx - hw, cy - hw*0.3f), ImVec2(cx + hw, cy - hw*0.3f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy - hw*0.7f), ImVec2(cx - hw*0.5f, cy - hw), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy - hw*0.7f), ImVec2(cx + hw*0.5f, cy - hw), color, strokeWidth);
            break;
        }
        case ICON_WIFI: {
            dl->AddBezierQuadratic(ImVec2(cx - r*0.8f, cy - r*0.2f), ImVec2(cx, cy - r), ImVec2(cx + r*0.8f, cy - r*0.2f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - r*0.5f, cy + r*0.1f), ImVec2(cx, cy - r*0.5f), ImVec2(cx + r*0.5f, cy + r*0.1f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - r*0.25f, cy + r*0.4f), ImVec2(cx, cy), ImVec2(cx + r*0.25f, cy + r*0.4f), color, strokeWidth);
            dl->AddCircleFilled(ImVec2(cx, cy + r*0.6f), strokeWidth*1.5f, color);
            break;
        }
        case ICON_LOCK: {
            dl->AddRect(ImVec2(cx - hw*0.7f, cy - hw*0.1f), ImVec2(cx + hw*0.7f, cy + hw), color, 2.0f, 0, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - hw*0.4f, cy - hw*0.1f), ImVec2(cx - hw*0.4f, cy - hw*0.8f), ImVec2(cx, cy - hw*0.8f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx, cy - hw*0.8f), ImVec2(cx + hw*0.4f, cy - hw*0.8f), ImVec2(cx + hw*0.4f, cy - hw*0.1f), color, strokeWidth);
            break;
        }
        case ICON_THUMBUP: {
            dl->AddLine(ImVec2(cx - hw*0.8f, cy + hw*0.1f), ImVec2(cx - hw*0.8f, cy + hw*0.9f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy + hw*0.1f), ImVec2(cx - hw*0.5f, cy + hw*0.9f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - hw*0.5f, cy + hw*0.1f), ImVec2(cx, cy - hw*0.8f), ImVec2(cx + hw*0.5f, cy - hw*0.3f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy - hw*0.3f), ImVec2(cx + hw*0.8f, cy + hw*0.9f), color, strokeWidth);
            break;
        }
        case ICON_CLOCK: {
            dl->AddCircle(ImVec2(cx, cy), r, color, 32, strokeWidth);
            dl->AddLine(ImVec2(cx, cy), ImVec2(cx, cy - r*0.5f), color, strokeWidth);
            dl->AddLine(ImVec2(cx, cy), ImVec2(cx + r*0.4f, cy + r*0.2f), color, strokeWidth);
            break;
        }
        case ICON_PLAY: {
            ImVec2 pts[3] = {ImVec2(cx - hw*0.4f, cy - hw*0.7f), ImVec2(cx + hw*0.6f, cy), ImVec2(cx - hw*0.4f, cy + hw*0.7f)};
            dl->AddTriangle(pts[0], pts[1], pts[2], color, strokeWidth);
            break;
        }
        case ICON_HOURGLASS: {
            dl->AddLine(ImVec2(cx - hw*0.6f, cy - hw), ImVec2(cx + hw*0.6f, cy - hw), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.6f, cy + hw), ImVec2(cx + hw*0.6f, cy + hw), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy - hw), ImVec2(cx, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy - hw), ImVec2(cx, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy + hw), ImVec2(cx, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy + hw), ImVec2(cx, cy), color, strokeWidth);
            break;
        }
        case ICON_LOCATION: {
            dl->AddCircle(ImVec2(cx, cy - r*0.3f), r*0.3f, color, 24, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - r*0.6f, cy - r*0.3f), ImVec2(cx - r*0.6f, cy - r), ImVec2(cx, cy - r), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx, cy - r), ImVec2(cx + r*0.6f, cy - r), ImVec2(cx + r*0.6f, cy - r*0.3f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.6f, cy - r*0.3f), ImVec2(cx, cy + r), color, strokeWidth);
            dl->AddLine(ImVec2(cx + r*0.6f, cy - r*0.3f), ImVec2(cx, cy + r), color, strokeWidth);
            break;
        }
        case ICON_SHOPPING: {
            dl->AddLine(ImVec2(cx - hw*0.8f, cy - hw*0.6f), ImVec2(cx + hw*0.8f, cy - hw*0.6f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.6f, cy - hw*0.6f), ImVec2(cx - hw*0.4f, cy + hw*0.6f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.6f, cy - hw*0.6f), ImVec2(cx + hw*0.4f, cy + hw*0.6f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.4f, cy + hw*0.6f), ImVec2(cx + hw*0.4f, cy + hw*0.6f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - hw*0.5f, cy - hw*0.6f), ImVec2(cx - hw*0.5f, cy - hw), ImVec2(cx, cy - hw), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx, cy - hw), ImVec2(cx + hw*0.5f, cy - hw), ImVec2(cx + hw*0.5f, cy - hw*0.6f), color, strokeWidth);
            break;
        }
        case ICON_UPLOAD: {
            dl->AddLine(ImVec2(cx, cy - hw*0.7f), ImVec2(cx, cy + hw*0.5f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.4f, cy - hw*0.3f), ImVec2(cx, cy - hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.4f, cy - hw*0.3f), ImVec2(cx, cy - hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.7f, cy + hw*0.8f), ImVec2(cx + hw*0.7f, cy + hw*0.8f), color, strokeWidth);
            break;
        }
        case ICON_LAPTOP: {
            dl->AddRect(ImVec2(cx - hw, cy - hw*0.5f), ImVec2(cx + hw, cy + hw*0.3f), color, 2.0f, 0, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*1.2f, cy + hw*0.7f), ImVec2(cx + hw*1.2f, cy + hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw, cy + hw*0.3f), ImVec2(cx - hw*1.2f, cy + hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw, cy + hw*0.3f), ImVec2(cx + hw*1.2f, cy + hw*0.7f), color, strokeWidth);
            break;
        }
        case ICON_PIECHART: {
            dl->AddCircle(ImVec2(cx, cy), r, color, 32, strokeWidth);
            dl->AddLine(ImVec2(cx, cy), ImVec2(cx, cy - r), color, strokeWidth);
            dl->AddLine(ImVec2(cx, cy), ImVec2(cx + r*0.7f, cy + r*0.7f), color, strokeWidth);
            break;
        }
        case ICON_MAIL: {
            dl->AddRect(ImVec2(cx - hw, cy - hw*0.6f), ImVec2(cx + hw, cy + hw*0.6f), color, 0, 0, strokeWidth);
            dl->AddLine(ImVec2(cx - hw, cy - hw*0.6f), ImVec2(cx, cy + hw*0.1f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw, cy - hw*0.6f), ImVec2(cx, cy + hw*0.1f), color, strokeWidth);
            break;
        }
        case ICON_BULB: {
            dl->AddCircle(ImVec2(cx, cy - r*0.2f), r*0.6f, color, 24, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.3f, cy + r*0.4f), ImVec2(cx - r*0.3f, cy + r*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + r*0.3f, cy + r*0.4f), ImVec2(cx + r*0.3f, cy + r*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.3f, cy + r*0.8f), ImVec2(cx + r*0.3f, cy + r*0.8f), color, strokeWidth);
            break;
        }
        case ICON_CROSS: {
            dl->AddCircle(ImVec2(cx, cy), r, color, 32, strokeWidth);
            dl->AddLine(ImVec2(cx - r*0.5f, cy - r*0.5f), ImVec2(cx + r*0.5f, cy + r*0.5f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + r*0.5f, cy - r*0.5f), ImVec2(cx - r*0.5f, cy + r*0.5f), color, strokeWidth);
            break;
        }
        case ICON_LOGIN: {
            dl->AddLine(ImVec2(cx - hw*0.2f, cy), ImVec2(cx + hw*0.8f, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.4f, cy - hw*0.4f), ImVec2(cx + hw*0.8f, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.4f, cy + hw*0.4f), ImVec2(cx + hw*0.8f, cy), color, strokeWidth);
            dl->AddRect(ImVec2(cx - hw*0.8f, cy - hw*0.7f), ImVec2(cx - hw*0.2f, cy + hw*0.7f), color, 0, 0, strokeWidth);
            break;
        }
        case ICON_HEART: {
            dl->AddBezierQuadratic(ImVec2(cx, cy + r*0.8f), ImVec2(cx - r*1.2f, cy - r*0.2f), ImVec2(cx, cy - r*0.4f), color, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx, cy - r*0.4f), ImVec2(cx + r*1.2f, cy - r*0.2f), ImVec2(cx, cy + r*0.8f), color, strokeWidth);
            break;
        }
        case ICON_STAR: {
            float outer = r;
            float inner = r * 0.4f;
            ImVec2 pts[10];
            for (int i = 0; i < 10; i++) {
                float angle = (i * 36.0f - 90.0f) * 3.14159f / 180.0f;
                float rad = (i % 2 == 0) ? outer : inner;
                pts[i] = ImVec2(cx + rad * cosf(angle), cy + rad * sinf(angle));
            }
            for (int i = 0; i < 10; i++) {
                dl->AddLine(pts[i], pts[(i + 1) % 10], color, strokeWidth);
            }
            break;
        }
        case ICON_SEARCH: {
            dl->AddCircle(ImVec2(cx - r*0.2f, cy - r*0.2f), r*0.6f, color, 24, strokeWidth);
            dl->AddLine(ImVec2(cx + r*0.2f, cy + r*0.2f), ImVec2(cx + r*0.8f, cy + r*0.8f), color, strokeWidth);
            break;
        }
        case ICON_HOME: {
            dl->AddLine(ImVec2(cx, cy - hw*0.8f), ImVec2(cx - hw*0.8f, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx, cy - hw*0.8f), ImVec2(cx + hw*0.8f, cy), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.6f, cy - hw*0.1f), ImVec2(cx - hw*0.6f, cy + hw*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.6f, cy - hw*0.1f), ImVec2(cx + hw*0.6f, cy + hw*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.6f, cy + hw*0.8f), ImVec2(cx + hw*0.6f, cy + hw*0.8f), color, strokeWidth);
            break;
        }
        case ICON_SETTINGS: {
            dl->AddCircle(ImVec2(cx, cy), r*0.4f, color, 24, strokeWidth);
            for (int i = 0; i < 8; i++) {
                float angle = i * 45.0f * 3.14159f / 180.0f;
                dl->AddLine(ImVec2(cx + r*0.5f * cosf(angle), cy + r*0.5f * sinf(angle)),
                           ImVec2(cx + r * cosf(angle), cy + r * sinf(angle)), color, strokeWidth);
            }
            break;
        }
        case ICON_USER: {
            dl->AddCircle(ImVec2(cx, cy - r*0.4f), r*0.4f, color, 24, strokeWidth);
            dl->AddBezierQuadratic(ImVec2(cx - r*0.8f, cy + r*0.9f), ImVec2(cx, cy + r*0.2f), ImVec2(cx + r*0.8f, cy + r*0.9f), color, strokeWidth);
            break;
        }
        case ICON_DOWNLOAD: {
            dl->AddLine(ImVec2(cx, cy + hw*0.5f), ImVec2(cx, cy - hw*0.7f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.4f, cy + hw*0.1f), ImVec2(cx, cy + hw*0.5f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.4f, cy + hw*0.1f), ImVec2(cx, cy + hw*0.5f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.7f, cy + hw*0.8f), ImVec2(cx + hw*0.7f, cy + hw*0.8f), color, strokeWidth);
            break;
        }
        case ICON_SHARE: {
            dl->AddCircle(ImVec2(cx + hw*0.5f, cy - hw*0.5f), r*0.25f, color, 16, strokeWidth);
            dl->AddCircle(ImVec2(cx - hw*0.5f, cy), r*0.25f, color, 16, strokeWidth);
            dl->AddCircle(ImVec2(cx + hw*0.5f, cy + hw*0.5f), r*0.25f, color, 16, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.3f, cy - hw*0.1f), ImVec2(cx + hw*0.3f, cy - hw*0.4f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.3f, cy + hw*0.1f), ImVec2(cx + hw*0.3f, cy + hw*0.4f), color, strokeWidth);
            break;
        }
        case ICON_BOOKMARK: {
            dl->AddLine(ImVec2(cx - hw*0.5f, cy - hw*0.8f), ImVec2(cx - hw*0.5f, cy + hw*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy - hw*0.8f), ImVec2(cx + hw*0.5f, cy + hw*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy - hw*0.8f), ImVec2(cx + hw*0.5f, cy - hw*0.8f), color, strokeWidth);
            dl->AddLine(ImVec2(cx - hw*0.5f, cy + hw*0.8f), ImVec2(cx, cy + hw*0.3f), color, strokeWidth);
            dl->AddLine(ImVec2(cx + hw*0.5f, cy + hw*0.8f), ImVec2(cx, cy + hw*0.3f), color, strokeWidth);
            break;
        }
        case ICON_CAMERA: {
            dl->AddRect(ImVec2(cx - hw, cy - hw*0.4f), ImVec2(cx + hw, cy + hw*0.7f), color, 4.0f, 0, strokeWidth);
            dl->AddCircle(ImVec2(cx, cy + hw*0.1f), r*0.4f, color, 24, strokeWidth);
            dl->AddRect(ImVec2(cx - hw*0.3f, cy - hw*0.7f), ImVec2(cx + hw*0.3f, cy - hw*0.4f), color, 0, 0, strokeWidth);
            break;
        }
        default:
            dl->AddRect(ImVec2(cx - hw*0.6f, cy - hw*0.6f), ImVec2(cx + hw*0.6f, cy + hw*0.6f), color, 0, 0, strokeWidth);
            break;
    }
}

// ============================================================================
// ANIMATION TYPES
// ============================================================================
enum AnimationType {
    ANIM_NONE = 0,
    ANIM_FADE_IN,
    ANIM_SLIDE_UP,
    ANIM_SLIDE_DOWN,
    ANIM_SLIDE_LEFT,
    ANIM_SLIDE_RIGHT,
    ANIM_ZOOM_IN,
    ANIM_ZOOM_OUT,
    ANIM_BOUNCE,
    ANIM_ROTATE_IN,
    ANIM_CAROUSEL
};

static const char* g_AnimationNames[] = {
    "None",
    "Fade In",
    "Slide Up",
    "Slide Down",
    "Slide Left",
    "Slide Right",
    "Zoom In",
    "Zoom Out",
    "Bounce",
    "Rotate In",
    "Carousel (Horizontal Scroll)"
};

// ============================================================================
// IMAGE TEXTURE CACHE
// ============================================================================
struct ImageTexture {
    GLuint id;
    int width, height;
    bool loaded;
};
static std::map<std::string, ImageTexture> g_ImageCache;

// ============================================================================
// POSTGRESQL DATABASE CONNECTION
// ============================================================================
static PGconn* g_DBConnection = nullptr;
static bool g_UseDatabase = false;  // Toggle between JSON and PostgreSQL

// Initialize database connection
bool InitDatabase() {
    // PostgreSQL connection string (using current system user and no password)
    const char* conninfo = "host=localhost port=5432 dbname=website_builder";

    g_DBConnection = PQconnectdb(conninfo);

    if (PQstatus(g_DBConnection) != CONNECTION_OK) {
        printf("PostgreSQL connection failed: %s\n", PQerrorMessage(g_DBConnection));
        PQfinish(g_DBConnection);
        g_DBConnection = nullptr;
        return false;
    }

    printf("PostgreSQL connected successfully!\n");
    g_UseDatabase = true;

    // Ensure position/size columns exist in sections table
    PGresult* alterRes;
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS x_position REAL DEFAULT 0");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS width REAL DEFAULT 800");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS z_index INTEGER DEFAULT 0");
    PQclear(alterRes);
    // Add free_design_mode to templates table
    alterRes = PQexec(g_DBConnection, "ALTER TABLE templates ADD COLUMN IF NOT EXISTS free_design_mode BOOLEAN DEFAULT TRUE");
    PQclear(alterRes);
    // Add margin columns to sections table
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS margin_top REAL DEFAULT 10");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS margin_right REAL DEFAULT 10");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS margin_bottom REAL DEFAULT 10");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS margin_left REAL DEFAULT 10");
    PQclear(alterRes);
    // Add page columns to sections table for multi-page support
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS page_index INTEGER DEFAULT 0");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE sections ADD COLUMN IF NOT EXISTS page_name TEXT DEFAULT 'Home'");
    PQclear(alterRes);
    printf("Database schema updated: position/size/margin/page columns ensured.\n");

    return true;
}

// Close database connection
void CloseDatabase() {
    if (g_DBConnection) {
        PQfinish(g_DBConnection);
        g_DBConnection = nullptr;
    }
}

// Helper: Escape string for SQL
std::string SQLEscape(const std::string& str) {
    if (!g_DBConnection) return str;
    char* escaped = new char[str.length() * 2 + 1];
    int error = 0;
    PQescapeStringConn(g_DBConnection, escaped, str.c_str(), str.length(), &error);
    std::string result(escaped);
    delete[] escaped;
    return result;
}

// Helper: Convert color to string "r,g,b,a"
std::string ColorToSQL(const ImVec4& color) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%.3f,%.3f,%.3f,%.3f", color.x, color.y, color.z, color.w);
    return std::string(buf);
}

// Helper: Convert string to color
ImVec4 SQLToColor(const std::string& str) {
    ImVec4 color;
    if (sscanf(str.c_str(), "%f,%f,%f,%f", &color.x, &color.y, &color.z, &color.w) != 4) {
        return ImVec4(0.1f, 0.1f, 0.1f, 1.0f); // Default dark color
    }
    return color;
}

ImageTexture LoadTexture(const std::string& path) {
    if (path.empty()) return {0, 0, 0, false};
    if (g_ImageCache.count(path) && g_ImageCache[path].loaded) {
        printf("‚úÖ Image loaded from cache: %s (ID=%d)\n", path.c_str(), g_ImageCache[path].id);
        return g_ImageCache[path];
    }

    ImageTexture tex = {0, 0, 0, false};
    int channels;
    printf("üì∏ Loading image: %s\n", path.c_str());
    unsigned char* data = stbi_load(path.c_str(), &tex.width, &tex.height, &channels, 4);
    if (data) {
        glGenTextures(1, &tex.id);
        glBindTexture(GL_TEXTURE_2D, tex.id);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, tex.width, tex.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
        stbi_image_free(data);
        tex.loaded = true;
        g_ImageCache[path] = tex;
        printf("‚úÖ Image loaded successfully: %dx%d, ID=%d\n", tex.width, tex.height, tex.id);
    } else {
        printf("‚ùå Failed to load image: %s\n", path.c_str());
    }
    return tex;
}

// Decode PostgreSQL hex BYTEA format (\xHEXHEX...) to raw binary
std::vector<unsigned char> DecodePostgresHexBytea(const char* hex_string, size_t length) {
    std::vector<unsigned char> binary;

    // PostgreSQL hex format starts with '\x'
    if (length < 2 || hex_string[0] != '\\' || hex_string[1] != 'x') {
        printf("ERROR: Invalid PostgreSQL hex BYTEA format (missing \\x prefix)\n");
        return binary;
    }

    // Skip the '\x' prefix
    const char* hex = hex_string + 2;
    size_t hex_len = length - 2;

    // Each byte is represented by 2 hex characters
    binary.reserve(hex_len / 2);

    for (size_t i = 0; i < hex_len; i += 2) {
        if (i + 1 >= hex_len) break;

        // Convert two hex characters to one byte
        char hex_byte[3] = {hex[i], hex[i+1], '\0'};
        unsigned int byte_val;
        sscanf(hex_byte, "%2x", &byte_val);
        binary.push_back((unsigned char)byte_val);
    }

    return binary;
}

// Load texture from memory buffer (for database BLOB data)
ImageTexture LoadTextureFromMemory(const unsigned char* buffer, size_t size, const std::string& cache_key) {
    if (!buffer || size == 0) return {0, 0, 0, false};
    if (!cache_key.empty() && g_ImageCache.count(cache_key) && g_ImageCache[cache_key].loaded) {
        return g_ImageCache[cache_key];
    }

    ImageTexture tex = {0, 0, 0, false};
    int channels;
    unsigned char* data = stbi_load_from_memory(buffer, size, &tex.width, &tex.height, &channels, 4);
    if (data) {
        glGenTextures(1, &tex.id);
        glBindTexture(GL_TEXTURE_2D, tex.id);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, tex.width, tex.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
        stbi_image_free(data);
        tex.loaded = true;
        if (!cache_key.empty()) {
            g_ImageCache[cache_key] = tex;
        }
    }
    return tex;
}

// Read image file into binary buffer
std::vector<unsigned char> ReadImageFile(const std::string& filepath) {
    std::vector<unsigned char> buffer;
    std::ifstream file(filepath, std::ios::binary | std::ios::ate);
    if (!file.is_open()) return buffer;

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    buffer.resize(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        buffer.clear();
    }
    return buffer;
}

// Convert binary data to hex string for PostgreSQL BYTEA
std::string BinaryToHex(const std::vector<unsigned char>& data) {
    if (data.empty()) return "";
    std::ostringstream oss;
    oss << "E'\\\\x";  // PostgreSQL escape string format for BYTEA hex
    for (unsigned char byte : data) {
        oss << std::hex << std::setw(2) << std::setfill('0') << (int)byte;
    }
    oss << "'";
    return oss.str();
}

// Convert vector of strings to PostgreSQL TEXT array
std::string StringVectorToArray(const std::vector<std::string>& vec) {
    if (vec.empty()) return "'{}'";
    std::ostringstream oss;
    oss << "ARRAY[";
    for (size_t i = 0; i < vec.size(); i++) {
        if (i > 0) oss << ",";
        oss << "'" << SQLEscape(vec[i]) << "'";
    }
    oss << "]";
    return oss.str();
}

// Convert vector of image files to PostgreSQL BYTEA array
std::string ImageVectorToByteaArray(const std::vector<std::string>& image_paths) {
    if (image_paths.empty()) return "'{}'";
    std::ostringstream oss;
    oss << "ARRAY[";
    for (size_t i = 0; i < image_paths.size(); i++) {
        if (i > 0) oss << ",";
        std::vector<unsigned char> img_data = ReadImageFile(image_paths[i]);
        if (!img_data.empty()) {
            oss << BinaryToHex(img_data);
        } else {
            oss << "NULL";
        }
    }
    oss << "]::bytea[]";
    return oss.str();
}

// Parse PostgreSQL TEXT[] array to vector<string>
std::vector<std::string> ParsePostgresArray(const char* pg_array) {
    std::vector<std::string> result;
    if (!pg_array || pg_array[0] != '{') return result;

    std::string str(pg_array);
    size_t start = 1;  // Skip opening '{'
    size_t end = str.find_last_of('}');
    if (end == std::string::npos) return result;

    std::string content = str.substr(start, end - start);
    if (content.empty()) return result;

    // Simple parser for comma-separated values
    size_t pos = 0;
    while (pos < content.length()) {
        if (content[pos] == '"') {
            // Quoted string
            size_t quote_end = content.find('"', pos + 1);
            if (quote_end != std::string::npos) {
                result.push_back(content.substr(pos + 1, quote_end - pos - 1));
                pos = quote_end + 1;
                if (pos < content.length() && content[pos] == ',') pos++;
            } else {
                break;
            }
        } else {
            // Unquoted value
            size_t comma = content.find(',', pos);
            if (comma == std::string::npos) {
                result.push_back(content.substr(pos));
                break;
            } else {
                result.push_back(content.substr(pos, comma - pos));
                pos = comma + 1;
            }
        }
    }
    return result;
}

// Forward declarations
struct WebSection;

// Normal Mode Page structure - each page has its own sections
struct NormalModePage {
    std::string name;
    std::vector<WebSection> sections;
    NormalModePage(const std::string& n = "Page") : name(n) {}
};

static std::vector<NormalModePage> g_NormalPages;  // All pages in Normal Mode
static int g_NormalPageIndex = 0;                   // Currently selected page in Normal Mode
static std::vector<WebSection> g_Sections;          // Sections of current page (for compatibility)
static std::vector<std::string> g_Pages;            // Page names (for compatibility)
void PreviewFigmaWebsite();           // Preview Figma layers in browser (screenshot mode)
void PreviewFigmaWebsiteRealLayout(); // Preview using real ImGui elements
void PreviewFigmaAsHTML();            // Simple HTML preview - no build required
bool IsInternalUrl(const std::string& href, const std::string& sourceUrl);  // Check if URL is internal
void ConvertLayersToSections();       // Convert Figma layers to Normal mode sections

// ============================================================================
// URL IMPORT STRUCTURES
// ============================================================================
struct ColorPalette {
    ImVec4 primary;
    ImVec4 secondary;
    ImVec4 accent;
    ImVec4 background;
    ImVec4 text;
};

struct DetectedSection {
    std::string type;  // "navbar", "hero", "cards", etc.
    std::string title;
    std::string subtitle;
    std::string content;
    std::vector<std::string> links;
    std::vector<std::string> images;
    ColorPalette colors;
    float estimated_height;
};

// ============================================================================
// PHASE 1: DYNAMIC SECTION TYPES
// ============================================================================
#include "layout_engine.h"

// Property Definition - describes a single configurable property
struct PropertyDefinition {
    std::string name;
    std::string display_name;
    std::string property_type;
    std::string default_value;
    float min_value;
    float max_value;
    std::string category;
};

// Section Type Definition - replaces hard-coded enum
struct SectionTypeDefinition {
    int id;
    std::string type_name;
    std::string display_name;
    std::string description;
    bool is_builtin;
    std::vector<PropertyDefinition> properties;
    std::string default_layout;
    std::string preview_template;
};

// Global registry of section types
static std::map<std::string, SectionTypeDefinition> g_SectionTypes;
static std::vector<std::string> g_SectionTypeNames;

// ============================================================================
// PHASE 2: LAYOUT ENGINE (already in layout_engine.h)
// ============================================================================
enum LayoutMode {
    LAYOUT_STACKED = 0,
    LAYOUT_FLEXBOX = 1,
    LAYOUT_GRID = 2,
    LAYOUT_ABSOLUTE = 3
};

// ============================================================================
// PHASE 3: INTERACTIVE ELEMENTS
// ============================================================================
enum InteractiveType {
    INTERACT_NONE = 0,
    INTERACT_DROPDOWN,
    INTERACT_CAROUSEL,
    INTERACT_MODAL,
    INTERACT_ACCORDION,
    INTERACT_TAB,
    INTERACT_BUTTON_HOVER,
    INTERACT_IMAGE_LIGHTBOX
};

// Interactive element state
struct InteractiveState {
    bool is_hovered;
    bool is_active;
    bool is_expanded;
    int active_index;
    float animation_progress;  // 0.0 to 1.0
    float hover_time;

    InteractiveState() : is_hovered(false), is_active(false), is_expanded(false),
                         active_index(0), animation_progress(0), hover_time(0) {}
};

// Hover state style overrides
struct HoverStyle {
    bool enabled;
    ImVec4 bg_color;
    ImVec4 text_color;
    float scale;
    float opacity;
    float border_width;
    ImVec4 border_color;
    std::string transform;

    HoverStyle() : enabled(false), bg_color(0,0,0,0), text_color(1,1,1,1),
                   scale(1.0f), opacity(1.0f), border_width(0), border_color(1,1,1,0.5f) {}
};

// Interactive element definition
struct InteractiveElement {
    InteractiveType type;
    std::string id;
    InteractiveState state;
    HoverStyle hover_style;

    // Dropdown specific
    std::vector<std::string> dropdown_items;
    int selected_dropdown_index;

    // Carousel specific
    std::vector<std::string> carousel_images;
    std::vector<GLuint> carousel_texture_ids;
    float carousel_auto_play_speed;
    bool carousel_show_dots;
    bool carousel_show_arrows;

    // Modal specific
    std::string modal_title;
    std::string modal_content;
    float modal_width;
    float modal_height;
    bool modal_backdrop_blur;

    // Accordion specific
    std::vector<std::pair<std::string, std::string>> accordion_items;
    std::vector<bool> accordion_expanded;

    // Animation
    float transition_duration;
    std::string easing_function;

    InteractiveElement() : type(INTERACT_NONE), selected_dropdown_index(0),
                          carousel_auto_play_speed(0), carousel_show_dots(true),
                          carousel_show_arrows(true), modal_width(600), modal_height(400),
                          modal_backdrop_blur(true), transition_duration(0.3f),
                          easing_function("ease-in-out") {}
};

// ============================================================================
// CONNECTOR DATA STRUCTURES
// ============================================================================

// Text segment for text_connector (supports bold/normal text)
struct TextSegment {
    std::string text;
    bool isBold;
    TextSegment() : isBold(false) {}
};

// Text block for text_connector (multiple segments with styling)
struct TextBlock {
    std::vector<TextSegment> segments;
    float fontSize;
    ImVec4 textColor;
    ImVec4 boldColor;
    float lineSpacing;
    TextBlock() : fontSize(16), textColor(0.3f, 0.3f, 0.3f, 1), boldColor(0.1f, 0.1f, 0.1f, 1), lineSpacing(1.5f) {}
};

// Bar item for bar_connector (colored heading bars)
struct BarItem {
    char heading[256];
    ImVec4 barColor;
    float barWidth;
    float barHeight;
    ImVec4 headingColor;
    float headingSize;
    float headingBoldness;
    float paddingLeft;
    BarItem() : barColor(0.9f, 0.45f, 0.2f, 1), barWidth(800), barHeight(50),
                headingColor(1, 1, 1, 1), headingSize(1.3f), headingBoldness(1.5f), paddingLeft(20) {
        strcpy(heading, "HEADING");
    }
};

// Column for footer_connector (multi-column footer)
struct FooterColumn {
    char heading[256];
    std::vector<std::string> items;
    FooterColumn() { strcpy(heading, "Column"); }
};

// Thumbnail card for Card_connector (image cards with text)
struct ThumbnailCard {
    GLuint textureID;
    int imageWidth;
    int imageHeight;
    std::string imagePath;
    char heading[256];
    char description[1024];
    ImVec4 headingColor;
    ImVec4 descriptionColor;
    ImVec4 cardColor;
    ImVec4 borderColor;
    float headingSize;
    float descriptionSize;
    float headingBoldness;
    float descriptionBoldness;
    float cardWidth;
    float cardHeight;
    float borderThickness;
    // Action settings
    int actionType;
    char actionTarget[512];
    bool showReadMore;  // Option to show/hide READ MORE button
    float cardBorderRadius;  // 0 = rectangle, higher = more rounded
    float imageHeightPercent;  // Image height as percentage of card height (0-100)
    ThumbnailCard() : textureID(0), imageWidth(0), imageHeight(0),
                      headingColor(1, 1, 1, 1), descriptionColor(0.7f, 0.7f, 0.7f, 1),
                      cardColor(0.14f, 0.14f, 0.16f, 1), borderColor(0.3f, 0.3f, 0.3f, 1),
                      headingSize(1.2f), descriptionSize(1.0f), headingBoldness(1.0f),
                      descriptionBoldness(0), cardWidth(280), cardHeight(340), borderThickness(1),
                      actionType(0), showReadMore(true), cardBorderRadius(4.0f), imageHeightPercent(45.0f) {
        strcpy(heading, "Card Title");
        strcpy(description, "Description text");
        strcpy(actionTarget, "");
    }
};

// Service card with badge tag (like IMAGING, 3D & ANIMATION, etc.)
struct ServiceCard {
    GLuint textureID;
    int imageWidth;
    int imageHeight;
    std::string imagePath;
    char title[256];           // Card title (e.g., "Imaging Services")
    char badgeText[64];        // Badge tag text (e.g., "IMAGING")
    ImVec4 titleColor;
    ImVec4 badgeColor;         // Badge background color
    ImVec4 badgeTextColor;
    ImVec4 cardBgColor;        // Card background
    float cardWidth;
    float cardHeight;
    float borderRadius;
    int actionType;
    char actionTarget[512];
    ServiceCard() : textureID(0), imageWidth(0), imageHeight(0),
                    titleColor(0.1f, 0.1f, 0.15f, 1),
                    badgeColor(0.3f, 0.5f, 0.9f, 1),
                    badgeTextColor(1, 1, 1, 1),
                    cardBgColor(1, 1, 1, 1),
                    cardWidth(280), cardHeight(220), borderRadius(12.0f),
                    actionType(0) {
        strcpy(title, "Service Title");
        strcpy(badgeText, "CATEGORY");
        strcpy(actionTarget, "");
    }
};

// ============================================================================
// NEW CONNECTOR STRUCTS
// ============================================================================

// Story section feature badge (colored dot + text)
struct StoryFeatureBadge {
    char text[128];
    ImVec4 dotColor;
    StoryFeatureBadge() : dotColor(0.95f, 0.6f, 0.2f, 1) {
        strcpy(text, "Feature Item");
    }
};

// Services section card item (with image, icon, bullets)
struct ServicesSectionCard {
    char title[256];
    char description[1024];
    int iconType;                    // From IconType enum
    ImVec4 iconBgColor;
    char bullets[6][256];            // Up to 6 bullet points
    int bulletCount;
    char linkText[64];
    int linkActionType;
    char linkTarget[512];
    ImVec4 titleColor;
    ImVec4 descColor;
    ImVec4 bulletColor;
    ImVec4 linkColor;
    ImVec4 cardBgColor;
    float borderRadius;
    // Image properties
    std::string imagePath;
    GLuint textureID;
    int imageWidth, imageHeight;
    float imageHeight_display;       // Height of image area in card

    ServicesSectionCard() : iconType(ICON_STAR),
                            iconBgColor(0.95f, 0.5f, 0.2f, 1),
                            bulletCount(3),
                            linkActionType(0),
                            titleColor(0.1f, 0.1f, 0.15f, 1),
                            descColor(0.3f, 0.3f, 0.35f, 1),
                            bulletColor(0.95f, 0.5f, 0.2f, 1),
                            linkColor(0.95f, 0.5f, 0.2f, 1),
                            cardBgColor(1, 1, 1, 1),
                            borderRadius(12.0f),
                            textureID(0), imageWidth(0), imageHeight(0),
                            imageHeight_display(180.0f) {
        strcpy(title, "Service Title");
        strcpy(description, "Service description goes here.");
        strcpy(bullets[0], "Feature one");
        strcpy(bullets[1], "Feature two");
        strcpy(bullets[2], "Feature three");
        for (int i = 3; i < 6; i++) bullets[i][0] = '\0';
        strcpy(linkText, "Learn More");
        strcpy(linkTarget, "");
    }
};

// Client/Partner logo item
struct ClientItem {
    char name[128];           // Company name displayed below logo
    char logoText[64];        // Text-based logo (if no image)
    bool useTextLogo;         // True = use text, False = use image
    std::string imagePath;
    GLuint textureID;
    int imageWidth, imageHeight;
    ImVec4 textColor;
    ImVec4 cardBgColor;
    int actionType;
    char actionTarget[512];

    ClientItem() : useTextLogo(true), textureID(0), imageWidth(0), imageHeight(0),
                   textColor(0.2f, 0.2f, 0.25f, 1),
                   cardBgColor(1, 1, 1, 1),
                   actionType(0) {
        strcpy(name, "Company Name");
        strcpy(logoText, "LOGO");
        strcpy(actionTarget, "");
    }
};

// Feature card item (icon + title + description + checkmarks)
struct FeatureCardItem {
    char title[256];
    char description[1024];
    int iconType;
    ImVec4 iconBgColor;
    char checkmarks[6][256];     // Up to 6 checkmark items
    int checkmarkCount;
    ImVec4 titleColor;
    ImVec4 descColor;
    ImVec4 checkColor;
    ImVec4 cardBgColor;
    float borderRadius;

    FeatureCardItem() : iconType(ICON_SETTINGS),
                        iconBgColor(0.95f, 0.5f, 0.2f, 1),
                        checkmarkCount(3),
                        titleColor(0.1f, 0.1f, 0.15f, 1),
                        descColor(0.3f, 0.3f, 0.35f, 1),
                        checkColor(0.95f, 0.5f, 0.2f, 1),
                        cardBgColor(1, 1, 1, 1),
                        borderRadius(12.0f) {
        strcpy(title, "Feature Title");
        strcpy(description, "Feature description goes here.");
        strcpy(checkmarks[0], "Checkmark item one");
        strcpy(checkmarks[1], "Checkmark item two");
        strcpy(checkmarks[2], "Checkmark item three");
        for (int i = 3; i < 6; i++) checkmarks[i][0] = '\0';
    }
};

// Process timeline step
struct ProcessStep {
    char title[128];
    char description[512];
    int iconType;
    ImVec4 iconBgColor;
    ImVec4 numberBgColor;
    ImVec4 numberTextColor;
    ImVec4 titleColor;
    ImVec4 descColor;
    ImVec4 cardBgColor;
    float borderRadius;

    ProcessStep() : iconType(ICON_BULB),
                    iconBgColor(0.95f, 0.5f, 0.2f, 1),
                    numberBgColor(0.95f, 0.5f, 0.2f, 1),
                    numberTextColor(0.1f, 0.1f, 0.15f, 1),
                    titleColor(1, 1, 1, 1),
                    descColor(0.7f, 0.7f, 0.75f, 1),
                    cardBgColor(0.15f, 0.18f, 0.25f, 0.8f),
                    borderRadius(8.0f) {
        strcpy(title, "Step Title");
        strcpy(description, "Step description goes here.");
    }
};

// Hero section stat item (icon + number + label)
struct HeroStatItem {
    int iconType;
    char number[32];
    char label[64];
    ImVec4 iconColor;
    ImVec4 numberColor;
    ImVec4 labelColor;

    HeroStatItem() : iconType(ICON_CALENDAR),
                     iconColor(0.95f, 0.5f, 0.2f, 1),
                     numberColor(0.1f, 0.1f, 0.15f, 1),
                     labelColor(0.4f, 0.4f, 0.45f, 1) {
        strcpy(number, "50+");
        strcpy(label, "STAT LABEL");
    }
};

// Hero section feature badge (checkmark + text)
struct HeroFeatureBadge {
    char text[128];
    ImVec4 checkColor;

    HeroFeatureBadge() : checkColor(0.95f, 0.5f, 0.2f, 1) {
        strcpy(text, "Feature Item");
    }
};

// Content block for vertical_connector (vertical text + image layout)
struct VerticalBlock {
    int type; // 0=Heading, 1=Description, 2=Image
    char text[2048];
    std::string imagePath;
    GLuint textureID;
    int imageWidth;
    int imageHeight;
    float displayWidth;
    float posX;
    float posY;
    VerticalBlock() : type(0), textureID(0), imageWidth(0), imageHeight(0),
                      displayWidth(150), posX(400), posY(50) {
        text[0] = '\0';
    }
};

// Navbar menu item for navbar_connector
// Action types for interactive elements
enum ActionType {
    ACTION_NONE = 0,
    ACTION_SCROLL_TO_SECTION,  // Scroll to a section on same page
    ACTION_LINK_TO_PAGE,       // Navigate to another page
    ACTION_EXTERNAL_URL,       // Open external URL
    ACTION_OPEN_POPUP,         // Open a popup/modal
    ACTION_DOWNLOAD,           // Download a file
    ACTION_EMAIL,              // Open email client
    ACTION_PHONE               // Open phone dialer
};

struct NavbarMenuItem {
    char label[256];
    std::vector<std::string> children;  // Dropdown items

    // Action settings
    int actionType;            // ActionType enum
    char actionTarget[512];    // Section name, page name, URL, etc.
    std::vector<int> childActionTypes;      // Action type for each child
    std::vector<std::string> childActionTargets;  // Target for each child

    NavbarMenuItem() : actionType(ACTION_NONE) {
        strcpy(label, "Menu");
        strcpy(actionTarget, "");
    }
};

// Copyright link for copyright bar connector
struct CopyrightLink {
    char text[256];
    char url[512];
    bool isBold;
    int actionType;
    CopyrightLink() : isBold(false), actionType(ACTION_EXTERNAL_URL) {
        strcpy(text, "Link");
        strcpy(url, "#");
    }
};

// Article card for article/blog connector
struct ArticleCard {
    char heading[512];
    char date[64];
    char description[2048];
    char readMoreText[64];

    // Colors
    ImVec4 headingColor;
    ImVec4 dateColor;
    ImVec4 descriptionColor;
    ImVec4 readMoreColor;
    ImVec4 cardBgColor;
    ImVec4 accentColor;      // Left border accent

    // Sizes
    float headingSize;
    float dateSize;
    float descriptionSize;
    float readMoreSize;
    float cardWidth;
    float cardHeight;
    float accentWidth;       // Left border width
    float cardPadding;

    // Action settings
    int headingActionType;
    char headingActionTarget[512];
    int readMoreActionType;
    char readMoreActionTarget[512];

    ArticleCard() :
        headingColor(0.91f, 0.40f, 0.10f, 1.0f),  // Orange
        dateColor(0.5f, 0.5f, 0.5f, 1.0f),         // Gray
        descriptionColor(0.3f, 0.3f, 0.3f, 1.0f),  // Dark gray
        readMoreColor(0.2f, 0.2f, 0.2f, 1.0f),     // Dark
        cardBgColor(0.97f, 0.97f, 0.97f, 1.0f),    // Light gray
        accentColor(0.91f, 0.40f, 0.10f, 1.0f),    // Orange accent
        headingSize(1.0f), dateSize(0.8f), descriptionSize(0.85f), readMoreSize(0.8f),
        cardWidth(500), cardHeight(180), accentWidth(4), cardPadding(20),
        headingActionType(ACTION_EXTERNAL_URL), readMoreActionType(ACTION_EXTERNAL_URL)
    {
        strcpy(heading, "Article Heading");
        strcpy(date, "1 Jan 2025");
        strcpy(description, "Article description text goes here...");
        strcpy(readMoreText, "READ MORE");
        strcpy(headingActionTarget, "#");
        strcpy(readMoreActionTarget, "#");
    }
};

// Bullet column for bullet_connector
struct BulletColumn {
    char subheading[256];
    std::vector<std::string> bullet_items;
    ImVec4 subheadingColor;
    float subheadingSize;
    float subheadingBoldness;

    BulletColumn() :
        subheadingColor(0.1f, 0.1f, 0.1f, 1.0f),
        subheadingSize(1.0f),
        subheadingBoldness(1.5f)
    {
        strcpy(subheading, "Column Heading");
        bullet_items.push_back("Bullet point 1");
        bullet_items.push_back("Bullet point 2");
        bullet_items.push_back("Bullet point 3");
    }
};

// Contact form field for contact_form_connector
struct ContactFormField {
    char label[128];
    char placeholder[256];
    int fieldType;  // 0=text, 1=email, 2=phone, 3=textarea
    float width;    // Width percentage (0.5 = 50% for 2-column, 1.0 = full width)
    bool required;

    ContactFormField() : fieldType(0), width(0.5f), required(false) {
        strcpy(label, "Field");
        strcpy(placeholder, "Enter value...");
    }
};

// ============================================================================
// WEBSITE SECTION
// ============================================================================
struct WebSection {
    int id;
    SectionType type;
    std::string name;
    std::string section_id;
    float x_position;       // X position for free design mode
    float y_position;
    float width;            // Width for free design mode
    float height;
    bool selected;
    int z_index;            // Z-order for layering

    // Content
    std::string title;
    std::string subtitle;
    std::string content;
    std::string button_text;
    std::string button_link;

    // Typography
    float title_font_size;
    float subtitle_font_size;
    float content_font_size;
    float title_font_weight;
    float subtitle_font_weight;
    float content_font_weight;
    ImVec4 title_color;
    ImVec4 subtitle_color;
    ImVec4 content_color;

    // Images
    std::string background_image;
    std::string section_image;
    GLuint bg_texture_id;
    GLuint img_texture_id;
    bool use_bg_image;
    float bg_overlay_opacity;

    // Hero Animation (multiple images slideshow)
    std::vector<std::string> hero_animation_images;
    std::vector<GLuint> hero_animation_texture_ids;
    bool enable_hero_animation;
    float hero_animation_speed;  // seconds per image
    int current_animation_frame;
    float animation_timer;

    // Style
    ImVec4 bg_color;
    ImVec4 text_color;
    ImVec4 accent_color;
    ImVec4 button_bg_color;
    ImVec4 button_text_color;
    float button_font_size;
    float button_font_weight;
    float padding;
    int text_align;

    // Margins (for text elements)
    float margin_top;
    float margin_right;
    float margin_bottom;
    float margin_left;

    // Glass effect for buttons
    bool button_glass_effect;
    float button_glass_opacity;
    ImVec4 button_glass_tint;

    // Navigation specific
    struct NavItem {
        std::string label;
        std::string link;
        std::string target_page;
        std::string target_section;
        ImVec4 text_color;
        float font_size;
        float font_weight;
    };
    std::vector<NavItem> nav_items;
    std::string logo_path;
    GLuint logo_texture_id;
    float logo_size;
    int brand_text_position;  // 0=side (next to), 1=above, 2=below
    ImVec4 nav_bg_color;
    ImVec4 nav_text_color;
    float nav_font_size;
    float nav_font_weight;

    // Cards/Items
    struct CardItem {
        std::string title;
        std::string description;
        std::string image;
        std::string price;
        std::string link;
        ImVec4 bg_color;
        ImVec4 title_color;
        ImVec4 desc_color;
        float title_font_size;
        float desc_font_size;
        float title_font_weight;
        float desc_font_weight;
        GLuint texture_id;
        float width;
        float height;
        // Glass effect
        bool glass_effect;
        float glass_opacity;
        float glass_blur;
        ImVec4 glass_tint;
        // Enhanced glass styling
        float glass_border_radius;
        float glass_border_width;
        ImVec4 glass_border_color;
        bool glass_highlight;        // Top edge highlight/shine
        float glass_highlight_opacity;

        // Modern card design (Screenshot style)
        int card_style;              // 0=old, 1=service(icon+bullets), 2=portfolio(thumbnail)
        ImVec4 icon_color;           // Icon background color (pink, blue, green, etc.)
        std::string icon_emoji;      // Icon emoji or symbol (‚ö°, üåê, üì±, etc.)
        std::vector<std::string> bullet_points;  // Feature list with bullets
        std::string thumbnail_image; // Large thumbnail for portfolio cards
        GLuint thumbnail_texture_id; // Thumbnail texture
        std::vector<std::string> tech_tags;      // Technology tags (React, Node.js, etc.)
        std::string category_badge;  // Badge text (Web Development, Mobile, etc.)

        // Animation
        int anim_direction;          // 0=none, 1=left-to-right, 2=right-to-left (default)
        float anim_progress;         // 0.0 to 1.0
        float anim_delay;            // Delay before animation starts
    };
    std::vector<CardItem> items;

    // Text Paragraphs (for text-heavy sections)
    struct Paragraph {
        std::string text;
        float font_size;
        float font_weight;
        ImVec4 color;
        std::string font_family;
    };
    std::vector<Paragraph> paragraphs;

    // Glass Panels (drag-drop glass elements)
    struct GlassPanel {
        float x, y;           // Position relative to section
        float width, height;
        std::string text;
        float text_size;
        ImVec4 text_color;
        float opacity;
        float blur;
        ImVec4 tint;
        float border_radius;
        bool selected;
    };
    std::vector<GlassPanel> glass_panels;

    // Moveable Image Elements (drag-drop images anywhere in section)
    struct ImageElement {
        float x, y;                  // Position relative to section (pixels)
        float width, height;         // Size in pixels
        std::string image_path;      // Path to image file
        GLuint texture_id;           // OpenGL texture ID
        bool selected;               // Is this image currently selected?
        bool dragging;               // Is this image being dragged?
        float drag_offset_x;         // Mouse offset during drag
        float drag_offset_y;         // Mouse offset during drag
        float border_radius;         // Optional rounded corners
        float opacity;               // Image opacity (0-1)
        bool maintain_aspect_ratio;  // Lock aspect ratio when resizing

        ImageElement() :
            x(100), y(100), width(200), height(200),
            texture_id(0), selected(false), dragging(false),
            drag_offset_x(0), drag_offset_y(0),
            border_radius(0), opacity(1.0f),
            maintain_aspect_ratio(true) {}
    };
    std::vector<ImageElement> moveable_images;

    // Card layout settings
    float card_width;
    float card_height;
    float card_spacing;
    float card_padding;
    int cards_per_row;
    float heading_to_cards_spacing;  // Space between heading and cards

    // FAQ Items
    struct FAQItem {
        std::string question;
        std::string answer;
        ImVec4 question_color;
        ImVec4 answer_color;
        float question_font_size;
        float answer_font_size;
        float question_font_weight;
        bool expanded;
    };
    std::vector<FAQItem> faq_items;

    // Login Card Properties
    float login_card_width;
    float login_card_height;
    float login_card_border_radius;
    float login_card_glass_opacity;
    float login_card_glass_blur;
    ImVec4 login_card_glass_tint;
    ImVec4 login_card_border_color;
    float login_card_border_width;
    // Login input fields
    float login_input_height;
    float login_input_border_radius;
    float login_input_glass_opacity;
    ImVec4 login_input_glass_tint;
    ImVec4 login_input_text_color;
    ImVec4 login_input_placeholder_color;
    // Login button
    float login_button_height;
    float login_button_border_radius;
    float login_button_glass_opacity;
    ImVec4 login_button_glass_tint;
    ImVec4 login_button_text_color;
    // Login field labels
    std::string login_username_placeholder;
    std::string login_password_placeholder;
    std::string login_button_label;

    // Contact Form Properties (user controllable)
    float contact_input_width;       // Width of form inputs (% of container)
    float contact_input_height;      // Height of each input field
    float contact_button_width;      // Width of submit button (% of container)
    float contact_button_height;     // Height of submit button
    float contact_field_spacing;     // Spacing between fields

    // Animation Settings
    AnimationType animation_type;
    float animation_duration;        // in seconds (0.3 to 30.0)
    float animation_delay;           // in seconds (0 to 5.0)
    bool animation_repeat;           // whether to repeat animation
    float card_stagger_delay;        // delay between each card starting (0.1 to 2.0)
    std::string animation_trigger;   // "onload", "onscroll", "onclick"

    // Layout Style (which of the 5 template variations)
    int layout_style;                // 0-4: which layout template was selected

    // Gallery/Images Section
    std::vector<std::string> gallery_images;
    std::vector<GLuint> gallery_texture_ids;
    int gallery_columns;             // number of columns in gallery grid
    float gallery_spacing;           // spacing between images
    bool gallery_lightbox;           // enable lightbox on click

    // Width and Position (for Image and Text Box sections)
    float section_width_percent;     // Width as percentage (30%, 50%, 70%, 100%)
    int horizontal_align;            // 0=Left, 1=Center, 2=Right
    bool use_manual_position;        // True = use y_position manually, False = auto-stack

    // ============================================================================
    // PHASE 1: Dynamic Section Types
    // ============================================================================
    std::string type_name;           // String-based type name
    bool use_legacy_type;            // True = use enum, False = use type_name
    std::map<std::string, std::string> custom_properties;

    // ============================================================================
    // PHASE 2: Flexbox/Grid Layout Engine
    // ============================================================================
    LayoutMode layout_mode;
    FlexboxLayout flexbox_props;
    GridLayout grid_props;

    // ============================================================================
    // PHASE 3: Interactive Elements
    // ============================================================================
    std::vector<InteractiveElement> interactive_elements;
    bool section_hovered;
    float section_hover_time;
    float carousel_timer;
    ImVec2 last_mouse_pos;

    // ============================================================================
    // CSS STYLING PROPERTIES (imported from web scraper)
    // ============================================================================
    // Button CSS
    float button_border_radius;
    float button_border_width;
    ImVec4 button_border_color;
    std::string button_box_shadow;      // e.g., "0px 4px 6px rgba(0,0,0,0.1)"
    std::string button_padding;         // e.g., "10px 20px"

    // Section CSS
    float section_border_radius;
    std::string section_box_shadow;     // e.g., "0px 10px 30px rgba(0,0,0,0.1)"
    std::string section_border;         // e.g., "1px solid rgb(200,200,200)"
    float section_opacity;
    std::string section_line_height;
    std::string section_letter_spacing;

    // ============================================================================
    // LAYOUT PROPERTIES (flexbox, grid, positioning, spacing)
    // ============================================================================
    // 4-sided padding
    float padding_top, padding_right, padding_bottom, padding_left;

    // Flexbox properties
    std::string display;                // "block", "flex", "grid"
    std::string flex_direction;         // "row", "column"
    std::string justify_content;        // "flex-start", "center", "space-between", etc.
    std::string align_items;            // "flex-start", "center", "stretch", etc.
    float gap;                          // Gap between flex items

    // Grid properties
    std::string grid_template_columns;  // e.g., "1fr 1fr 1fr" or "repeat(3, 1fr)"
    std::string grid_template_rows;

    // Background positioning
    std::string background_position;    // e.g., "center center"
    std::string background_repeat;      // e.g., "no-repeat"
    std::string background_size;        // e.g., "cover", "contain"
    std::string background_image_css;   // CSS gradient or image URL

    // Position properties (for overlays and absolute positioning)
    std::string css_position;           // "static", "relative", "absolute", "fixed"
    std::string css_top, css_left, css_right, css_bottom;
    int css_z_index;

    // Typography
    std::string font_family;            // e.g., "Roboto", "Poppins"

    // Gradient support
    bool has_gradient;
    std::vector<ImVec4> gradient_colors;
    bool gradient_is_radial;

    // ==================== CONNECTOR PROPERTIES ====================

    // TEXT CONNECTOR properties
    std::vector<TextBlock> text_blocks;
    float text_content_width;
    float text_padding;

    // BAR CONNECTOR properties
    std::vector<BarItem> bar_items;

    // FOOTER CONNECTOR properties
    std::vector<FooterColumn> footer_columns;
    ImVec4 footer_heading_color;
    ImVec4 footer_subheading_color;
    float footer_heading_size;
    float footer_subheading_size;
    float footer_heading_boldness;
    float footer_subheading_boldness;
    float footer_column_width;
    float footer_item_spacing;

    // CARD CONNECTOR properties
    std::vector<ThumbnailCard> connector_cards;
    int connector_cards_per_row;
    float connector_card_spacing;
    float connector_card_padding;  // Padding from section edges

    // VERTICAL CONNECTOR properties
    std::vector<VerticalBlock> vertical_blocks;
    ImVec4 vertical_heading_color;
    ImVec4 vertical_desc_color;
    float vertical_heading_size;
    float vertical_desc_size;
    float vertical_heading_boldness;
    float vertical_desc_boldness;
    float vertical_content_width;
    float vertical_spacing;

    // NAVBAR CONNECTOR properties
    std::vector<NavbarMenuItem> navbar_items;
    ImVec4 navbar_bg_color;
    ImVec4 navbar_hover_color;
    ImVec4 navbar_dropdown_color;
    ImVec4 navbar_text_color;
    float navbar_height;
    float navbar_padding_x;
    float navbar_padding_y;
    float navbar_spacing;
    float navbar_rounding;
    float navbar_font_scale;
    float navbar_font_boldness;  // 0-3 for text boldness
    bool navbar_rounded;

    // COPYRIGHT CONNECTOR properties
    char copyright_text[512];
    char copyright_subtext[256];
    std::vector<CopyrightLink> copyright_links;
    ImVec4 copyright_bg_color;
    ImVec4 copyright_text_color;
    ImVec4 copyright_link_color;
    float copyright_font_size;
    float copyright_subtext_size;
    float copyright_padding;
    float copyright_bg_opacity;  // 0.0 = fully transparent, 1.0 = fully opaque

    // ARTICLE CONNECTOR properties
    std::vector<ArticleCard> article_cards;
    int article_cards_per_row;
    float article_card_spacing;

    // BULLET CONNECTOR properties
    std::vector<BulletColumn> bullet_columns;
    char bullet_main_heading[512];
    char bullet_footer_text[512];
    ImVec4 bullet_heading_color;
    ImVec4 bullet_item_color;
    float bullet_heading_size;
    float bullet_heading_boldness;
    float bullet_item_size;
    float bullet_column_spacing;

    // CONTACT FORM CONNECTOR properties
    std::vector<ContactFormField> contact_form_fields;
    char contact_form_title[256];
    char contact_form_submit_text[64];
    ImVec4 contact_form_title_color;
    ImVec4 contact_form_input_bg;
    ImVec4 contact_form_input_text;
    ImVec4 contact_form_button_bg;
    ImVec4 contact_form_button_text;
    ImVec4 contact_form_button_border;
    float contact_form_title_size;
    float contact_form_input_height;
    float contact_form_textarea_height;
    float contact_form_button_width;
    float contact_form_button_height;
    float contact_form_spacing;
    int contact_form_submit_action;
    char contact_form_submit_target[512];

    // SEARCH CONNECTOR properties
    char search_placeholder[128];
    char search_button_text[64];
    ImVec4 search_input_bg;
    ImVec4 search_input_border;
    ImVec4 search_input_text;
    ImVec4 search_button_bg;
    ImVec4 search_button_text_color;
    float search_input_width;
    float search_input_height;
    float search_button_width;
    float search_border_radius;

    // Logo Connector properties
    std::string logo_image_path;
    std::vector<unsigned char> logo_image_data;
    GLuint logo_connector_texture;
    int logo_image_width;
    int logo_image_height;
    float logo_width;
    float logo_height;
    bool logo_maintain_aspect;
    int logo_alignment;  // 0=left, 1=center, 2=right
    char logo_link[512];
    ImVec4 logo_bg_color;
    float logo_padding;

    // Icon properties
    int icon_type;           // Which icon from IconType enum
    float icon_size;         // Size of the icon
    ImVec4 icon_color;       // Icon color
    float icon_stroke_width; // Line thickness

    // Service card connector properties
    std::vector<ServiceCard> service_cards;
    int service_cards_per_row;
    float service_card_spacing;

    // Glass bar connector properties
    char glass_bar_text[512];
    char glass_bar_highlight[128];  // Highlighted text portion
    ImVec4 glass_bar_text_color;
    ImVec4 glass_bar_highlight_color;
    ImVec4 glass_bar_bg_color;
    float glass_bar_opacity;
    float glass_bar_border_radius;
    float glass_bar_padding;

    // ========== STORY CONNECTOR ==========
    char story_label[64];            // "OUR STORY"
    char story_heading[256];         // "Five Decades of"
    char story_heading_accent[128];  // "Visual Mastery" (colored)
    char story_paragraphs[3][1024];  // Up to 3 paragraphs
    int story_paragraph_count;
    std::vector<StoryFeatureBadge> story_badges;  // Feature badges with dots
    char story_button_text[64];
    int story_button_action;
    char story_button_target[512];
    char story_stats_number[32];     // "50+"
    char story_stats_label[64];      // Optional label
    ImVec4 story_label_color;
    ImVec4 story_heading_color;
    ImVec4 story_accent_color;
    ImVec4 story_text_color;
    ImVec4 story_button_bg;
    ImVec4 story_button_text_color;
    ImVec4 story_stats_bg;
    ImVec4 story_stats_text_color;
    // Story section images (collage of 3 images)
    std::string story_images[3];          // Image paths
    GLuint story_image_textures[3];       // Texture IDs
    int story_image_widths[3];
    int story_image_heights[3];

    // ========== SERVICES SECTION CONNECTOR ==========
    char services_label[64];
    char services_heading[256];
    char services_heading_accent[128];
    char services_subtitle[512];
    std::vector<ServicesSectionCard> services_cards;
    int services_cards_per_row;
    float services_card_spacing;
    ImVec4 services_label_color;
    ImVec4 services_heading_color;
    ImVec4 services_accent_color;
    ImVec4 services_subtitle_color;

    // ========== CLIENTS GRID CONNECTOR ==========
    char clients_label[64];
    char clients_heading[256];
    char clients_heading_accent[128];
    char clients_subtitle[512];
    std::vector<ClientItem> clients_items;
    int clients_per_row;
    float clients_card_spacing;
    ImVec4 clients_label_color;
    ImVec4 clients_heading_color;
    ImVec4 clients_accent_color;
    ImVec4 clients_subtitle_color;

    // ========== FEATURES GRID CONNECTOR ==========
    char features_label[64];
    char features_heading[256];
    char features_heading_accent[128];
    char features_subtitle[512];
    std::vector<FeatureCardItem> features_cards;
    int features_cards_per_row;
    float features_card_spacing;
    ImVec4 features_label_color;
    ImVec4 features_heading_color;
    ImVec4 features_accent_color;
    ImVec4 features_subtitle_color;

    // ========== PROCESS TIMELINE CONNECTOR ==========
    char process_label[64];
    char process_heading[256];
    char process_heading_accent[128];
    char process_subtitle[512];
    std::vector<ProcessStep> process_steps;
    ImVec4 process_label_color;
    ImVec4 process_heading_color;
    ImVec4 process_accent_color;
    ImVec4 process_subtitle_color;
    ImVec4 process_line_color;
    ImVec4 process_bg_color;         // Section background (dark theme)

    // ========== HERO SECTION CONNECTOR ==========
    char hero_badge_text[128];       // "Your Premier Visual Production Partner"
    int hero_badge_icon_left;        // Icon type for left side
    int hero_badge_icon_right;       // Icon type for right side
    char hero_heading[256];          // "Transforming Ideas into"
    char hero_heading_accent[128];   // "Visual Excellence"
    char hero_description[1024];     // Description paragraph
    char hero_btn_primary_text[64];  // "Explore Our Services"
    char hero_btn_secondary_text[64]; // "Partner With Us"
    int hero_btn_primary_action;
    char hero_btn_primary_target[512];
    int hero_btn_secondary_action;
    char hero_btn_secondary_target[512];
    std::vector<HeroFeatureBadge> hero_feature_badges;  // Row of feature badges
    std::vector<HeroStatItem> hero_stats;               // Stats counter items
    ImVec4 hero_bg_color;
    ImVec4 hero_badge_bg;
    ImVec4 hero_badge_text_color;
    ImVec4 hero_badge_icon_color;
    ImVec4 hero_heading_color;
    ImVec4 hero_accent_color;
    ImVec4 hero_description_color;
    ImVec4 hero_btn_primary_bg;
    ImVec4 hero_btn_primary_text_color;
    ImVec4 hero_btn_secondary_bg;
    ImVec4 hero_btn_secondary_text_color;
    ImVec4 hero_btn_secondary_border;
    float hero_btn_border_radius;
    float hero_badge_border_radius;

    WebSection(int _id, SectionType _type) : id(_id), type(_type),
        x_position(0), y_position(0), width(800), height(300), selected(false), z_index(0),
        title_font_size(48), subtitle_font_size(20), content_font_size(16),
        title_font_weight(700), subtitle_font_weight(400), content_font_weight(400),
        title_color(0.1f,0.1f,0.1f,1), subtitle_color(0.3f,0.3f,0.3f,1), content_color(0.2f,0.2f,0.2f,1),
        bg_texture_id(0), img_texture_id(0), use_bg_image(false), bg_overlay_opacity(0.0f),
        enable_hero_animation(false), hero_animation_speed(3.0f), current_animation_frame(0), animation_timer(0.0f),
        logo_texture_id(0), logo_size(50.0f), brand_text_position(0),
        bg_color(1,1,1,1), text_color(0.1f,0.1f,0.1f,1), accent_color(0.2f,0.5f,1.0f,1),
        button_bg_color(0.2f,0.5f,1.0f,1), button_text_color(1,1,1,1),
        button_font_size(16), button_font_weight(600),
        button_glass_effect(false), button_glass_opacity(0.0f), button_glass_tint(1,1,1,0.0f),
        nav_bg_color(1,1,1,1), nav_text_color(0.2f,0.2f,0.2f,1),
        nav_font_size(15), nav_font_weight(500),
        card_width(300), card_height(250), card_spacing(20), card_padding(25), cards_per_row(3), heading_to_cards_spacing(40),
        padding(60), text_align(1),
        margin_top(10), margin_right(10), margin_bottom(10), margin_left(10),
        // Login card defaults
        login_card_width(400), login_card_height(450), login_card_border_radius(20),
        login_card_glass_opacity(0.25f), login_card_glass_blur(20),
        login_card_glass_tint(0.1f, 0.15f, 0.25f, 1.0f),
        login_card_border_color(1.0f, 1.0f, 1.0f, 0.2f), login_card_border_width(1.5f),
        login_input_height(50), login_input_border_radius(8),
        login_input_glass_opacity(0.15f), login_input_glass_tint(0.0f, 0.1f, 0.2f, 1.0f),
        login_input_text_color(1,1,1,1), login_input_placeholder_color(0.7f, 0.7f, 0.7f, 1.0f),
        login_button_height(50), login_button_border_radius(25),
        login_button_glass_opacity(0.35f), login_button_glass_tint(0.1f, 0.2f, 0.35f, 1.0f),
        login_button_text_color(1,1,1,1),
        login_username_placeholder("Enter Username"), login_password_placeholder("Enter Password"),
        login_button_label("LOGIN"),
        // Contact form defaults
        contact_input_width(80.0f), contact_input_height(28.0f),
        contact_button_width(80.0f), contact_button_height(35.0f),
        contact_field_spacing(38.0f),
        // Animation defaults
        animation_type(ANIM_FADE_IN), animation_duration(1.0f), animation_delay(0.0f),
        animation_repeat(false), card_stagger_delay(0.3f), animation_trigger("onload"),
        // Layout style default
        layout_style(0),
        // Gallery defaults
        gallery_columns(3), gallery_spacing(20.0f), gallery_lightbox(true),
        // Width and position defaults
        section_width_percent(100.0f), horizontal_align(0), use_manual_position(false),
        // Phase 1: Dynamic types
        use_legacy_type(true),
        // Phase 2: Layout engine
        layout_mode(LAYOUT_STACKED),
        // Phase 3: Interactive elements
        section_hovered(false), section_hover_time(0), carousel_timer(0), last_mouse_pos(0,0),
        // CSS styling defaults
        button_border_radius(0.0f), button_border_width(0.0f),
        button_border_color(0,0,0,1), button_box_shadow("none"), button_padding("10px 20px"),
        section_border_radius(0.0f), section_box_shadow("none"),
        section_border("none"), section_opacity(1.0f),
        section_line_height("normal"), section_letter_spacing("normal"),
        // Layout properties defaults
        padding_top(60.0f), padding_right(60.0f), padding_bottom(60.0f), padding_left(60.0f),
        display("block"), flex_direction("row"), justify_content("normal"), align_items("normal"),
        gap(0.0f), grid_template_columns("none"), grid_template_rows("none"),
        background_position("0% 0%"), background_repeat("repeat"), background_size("auto"), background_image_css("none"),
        css_position("static"), css_top("auto"), css_left("auto"), css_right("auto"), css_bottom("auto"), css_z_index(0),
        font_family("system-ui"), has_gradient(false), gradient_is_radial(false),
        // Connector defaults
        text_content_width(700), text_padding(30),
        footer_heading_color(1, 1, 1, 1), footer_subheading_color(1, 1, 1, 0.9f),
        footer_heading_size(1.3f), footer_subheading_size(1.0f),
        footer_heading_boldness(1.5f), footer_subheading_boldness(0),
        footer_column_width(280), footer_item_spacing(8),
        connector_cards_per_row(3), connector_card_spacing(20), connector_card_padding(20),
        vertical_heading_color(0.1f, 0.1f, 0.1f, 1), vertical_desc_color(0.3f, 0.3f, 0.3f, 1),
        vertical_heading_size(1.2f), vertical_desc_size(1.0f),
        vertical_heading_boldness(1.5f), vertical_desc_boldness(0),
        vertical_content_width(500), vertical_spacing(15),
        // Navbar connector defaults
        navbar_bg_color(0.12f, 0.12f, 0.12f, 1), navbar_hover_color(0.26f, 0.26f, 0.26f, 1),
        navbar_dropdown_color(0.18f, 0.18f, 0.18f, 1), navbar_text_color(1, 1, 1, 1),
        navbar_height(42), navbar_padding_x(10), navbar_padding_y(8),
        navbar_spacing(18), navbar_rounding(4), navbar_font_scale(1.0f), navbar_font_boldness(1.0f), navbar_rounded(true),
        copyright_bg_color(0.18f, 0.18f, 0.18f, 1), copyright_text_color(0.7f, 0.7f, 0.7f, 1),
        copyright_link_color(0.9f, 0.9f, 0.9f, 1), copyright_font_size(11.0f), copyright_subtext_size(10.0f),
        copyright_padding(15.0f), copyright_bg_opacity(1.0f),
        // Article connector defaults
        article_cards_per_row(2), article_card_spacing(20.0f),
        // Bullet connector defaults
        bullet_heading_color(0.1f, 0.1f, 0.1f, 1.0f),
        bullet_item_color(0.3f, 0.3f, 0.3f, 1.0f),
        bullet_heading_size(1.2f), bullet_heading_boldness(2.0f),
        bullet_item_size(1.0f), bullet_column_spacing(40.0f),
        // Contact form defaults
        contact_form_title_color(0.1f, 0.1f, 0.1f, 1.0f),
        contact_form_input_bg(0.95f, 0.95f, 0.95f, 1.0f),
        contact_form_input_text(0.4f, 0.4f, 0.4f, 1.0f),
        contact_form_button_bg(1.0f, 1.0f, 1.0f, 1.0f),
        contact_form_button_text(0.2f, 0.6f, 0.9f, 1.0f),
        contact_form_button_border(0.2f, 0.6f, 0.9f, 1.0f),
        contact_form_title_size(1.3f), contact_form_input_height(45.0f),
        contact_form_textarea_height(150.0f), contact_form_button_width(100.0f),
        contact_form_button_height(40.0f), contact_form_spacing(20.0f),
        contact_form_submit_action(ACTION_EMAIL),
        // Search connector defaults
        search_input_bg(1.0f, 1.0f, 1.0f, 1.0f), search_input_border(0.8f, 0.8f, 0.8f, 1.0f),
        search_input_text(0.3f, 0.3f, 0.3f, 1.0f), search_button_bg(0.91f, 0.40f, 0.10f, 1.0f),
        search_button_text_color(1.0f, 1.0f, 1.0f, 1.0f), search_input_width(400.0f),
        search_input_height(42.0f), search_button_width(90.0f), search_border_radius(0.0f),
        // Logo connector defaults
        logo_connector_texture(0), logo_image_width(0), logo_image_height(0),
        logo_width(200.0f), logo_height(80.0f), logo_maintain_aspect(true),
        logo_alignment(1), logo_bg_color(1.0f, 1.0f, 1.0f, 0.0f), logo_padding(20.0f),
        icon_type(ICON_STAR), icon_size(48.0f), icon_color(0.2f, 0.2f, 0.4f, 1.0f), icon_stroke_width(2.0f),
        service_cards_per_row(3), service_card_spacing(20.0f),
        glass_bar_text_color(0.2f, 0.2f, 0.25f, 1.0f), glass_bar_highlight_color(0.3f, 0.5f, 0.9f, 1.0f),
        glass_bar_bg_color(0.95f, 0.95f, 0.98f, 0.9f), glass_bar_opacity(0.9f),
        glass_bar_border_radius(30.0f), glass_bar_padding(20.0f),
        // Story connector defaults
        story_paragraph_count(0), story_button_action(0),
        story_label_color(0.95f, 0.5f, 0.2f, 1), story_heading_color(0.1f, 0.1f, 0.15f, 1),
        story_accent_color(0.95f, 0.5f, 0.2f, 1), story_text_color(0.3f, 0.3f, 0.35f, 1),
        story_button_bg(0.95f, 0.5f, 0.2f, 1), story_button_text_color(1, 1, 1, 1),
        story_stats_bg(0.95f, 0.5f, 0.2f, 1), story_stats_text_color(1, 1, 1, 1),
        story_image_textures{0, 0, 0}, story_image_widths{0, 0, 0}, story_image_heights{0, 0, 0},
        // Services section defaults
        services_cards_per_row(3), services_card_spacing(24.0f),
        services_label_color(0.95f, 0.5f, 0.2f, 1), services_heading_color(0.1f, 0.1f, 0.15f, 1),
        services_accent_color(0.95f, 0.5f, 0.2f, 1), services_subtitle_color(0.4f, 0.4f, 0.45f, 1),
        // Clients grid defaults
        clients_per_row(4), clients_card_spacing(20.0f),
        clients_label_color(0.95f, 0.5f, 0.2f, 1), clients_heading_color(0.1f, 0.1f, 0.15f, 1),
        clients_accent_color(0.95f, 0.5f, 0.2f, 1), clients_subtitle_color(0.4f, 0.4f, 0.45f, 1),
        // Features grid defaults
        features_cards_per_row(3), features_card_spacing(24.0f),
        features_label_color(0.95f, 0.5f, 0.2f, 1), features_heading_color(0.1f, 0.1f, 0.15f, 1),
        features_accent_color(0.95f, 0.5f, 0.2f, 1), features_subtitle_color(0.4f, 0.4f, 0.45f, 1),
        // Process timeline defaults
        process_label_color(0.95f, 0.5f, 0.2f, 1), process_heading_color(1, 1, 1, 1),
        process_accent_color(0.95f, 0.5f, 0.2f, 1), process_subtitle_color(0.6f, 0.6f, 0.65f, 1),
        process_line_color(0.95f, 0.5f, 0.2f, 0.5f), process_bg_color(0.08f, 0.1f, 0.14f, 1),
        // Hero section connector defaults
        hero_badge_icon_left(ICON_STAR), hero_badge_icon_right(ICON_STAR),
        hero_btn_primary_action(ACTION_SCROLL_TO_SECTION), hero_btn_secondary_action(ACTION_SCROLL_TO_SECTION),
        hero_bg_color(0.98f, 0.98f, 0.99f, 1.0f),
        hero_badge_bg(1.0f, 1.0f, 1.0f, 0.95f), hero_badge_text_color(0.2f, 0.2f, 0.25f, 1.0f),
        hero_badge_icon_color(0.95f, 0.5f, 0.2f, 1.0f),
        hero_heading_color(0.1f, 0.1f, 0.15f, 1.0f), hero_accent_color(0.95f, 0.5f, 0.2f, 1.0f),
        hero_description_color(0.4f, 0.4f, 0.45f, 1.0f),
        hero_btn_primary_bg(0.95f, 0.5f, 0.2f, 1.0f), hero_btn_primary_text_color(1.0f, 1.0f, 1.0f, 1.0f),
        hero_btn_secondary_bg(1.0f, 1.0f, 1.0f, 0.0f), hero_btn_secondary_text_color(0.1f, 0.1f, 0.15f, 1.0f),
        hero_btn_secondary_border(0.8f, 0.8f, 0.85f, 1.0f),
        hero_btn_border_radius(30.0f), hero_badge_border_radius(25.0f) {
        // Initialize char arrays
        story_label[0] = '\0'; story_heading[0] = '\0'; story_heading_accent[0] = '\0';
        story_paragraphs[0][0] = '\0'; story_paragraphs[1][0] = '\0'; story_paragraphs[2][0] = '\0';
        story_button_text[0] = '\0'; story_button_target[0] = '\0';
        story_stats_number[0] = '\0'; story_stats_label[0] = '\0';
        services_label[0] = '\0'; services_heading[0] = '\0'; services_heading_accent[0] = '\0'; services_subtitle[0] = '\0';
        clients_label[0] = '\0'; clients_heading[0] = '\0'; clients_heading_accent[0] = '\0'; clients_subtitle[0] = '\0';
        features_label[0] = '\0'; features_heading[0] = '\0'; features_heading_accent[0] = '\0'; features_subtitle[0] = '\0';
        process_label[0] = '\0'; process_heading[0] = '\0'; process_heading_accent[0] = '\0'; process_subtitle[0] = '\0';
        hero_badge_text[0] = '\0'; hero_heading[0] = '\0'; hero_heading_accent[0] = '\0'; hero_description[0] = '\0';
        hero_btn_primary_text[0] = '\0'; hero_btn_secondary_text[0] = '\0';
        hero_btn_primary_target[0] = '\0'; hero_btn_secondary_target[0] = '\0';
        strcpy(copyright_text, "Website under development.");
        strcpy(copyright_subtext, "2025 COMPANY NAME. ALL RIGHTS RESERVED.");
        strcpy(contact_form_title, "Contact Us");
        strcpy(contact_form_submit_text, "Submit");
        strcpy(contact_form_submit_target, "info@example.com");
        strcpy(search_placeholder, "Search...");
        strcpy(search_button_text, "Search");
        strcpy(bullet_main_heading, "Main Heading");
        strcpy(bullet_footer_text, "");
        strcpy(glass_bar_text, "Your text here");
        strcpy(glass_bar_highlight, "highlight");
        logo_link[0] = '\0';
        SetDefaults();
    }

    void SetDefaults() {
        const char* ids[] = {"hero","nav","about","services","cards","team","pricing",
                            "testimonials","gallery","blog","contact","footer","faq","cta","features","stats","login","image","textbox","custom",
                            "logo","heading","text-element","button-element",
                            "text-connector","bar-connector","footer-connector","card-connector","vertical-connector","navbar-connector","copyright-connector","article-connector","contact-form-connector","search-connector","logo-connector"};
        // Bounds check to prevent crash
        if (type >= 0 && type < (int)(sizeof(ids)/sizeof(ids[0]))) {
            section_id = ids[type];
        } else {
            section_id = "section";
        }

        switch(type) {
            case SEC_HERO:
                name = "Hero Section";
                title = "Transform Your Digital Presence";
                subtitle = "Create stunning websites with elegant design and powerful features";
                content = "Join thousands of satisfied customers who trust us to bring their vision to life";
                button_text = "Get Started Free";
                button_link = "#contact";
                height = 600;
                // Modern gradient background (deep blue to purple)
                bg_color = ImVec4(0.09f, 0.13f, 0.25f, 1.0f);
                title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                subtitle_color = ImVec4(0.85f, 0.88f, 0.95f, 1.0f);
                content_color = ImVec4(0.7f, 0.75f, 0.85f, 1.0f);
                text_color = ImVec4(1,1,1,1);
                // Modern typography
                title_font_size = 64;
                title_font_weight = 800;
                subtitle_font_size = 24;
                subtitle_font_weight = 500;
                content_font_size = 18;
                content_font_weight = 400;
                // Modern glass button
                button_bg_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);  // Modern blue
                button_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                button_font_size = 18;
                button_font_weight = 600;
                button_glass_effect = false;
                button_glass_opacity = 0.3f;
                button_glass_tint = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
                accent_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                padding = 80;
                animation_type = ANIM_FADE_IN;
                animation_duration = 1.2f;
                break;

            case SEC_NAVBAR:
                name = "Navigation";
                title = "Brand";
                height = 70;
                section_id = "nav";
                bg_color = ImVec4(1,1,1,1);
                nav_bg_color = ImVec4(1,1,1,1);
                nav_text_color = ImVec4(0.2f,0.2f,0.2f,1);
                nav_font_size = 15;
                nav_font_weight = 500;
                nav_items = {
                    {"Home", "#hero", "", "hero", nav_text_color, 15, 500},
                    {"About", "#about", "", "about", nav_text_color, 15, 500},
                    {"Services", "#services", "", "services", nav_text_color, 15, 500},
                    {"Contact", "#contact", "", "contact", nav_text_color, 15, 500}
                };
                break;

            case SEC_ABOUT:
                name = "About Section";
                title = "Who We Are";
                subtitle = "Crafting digital excellence since 2015";
                content = "We are a passionate team of designers, developers, and strategists dedicated to transforming bold ideas into exceptional digital experiences.\n\nOur Story:\nFounded in 2015, we've helped over 500 businesses achieve their digital goals. From startups to enterprise companies, we bring creativity, technical expertise, and strategic thinking to every project.\n\nOur Mission:\nTo empower businesses with innovative digital solutions that drive growth, engage audiences, and create lasting impact in the digital world.\n\nWhat Sets Us Apart:\n‚Ä¢ 10+ years of combined experience\n‚Ä¢ Award-winning design team\n‚Ä¢ Agile development methodology\n‚Ä¢ 24/7 dedicated support\n‚Ä¢ 98% client satisfaction rate";
                height = 550;
                bg_color = ImVec4(0.99f, 0.99f, 1.0f, 1.0f);
                // Modern colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                content_color = ImVec4(0.25f, 0.30f, 0.40f, 1.0f);
                // Typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 22;
                subtitle_font_weight = 500;
                content_font_size = 17;
                content_font_weight = 400;
                accent_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                padding = 70;
                animation_type = ANIM_SLIDE_UP;
                animation_duration = 1.0f;
                break;

            case SEC_SERVICES:
            case SEC_FEATURES:
                name = type == SEC_SERVICES ? "Services" : "Features";
                title = type == SEC_SERVICES ? "Our Services" : "Why Choose Us";
                subtitle = type == SEC_SERVICES ? "Professional solutions tailored to your needs" : "The features that make us stand out";
                height = 1200;
                bg_color = ImVec4(0.99f, 0.99f, 1.0f, 1.0f);  // Pure white
                // Modern colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                // Professional typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 800;
                card_height = 1000;
                card_spacing = 40;
                cards_per_row = 3;
                padding = 70;
                items = {
                    {"AI & Machine Learning", "Intelligent solutions for your business", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.37f, 0.51f, 0.99f, 0.05f), 16.0f, 1.5f, ImVec4(0.37f, 0.51f, 0.99f, 0.1f), false, 0.15f,
                     1, ImVec4(0.96f, 0.32f, 0.53f, 1.0f), "‚ö°", {"Custom Models", "Data Analysis", "Predictive Analytics"}, "", 0, {}, "", 2, 0.0f, 0.0f},
                    {"Website Design & Development", "Make your online presence impactful", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.56f, 0.27f, 0.68f, 0.05f), 16.0f, 1.5f, ImVec4(0.56f, 0.27f, 0.68f, 0.1f), false, 0.15f,
                     1, ImVec4(0.25f, 0.52f, 1.0f, 1.0f), "üåê", {"Responsive Design", "SEO Optimization", "Performance Tuning"}, "", 0, {}, "", 2, 0.0f, 0.15f},
                    {"Mobile App Development", "Android | iOS | Hybrid", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.06f, 0.71f, 0.60f, 0.05f), 16.0f, 1.5f, ImVec4(0.06f, 0.71f, 0.60f, 0.1f), false, 0.15f,
                     1, ImVec4(0.20f, 0.73f, 0.42f, 1.0f), "üì±", {"Native Apps", "Cross-platform", "App Store Deployment"}, "", 0, {}, "", 2, 0.0f, 0.3f}
                };
                animation_type = ANIM_SLIDE_UP;
                animation_duration = 0.9f;
                animation_delay = 0.2f;
                break;

            case SEC_CARDS:
                name = "Cards Section";
                title = "Featured";
                height = 1200;
                title_font_size = 42;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 800;
                card_height = 1000;
                card_spacing = 40;
                cards_per_row = 3;
                padding = 70;
                items = {
                    {"AI & Machine Learning", "Intelligent solutions for your business", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.37f, 0.51f, 0.99f, 0.05f), 16.0f, 1.5f, ImVec4(0.37f, 0.51f, 0.99f, 0.1f), false, 0.15f,
                     1, ImVec4(0.96f, 0.32f, 0.53f, 1.0f), "‚ö°", {"Custom Models", "Data Analysis", "Predictive Analytics"}, "", 0, {}, "", 2, 0.0f, 0.0f},
                    {"Website Design & Development", "Make your online presence impactful", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.56f, 0.27f, 0.68f, 0.05f), 16.0f, 1.5f, ImVec4(0.56f, 0.27f, 0.68f, 0.1f), false, 0.15f,
                     1, ImVec4(0.25f, 0.52f, 1.0f, 1.0f), "üåê", {"Responsive Design", "SEO Optimization", "Performance Tuning"}, "", 0, {}, "", 2, 0.0f, 0.15f},
                    {"Mobile App Development", "Android | iOS | Hybrid", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.06f, 0.71f, 0.60f, 0.05f), 16.0f, 1.5f, ImVec4(0.06f, 0.71f, 0.60f, 0.1f), false, 0.15f,
                     1, ImVec4(0.20f, 0.73f, 0.42f, 1.0f), "üì±", {"Native Apps", "Cross-platform", "App Store Deployment"}, "", 0, {}, "", 2, 0.0f, 0.3f}
                };
                animation_type = ANIM_SLIDE_UP;
                animation_duration = 0.9f;
                animation_delay = 0.2f;
                break;

            case SEC_TEAM:
                name = "Team Section";
                title = "Meet Our Team";
                subtitle = "The talented people behind our success";
                height = 1200;
                bg_color = ImVec4(0.99f, 0.99f, 1.0f, 1.0f);
                // Modern colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                // Typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 800;
                card_height = 1000;
                card_spacing = 40;
                cards_per_row = 3;
                padding = 70;
                items = {
                    {"Sarah Johnson", "CEO & Founder", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.37f, 0.51f, 0.99f, 0.05f), 16.0f, 1.5f, ImVec4(0.37f, 0.51f, 0.99f, 0.1f), false, 0.15f,
                     1, ImVec4(0.96f, 0.32f, 0.53f, 1.0f), "", {"10+ years experience", "Strategic vision", "Team leadership"}, "", 0, {}, "", 2, 1.0f, 0.0f},
                    {"Michael Chen", "Creative Director", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.56f, 0.27f, 0.68f, 0.05f), 16.0f, 1.5f, ImVec4(0.56f, 0.27f, 0.68f, 0.1f), false, 0.15f,
                     1, ImVec4(0.25f, 0.52f, 1.0f, 1.0f), "", {"Award-winning designs", "Brand innovation", "Creative strategy"}, "", 0, {}, "", 2, 1.0f, 0.15f},
                    {"Emily Rodriguez", "Lead Developer", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.06f, 0.71f, 0.60f, 0.05f), 16.0f, 1.5f, ImVec4(0.06f, 0.71f, 0.60f, 0.1f), false, 0.15f,
                     1, ImVec4(0.20f, 0.73f, 0.42f, 1.0f), "", {"Full-stack expertise", "Clean code advocate", "Tech innovation"}, "", 0, {}, "", 2, 1.0f, 0.3f}
                };
                animation_type = ANIM_FADE_IN;
                animation_duration = 1.0f;
                animation_delay = 0.3f;
                break;

            case SEC_PRICING:
                name = "Pricing";
                title = "Choose Your Plan";
                subtitle = "Simple, transparent pricing that grows with you";
                height = 1200;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
                // Modern elegant colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                // Typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 800;
                card_height = 1000;
                card_spacing = 40;
                cards_per_row = 3;
                padding = 70;
                items = {
                    {"Starter", "Perfect for individuals and small projects", "", "$19/mo", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.37f, 0.51f, 0.99f, 0.05f), 16.0f, 1.5f, ImVec4(0.37f, 0.51f, 0.99f, 0.1f), false, 0.15f,
                     1, ImVec4(0.96f, 0.32f, 0.53f, 1.0f), "", {"5GB Storage", "Basic Support", "1 User"}, "", 0, {}, "", 2, 1.0f, 0.0f},
                    {"Professional", "Ideal for growing businesses", "", "$49/mo", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.56f, 0.27f, 0.68f, 0.05f), 16.0f, 1.5f, ImVec4(0.56f, 0.27f, 0.68f, 0.1f), false, 0.15f,
                     1, ImVec4(0.25f, 0.52f, 1.0f, 1.0f), "", {"100GB Storage", "Priority Support", "10 Users"}, "", 0, {}, "", 2, 1.0f, 0.15f},
                    {"Enterprise", "Advanced features for large organizations", "", "$99/mo", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.45f, 0.50f, 0.60f, 1.0f), 24, 16, 600, 400, 0, 0, 0,
                     false, 0.15f, 15.0f, ImVec4(0.06f, 0.71f, 0.60f, 0.05f), 16.0f, 1.5f, ImVec4(0.06f, 0.71f, 0.60f, 0.1f), false, 0.15f,
                     1, ImVec4(0.20f, 0.73f, 0.42f, 1.0f), "", {"Unlimited Storage", "24/7 Support", "Unlimited Users"}, "", 0, {}, "", 2, 1.0f, 0.3f}
                };
                animation_type = ANIM_ZOOM_IN;
                animation_duration = 0.8f;
                animation_delay = 0.15f;
                break;

            case SEC_TESTIMONIALS:
                name = "Testimonials";
                title = "What Our Clients Say";
                subtitle = "Don't just take our word for it - hear from our satisfied customers";
                height = 480;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
                // Modern colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                // Typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 380;
                card_height = 250;
                card_spacing = 25;
                cards_per_row = 3;
                padding = 70;
                items = {
                    {"\"Working with this team has been transformative for our business. Their attention to detail and creativity exceeded all expectations!\"", "Sarah Johnson, CEO at TechStart", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.37f, 0.51f, 0.99f, 1.0f), 18, 15, 500, 600, 0, 0, 0,
                     true, 0.10f, 12.0f, ImVec4(0.97f, 0.97f, 0.99f, 1.0f), 14.0f, 1.8f, ImVec4(0.37f, 0.51f, 0.99f, 0.12f), true, 0.15f},
                    {"\"The best investment we've made this year. Professional, responsive, and delivered exceptional results on time.\"", "Michael Chen, Founder of GrowthCo", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.37f, 0.51f, 0.99f, 1.0f), 18, 15, 500, 600, 0, 0, 0,
                     true, 0.10f, 12.0f, ImVec4(0.97f, 0.97f, 0.99f, 1.0f), 14.0f, 1.8f, ImVec4(0.37f, 0.51f, 0.99f, 0.12f), true, 0.15f},
                    {"\"Outstanding work from start to finish. They truly understood our vision and brought it to life beautifully.\"", "Emily Rodriguez, Marketing Director", "", "", "",
                     ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(0.12f, 0.15f, 0.22f, 1.0f), ImVec4(0.37f, 0.51f, 0.99f, 1.0f), 18, 15, 500, 600, 0, 0, 0,
                     true, 0.10f, 12.0f, ImVec4(0.97f, 0.97f, 0.99f, 1.0f), 14.0f, 1.8f, ImVec4(0.37f, 0.51f, 0.99f, 0.12f), true, 0.15f}
                };
                animation_type = ANIM_FADE_IN;
                animation_duration = 1.1f;
                animation_delay = 0.2f;
                break;

            case SEC_GALLERY:
                name = "Gallery";
                title = "Our Portfolio";
                subtitle = "Explore our latest projects and creative work";
                height = 1200;
                bg_color = ImVec4(0.99f, 0.99f, 1.0f, 1.0f);
                // Modern colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                // Typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                card_width = 1200;
                card_height = 1000;
                card_spacing = 10;
                cards_per_row = 2;
                padding = 70;
                gallery_columns = 2;
                gallery_spacing = 10.0f;
                gallery_lightbox = true;
                items = {
                    {"Project 1", "Gallery image", "", "", "", ImVec4(0.96f,0.96f,0.98f,1), ImVec4(0.12f,0.15f,0.22f,1), ImVec4(0.45f,0.50f,0.60f,1), 20, 15, 600, 400, 0, 0, 0,
                     true, 0.08f, 12.0f, ImVec4(0.95f,0.95f,0.97f,1), 14.0f, 1.5f, ImVec4(0.85f,0.87f,0.92f,0.2f), true, 0.12f},
                    {"Project 2", "Gallery image", "", "", "", ImVec4(0.96f,0.96f,0.98f,1), ImVec4(0.12f,0.15f,0.22f,1), ImVec4(0.45f,0.50f,0.60f,1), 20, 15, 600, 400, 0, 0, 0,
                     true, 0.08f, 12.0f, ImVec4(0.95f,0.95f,0.97f,1), 14.0f, 1.5f, ImVec4(0.85f,0.87f,0.92f,0.2f), true, 0.12f},
                    {"Project 3", "Gallery image", "", "", "", ImVec4(0.96f,0.96f,0.98f,1), ImVec4(0.12f,0.15f,0.22f,1), ImVec4(0.45f,0.50f,0.60f,1), 20, 15, 600, 400, 0, 0, 0,
                     true, 0.08f, 12.0f, ImVec4(0.95f,0.95f,0.97f,1), 14.0f, 1.5f, ImVec4(0.85f,0.87f,0.92f,0.2f), true, 0.12f},
                    {"Project 4", "Gallery image", "", "", "", ImVec4(0.96f,0.96f,0.98f,1), ImVec4(0.12f,0.15f,0.22f,1), ImVec4(0.45f,0.50f,0.60f,1), 20, 15, 600, 400, 0, 0, 0,
                     true, 0.08f, 12.0f, ImVec4(0.95f,0.95f,0.97f,1), 14.0f, 1.5f, ImVec4(0.85f,0.87f,0.92f,0.2f), true, 0.12f}
                };
                animation_type = ANIM_ZOOM_IN;
                animation_duration = 0.7f;
                animation_delay = 0.1f;
                break;

            case SEC_CONTACT:
                name = "Contact";
                title = "Get In Touch";
                subtitle = "We'd love to hear from you";
                content = "Have a question or want to work together? Drop us a message and we'll get back to you within 24 hours.\n\nEmail: hello@company.com\nPhone: (555) 123-4567\nAddress: 123 Main Street, Suite 100\nNew York, NY 10001\n\nBusiness Hours:\nMon-Fri: 9:00 AM - 6:00 PM\nSat-Sun: Closed";
                height = 550;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);  // Light gray background
                // Modern elegant colors
                title_color = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);  // Dark blue-gray
                subtitle_color = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);  // Medium gray
                content_color = ImVec4(0.35f, 0.40f, 0.50f, 1.0f);
                // Professional typography
                title_font_size = 48;
                title_font_weight = 700;
                subtitle_font_size = 20;
                subtitle_font_weight = 400;
                content_font_size = 16;
                content_font_weight = 400;
                // Modern button
                button_text = "Send Message";
                button_bg_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);  // Modern blue
                button_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                button_font_size = 17;
                button_font_weight = 600;
                button_glass_effect = false;
                button_glass_opacity = 0.25f;
                accent_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                padding = 70;
                animation_type = ANIM_SLIDE_UP;
                animation_duration = 0.8f;
                break;

            case SEC_FOOTER:
                name = "Footer";
                title = "Your Company";
                subtitle = "Building the future, one project at a time";
                content = "¬© 2024 Your Company. All rights reserved.\n\nQuick Links: Home ‚Ä¢ About ‚Ä¢ Services ‚Ä¢ Contact\nLegal: Privacy Policy ‚Ä¢ Terms of Service ‚Ä¢ Cookie Policy\n\nConnect: LinkedIn ‚Ä¢ Twitter ‚Ä¢ Facebook ‚Ä¢ Instagram\nEmail: hello@yourcompany.com ‚Ä¢ Phone: (555) 123-4567";
                height = 280;
                // Modern dark footer
                bg_color = ImVec4(0.08f, 0.10f, 0.14f, 1.0f);  // Dark blue-gray
                title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                subtitle_color = ImVec4(0.75f, 0.78f, 0.85f, 1.0f);
                content_color = ImVec4(0.60f, 0.65f, 0.75f, 1.0f);
                text_color = ImVec4(0.7f, 0.75f, 0.85f, 1.0f);
                // Typography
                title_font_size = 28;
                title_font_weight = 700;
                subtitle_font_size = 16;
                subtitle_font_weight = 400;
                content_font_size = 15;
                content_font_weight = 400;
                accent_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                padding = 60;
                break;

            case SEC_FAQ:
                name = "FAQ";
                title = "Frequently Asked Questions";
                height = 400;
                title_font_size = 42;
                faq_items = {
                    {"What services do you offer?", "We offer web design, development, and SEO.",
                     ImVec4(0.1f,0.1f,0.1f,1), ImVec4(0.4f,0.4f,0.4f,1), 18, 15, 600, false},
                    {"How long does a project take?", "Typically 2-4 weeks depending on complexity.",
                     ImVec4(0.1f,0.1f,0.1f,1), ImVec4(0.4f,0.4f,0.4f,1), 18, 15, 600, false},
                    {"Do you offer support?", "Yes, we provide ongoing support and maintenance.",
                     ImVec4(0.1f,0.1f,0.1f,1), ImVec4(0.4f,0.4f,0.4f,1), 18, 15, 600, false}
                };
                break;

            case SEC_CTA:
                name = "Call to Action";
                title = "Ready to Transform Your Business?";
                subtitle = "Join over 10,000 companies already growing with us";
                content = "Start your free 14-day trial today. No credit card required.";
                button_text = "Get Started Free";
                button_link = "#contact";
                height = 350;
                // Modern gradient background
                bg_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);  // Modern blue
                title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                subtitle_color = ImVec4(0.92f, 0.94f, 0.98f, 1.0f);
                content_color = ImVec4(0.88f, 0.91f, 0.96f, 1.0f);
                // Modern typography
                title_font_size = 52;
                title_font_weight = 800;
                subtitle_font_size = 22;
                subtitle_font_weight = 500;
                content_font_size = 18;
                content_font_weight = 400;
                // Modern glass button
                button_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                button_text_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                button_font_size = 18;
                button_font_weight = 700;
                button_glass_effect = false;
                button_glass_opacity = 0.25f;
                button_glass_tint = ImVec4(1.0f, 1.0f, 1.0f, 0.15f);
                padding = 80;
                animation_type = ANIM_ZOOM_IN;
                animation_duration = 0.8f;
                break;

            case SEC_STATS:
                name = "Statistics";
                title = "Our Numbers";
                height = 200;
                bg_color = ImVec4(0.1f, 0.15f, 0.25f, 1.0f);
                title_color = ImVec4(1,1,1,1);
                text_color = ImVec4(1,1,1,1);
                items = {
                    {"500+", "Projects", "", "", "", ImVec4(0,0,0,0), ImVec4(1,1,1,1), ImVec4(0.8f,0.8f,0.8f,1), 48, 16, 700, 400, 0, 0, 0,
                     false, 0.25f, 10.0f, ImVec4(0.1f,0.15f,0.25f,1), 15.0f, 1.5f, ImVec4(1,1,1,0.2f), true, 0.3f},
                    {"100+", "Clients", "", "", "", ImVec4(0,0,0,0), ImVec4(1,1,1,1), ImVec4(0.8f,0.8f,0.8f,1), 48, 16, 700, 400, 0, 0, 0,
                     false, 0.25f, 10.0f, ImVec4(0.1f,0.15f,0.25f,1), 15.0f, 1.5f, ImVec4(1,1,1,0.2f), true, 0.3f},
                    {"10+", "Years", "", "", "", ImVec4(0,0,0,0), ImVec4(1,1,1,1), ImVec4(0.8f,0.8f,0.8f,1), 48, 16, 700, 400, 0, 0, 0,
                     false, 0.25f, 10.0f, ImVec4(0.1f,0.15f,0.25f,1), 15.0f, 1.5f, ImVec4(1,1,1,0.2f), true, 0.3f},
                    {"24/7", "Support", "", "", "", ImVec4(0,0,0,0), ImVec4(1,1,1,1), ImVec4(0.8f,0.8f,0.8f,1), 48, 16, 700, 400, 0, 0, 0,
                     false, 0.25f, 10.0f, ImVec4(0.1f,0.15f,0.25f,1), 15.0f, 1.5f, ImVec4(1,1,1,0.2f), true, 0.3f}
                };
                break;

            case SEC_LOGIN:
                name = "Login Card";
                title = "LOGIN";
                height = 600;
                bg_color = ImVec4(0.1f, 0.15f, 0.25f, 1.0f);
                title_color = ImVec4(1,1,1,1);
                text_color = ImVec4(1,1,1,1);
                title_font_size = 32;
                title_font_weight = 600;
                use_bg_image = true;
                bg_overlay_opacity = 0.0f;
                break;

            case SEC_IMAGE:
                name = "Image";
                title = "";
                height = 300;  // Default height, will adjust based on image
                bg_color = ImVec4(0,0,0,0);  // Transparent background
                break;

            case SEC_TEXTBOX:
                name = "Text Box";
                title = "Your Title Here";
                subtitle = "Your subtitle here";
                content = "Add your text content here. You can write paragraphs, descriptions, or any text you want to display.";
                height = 400;
                bg_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);  // Light gray
                title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                subtitle_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                content_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
                title_font_size = 32;
                subtitle_font_size = 18;
                content_font_size = 16;
                title_font_weight = 700;
                subtitle_font_weight = 500;
                content_font_weight = 400;
                text_align = 0;  // Left aligned
                padding = 40;
                break;

            // ==================== CONNECTOR SECTIONS ====================

            case SEC_TEXT_CONNECTOR:
                name = "Text Block";
                height = 250;
                bg_color = ImVec4(1, 1, 1, 1);  // White background
                text_content_width = 700.0f;
                text_padding = 30.0f;
                {
                    // Sample block 1 - exact from original text_connector
                    TextBlock block1;
                    block1.fontSize = 16;
                    block1.textColor = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                    block1.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                    block1.lineSpacing = 1.5f;
                    TextSegment s1; s1.text = "At OMNiON, we work with clients and partners around the world and across diverse markets to provide "; s1.isBold = false; block1.segments.push_back(s1);
                    TextSegment s2; s2.text = "premedia services"; s2.isBold = true; block1.segments.push_back(s2);
                    TextSegment s3; s3.text = ", "; s3.isBold = false; block1.segments.push_back(s3);
                    TextSegment s4; s4.text = "mobile publishing services"; s4.isBold = true; block1.segments.push_back(s4);
                    TextSegment s5; s5.text = " & "; s5.isBold = false; block1.segments.push_back(s5);
                    TextSegment s6; s6.text = "creative production solutions"; s6.isBold = true; block1.segments.push_back(s6);
                    TextSegment s7; s7.text = " ranging from imaging, packaging artwork, prepress, design, animation & programming services to more complex projects."; s7.isBold = false; block1.segments.push_back(s7);
                    text_blocks.push_back(block1);

                    // Sample block 2 - exact from original text_connector
                    TextBlock block2;
                    block2.fontSize = 16;
                    block2.textColor = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                    block2.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                    block2.lineSpacing = 1.5f;
                    TextSegment b1; b1.text = "OMNiON Founders - "; b1.isBold = false; block2.segments.push_back(b1);
                    TextSegment b2; b2.text = "M. C. ABRAHAM"; b2.isBold = true; block2.segments.push_back(b2);
                    TextSegment b3; b3.text = ", based in Bangalore, India is considered India's pioneer of global media solutions, having started doing this in 1974 and his son - "; b3.isBold = false; block2.segments.push_back(b3);
                    TextSegment b4; b4.text = "MAT ABRAHAM"; b4.isBold = true; block2.segments.push_back(b4);
                    TextSegment b5; b5.text = ", based in New Jersey, USA has led premedia technology at Quad/Graphics, Inc., USA for almost 20 years."; b5.isBold = false; block2.segments.push_back(b5);
                    text_blocks.push_back(block2);
                }
                break;

            case SEC_BAR_CONNECTOR:
                name = "Heading Bar";
                height = 50;
                bg_color = ImVec4(0.9f, 0.45f, 0.2f, 1);  // Orange
                {
                    BarItem bar;
                    strcpy(bar.heading, "WHO ARE WE?");
                    bar_items.push_back(bar);
                }
                break;

            case SEC_FOOTER_CONNECTOR:
                name = "Footer Columns";
                height = 400;
                bg_color = ImVec4(0.85f, 0.45f, 0.2f, 1);  // Orange - exact from original
                footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White
                footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.9f);  // White slightly transparent
                footer_heading_size = 1.3f;
                footer_subheading_size = 1.0f;
                footer_heading_boldness = 1.5f;
                footer_subheading_boldness = 0.0f;
                footer_column_width = 280.0f;
                footer_item_spacing = 8.0f;
                {
                    // Column 1: Imaging Services - exact from original footer_connector
                    FooterColumn col1;
                    strcpy(col1.heading, "IMAGING SERVICES");
                    col1.items.push_back("SILO");
                    col1.items.push_back("MASKING");
                    col1.items.push_back("RETOUCHING");
                    col1.items.push_back("CLIPPING PATH");
                    col1.items.push_back("COLOR CORRECTION");
                    col1.items.push_back("SIZING");
                    col1.items.push_back("VECTORIZING");
                    col1.items.push_back("COLORIZING");
                    col1.items.push_back("PHOTOGRAPHY");
                    col1.items.push_back("SWATCH MATCHING");
                    col1.items.push_back("CGI & MODELLING");
                    footer_columns.push_back(col1);

                    // Column 2: Packaging Services
                    FooterColumn col2;
                    strcpy(col2.heading, "PACKAGING SERVICES");
                    col2.items.push_back("ARTWORK");
                    col2.items.push_back("ADAPTATION");
                    col2.items.push_back("LOCALIZATION");
                    col2.items.push_back("TRAPPING");
                    col2.items.push_back("COLOR SEPARATION");
                    col2.items.push_back("ARTWORK MANAGEMENT");
                    col2.items.push_back("");
                    col2.items.push_back("3D & CGI SERVICES");
                    col2.items.push_back("3D MODELLING");
                    footer_columns.push_back(col2);

                    // Column 3: Advertising Services
                    FooterColumn col3;
                    strcpy(col3.heading, "ADVERTISING SERVICES");
                    col3.items.push_back("BANNER ADS");
                    col3.items.push_back("WEB, MOBILE & TABLET AD PROGRAMMING");
                    col3.items.push_back("PRINT, RICH & MOBILE, MEDIA ADS");
                    col3.items.push_back("AD DESIGN, IMAGING, LAYOUT, ILLUSTRATION");
                    col3.items.push_back("BRANDING & CREATIVE");
                    col3.items.push_back("");
                    col3.items.push_back("TECHNOLOGY SERVICES");
                    col3.items.push_back("CMS WEBSITE");
                    col3.items.push_back("SEO");
                    col3.items.push_back("YAHOO RTML");
                    col3.items.push_back("ECOMMERCE WEBSITE");
                    col3.items.push_back("APPLE DEVELOPMENT");
                    col3.items.push_back("APPLICATION DEV");
                    footer_columns.push_back(col3);

                    // Column 4: Publishing Services
                    FooterColumn col4;
                    strcpy(col4.heading, "PUBLISHING SERVICES");
                    col4.items.push_back("TABLET PUBLISHING");
                    col4.items.push_back("IPAD PUBLISHING");
                    col4.items.push_back("DESIGN & LAYOUT");
                    col4.items.push_back("PROOF READING & COPY EDITING");
                    col4.items.push_back("HTML, XML & TAGGING");
                    col4.items.push_back("EPUB, EBOOK, DIGITIZATION");
                    col4.items.push_back("");
                    col4.items.push_back("NEW MEDIA SERVICES");
                    col4.items.push_back("PACKAGING");
                    col4.items.push_back("MAGAZINES");
                    col4.items.push_back("CATALOGS");
                    col4.items.push_back("BOOKS");
                    col4.items.push_back("NEWSPAPERS");
                    col4.items.push_back("DIGITAL ASSET MANAGEMENT (DAM)");
                    col4.items.push_back("DATA MANAGEMENT");
                    footer_columns.push_back(col4);
                }
                break;

            case SEC_CARD_CONNECTOR:
                name = "Thumbnail Cards";
                height = 400;
                bg_color = ImVec4(0.1f, 0.1f, 0.12f, 1);  // Dark background - exact from original
                connector_cards_per_row = 3;
                connector_card_spacing = 20.0f;
                {
                    // Create 1 empty card with default values from original Card_connector
                    ThumbnailCard card;
                    // Default values exactly from original struct
                    card.headingBoldness = 1.0f;
                    card.headingSize = 1.2f;
                    card.descriptionBoldness = 0.0f;
                    card.descriptionSize = 1.0f;
                    card.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);      // White
                    card.descriptionColor = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);  // Gray
                    card.cardColor = ImVec4(0.14f, 0.14f, 0.16f, 1.0f);      // Dark gray
                    card.cardWidth = 280.0f;
                    card.cardHeight = 340.0f;
                    card.borderThickness = 1.0f;
                    card.borderColor = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);       // Gray border
                    connector_cards.push_back(card);
                }
                break;

            case SEC_VERTICAL_CONNECTOR:
                name = "Vertical Layout";
                height = 350;
                bg_color = ImVec4(1, 1, 1, 1);  // White background - exact from original
                // Global style values from original vertical_connector
                vertical_heading_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);  // Dark
                vertical_heading_size = 1.2f;
                vertical_heading_boldness = 1.5f;
                vertical_desc_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);  // Gray
                vertical_desc_size = 1.0f;
                vertical_desc_boldness = 0.0f;
                vertical_content_width = 500.0f;
                vertical_spacing = 15.0f;
                {
                    // Sample heading 1 - exact from original vertical_connector
                    VerticalBlock h1;
                    h1.type = 0;  // Heading
                    strcpy(h1.text, "Reduce Time to Market / Save Time");
                    vertical_blocks.push_back(h1);

                    // Sample description 1
                    VerticalBlock d1;
                    d1.type = 1;  // Description
                    strcpy(d1.text, "We are Staffed for 24/7 Production and Enjoy A 10+ Hour Time Zone Advantage");
                    vertical_blocks.push_back(d1);

                    // Sample heading 2
                    VerticalBlock h2;
                    h2.type = 0;  // Heading
                    strcpy(h2.text, "Expand Range of Services");
                    vertical_blocks.push_back(h2);

                    // Sample description 2
                    VerticalBlock d2;
                    d2.type = 1;  // Description
                    strcpy(d2.text, "OMNiON blends a wide range of professional services under one roof and this increases your ability to deal with the multi-dimensional challenges of today's markets.");
                    vertical_blocks.push_back(d2);
                }
                break;

            case SEC_NAVBAR_CONNECTOR:
                name = "Navbar Menu";
                height = 42;
                // Navbar style - matching original main.txt
                navbar_bg_color = ImVec4(0.12f, 0.12f, 0.12f, 1.0f);
                navbar_hover_color = ImVec4(0.26f, 0.26f, 0.26f, 1.0f);
                navbar_dropdown_color = ImVec4(0.18f, 0.18f, 0.18f, 1.0f);
                navbar_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                navbar_height = 42.0f;
                navbar_padding_x = 10.0f;
                navbar_padding_y = 8.0f;
                navbar_spacing = 18.0f;
                navbar_rounding = 4.0f;
                navbar_font_scale = 1.0f;
                navbar_font_boldness = 1.0f;
                navbar_rounded = true;
                {
                    // Sample menu items - exact from original main.txt
                    NavbarMenuItem home;
                    strcpy(home.label, "Home");
                    navbar_items.push_back(home);

                    NavbarMenuItem premedia;
                    strcpy(premedia.label, "Premedia");
                    premedia.children.push_back("About");
                    premedia.children.push_back("Values");
                    premedia.children.push_back("Outsourcing");
                    premedia.children.push_back("How We Work");
                    navbar_items.push_back(premedia);

                    NavbarMenuItem services;
                    strcpy(services.label, "Services");
                    services.children.push_back("Creative");
                    services.children.push_back("Catalog");
                    services.children.push_back("Technology");
                    navbar_items.push_back(services);

                    NavbarMenuItem contact;
                    strcpy(contact.label, "Contact");
                    navbar_items.push_back(contact);
                }
                break;

            case SEC_COPYRIGHT_CONNECTOR:
                name = "Copyright Bar";
                height = 60;
                strcpy(copyright_text, "Website under development.");
                strcpy(copyright_subtext, "2025 COMPANY NAME. ALL RIGHTS RESERVED.");
                copyright_bg_color = ImVec4(0.18f, 0.18f, 0.18f, 1.0f);
                copyright_text_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
                copyright_link_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                copyright_font_size = 11.0f;
                copyright_subtext_size = 10.0f;
                copyright_padding = 15.0f;
                copyright_bg_opacity = 1.0f;
                {
                    CopyrightLink link1;
                    strcpy(link1.text, "Privacy Policy");
                    strcpy(link1.url, "#privacy");
                    link1.isBold = true;
                    copyright_links.push_back(link1);

                    CopyrightLink link2;
                    strcpy(link2.text, "Terms of Service");
                    strcpy(link2.url, "#terms");
                    link2.isBold = true;
                    copyright_links.push_back(link2);
                }
                break;

            case SEC_ARTICLE_CONNECTOR:
                name = "Article Cards";
                height = 200;
                article_cards_per_row = 2;
                article_card_spacing = 20;
                {
                    // Initialize with 2 sample article cards
                    ArticleCard card1;
                    strcpy(card1.heading, "Article Heading 1");
                    strcpy(card1.date, "1 Jan 2025");
                    strcpy(card1.description, "Article description text goes here. This provides a brief summary of the article content.");
                    article_cards.push_back(card1);

                    ArticleCard card2;
                    strcpy(card2.heading, "Article Heading 2");
                    strcpy(card2.date, "15 Jan 2025");
                    strcpy(card2.description, "Another article description. Click READ MORE to view the full article.");
                    article_cards.push_back(card2);
                }
                break;

            case SEC_CONTACT_FORM_CONNECTOR:
                name = "Contact Form";
                height = 450;
                strcpy(contact_form_title, "Contact Us");
                strcpy(contact_form_submit_text, "Submit");
                strcpy(contact_form_submit_target, "info@example.com");
                contact_form_submit_action = ACTION_EMAIL;
                contact_form_title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                contact_form_input_bg = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
                contact_form_input_text = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                contact_form_button_bg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                contact_form_button_text = ImVec4(0.2f, 0.6f, 0.9f, 1.0f);
                contact_form_button_border = ImVec4(0.2f, 0.6f, 0.9f, 1.0f);
                contact_form_title_size = 1.3f;
                contact_form_input_height = 45.0f;
                contact_form_textarea_height = 150.0f;
                contact_form_button_width = 100.0f;
                contact_form_button_height = 40.0f;
                contact_form_spacing = 20.0f;
                {
                    // Initialize with default fields
                    ContactFormField nameField;
                    strcpy(nameField.label, "Name");
                    strcpy(nameField.placeholder, "Name");
                    nameField.fieldType = 0; nameField.width = 0.5f;
                    contact_form_fields.push_back(nameField);

                    ContactFormField emailField;
                    strcpy(emailField.label, "Email");
                    strcpy(emailField.placeholder, "Email Address");
                    emailField.fieldType = 1; emailField.width = 0.5f;
                    contact_form_fields.push_back(emailField);

                    ContactFormField phoneField;
                    strcpy(phoneField.label, "Phone");
                    strcpy(phoneField.placeholder, "Phone No.");
                    phoneField.fieldType = 2; phoneField.width = 0.5f;
                    contact_form_fields.push_back(phoneField);

                    ContactFormField firmField;
                    strcpy(firmField.label, "Firm");
                    strcpy(firmField.placeholder, "Firm Name");
                    firmField.fieldType = 0; firmField.width = 0.5f;
                    contact_form_fields.push_back(firmField);

                    ContactFormField messageField;
                    strcpy(messageField.label, "Message");
                    strcpy(messageField.placeholder, "Message");
                    messageField.fieldType = 3; messageField.width = 1.0f;
                    contact_form_fields.push_back(messageField);
                }
                break;

            case SEC_BULLET_CONNECTOR:
                name = "Bullet Points";
                height = 300;
                bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White background
                strcpy(bullet_main_heading, "OMNiON's consistently delivered benefits are guaranteed to satisfy you:");
                strcpy(bullet_footer_text, "");
                bullet_heading_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                bullet_item_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                bullet_heading_size = 1.2f;
                bullet_heading_boldness = 2.0f;
                bullet_item_size = 1.0f;
                bullet_column_spacing = 40.0f;
                {
                    // Initialize with 2 default columns
                    BulletColumn col1;
                    strcpy(col1.subheading, "Core Value");
                    col1.bullet_items.clear();
                    col1.bullet_items.push_back("Prompt and Accurate Turnaround");
                    col1.bullet_items.push_back("Open Lines of Communication");
                    col1.bullet_items.push_back("Single Point of Contact");
                    col1.bullet_items.push_back("Comprehensive Security");
                    col1.bullet_items.push_back("Competitive Pricing");
                    col1.bullet_items.push_back("No Surprises");
                    bullet_columns.push_back(col1);

                    BulletColumn col2;
                    strcpy(col2.subheading, "End-to-End Services");
                    col2.bullet_items.clear();
                    col2.bullet_items.push_back("Print and Digital Publishing");
                    col2.bullet_items.push_back("Packaging");
                    col2.bullet_items.push_back("Catalog");
                    col2.bullet_items.push_back("Advertising");
                    col2.bullet_items.push_back("Technology");
                    col2.bullet_items.push_back("All Prepress Functions");
                    bullet_columns.push_back(col2);
                }
                break;

            case SEC_ICON:
                name = "Icon";
                height = 100;
                bg_color = ImVec4(1.0f, 1.0f, 1.0f, 0.0f);  // Transparent background
                icon_type = ICON_STAR;
                icon_size = 48.0f;
                icon_color = ImVec4(0.2f, 0.2f, 0.4f, 1.0f);
                icon_stroke_width = 2.0f;
                break;

            case SEC_SERVICE_CARD_CONNECTOR:
                name = "Service Cards";
                height = 350;
                bg_color = ImVec4(0.97f, 0.97f, 0.98f, 1.0f);
                service_cards_per_row = 3;
                service_card_spacing = 20.0f;
                {
                    // Initialize with 3 default service cards
                    ServiceCard card1;
                    strcpy(card1.title, "Imaging Services");
                    strcpy(card1.badgeText, "IMAGING");
                    card1.badgeColor = ImVec4(0.3f, 0.5f, 0.9f, 1.0f);
                    service_cards.push_back(card1);

                    ServiceCard card2;
                    strcpy(card2.title, "3D & Animation");
                    strcpy(card2.badgeText, "3D & ANIMATION");
                    card2.badgeColor = ImVec4(0.9f, 0.4f, 0.3f, 1.0f);
                    service_cards.push_back(card2);

                    ServiceCard card3;
                    strcpy(card3.title, "Technology Services");
                    strcpy(card3.badgeText, "TECHNOLOGY");
                    card3.badgeColor = ImVec4(0.3f, 0.7f, 0.5f, 1.0f);
                    service_cards.push_back(card3);
                }
                break;

            case SEC_GLASS_BAR_CONNECTOR:
                name = "Glass Bar";
                height = 60;
                bg_color = ImVec4(1.0f, 1.0f, 1.0f, 0.0f);  // Transparent
                strcpy(glass_bar_text, "Leading PreMedia");
                strcpy(glass_bar_highlight, "since 1974");
                glass_bar_text_color = ImVec4(0.2f, 0.2f, 0.25f, 1.0f);
                glass_bar_highlight_color = ImVec4(0.9f, 0.5f, 0.3f, 1.0f);
                glass_bar_bg_color = ImVec4(0.95f, 0.95f, 0.98f, 0.95f);
                glass_bar_opacity = 0.95f;
                glass_bar_border_radius = 30.0f;
                glass_bar_padding = 20.0f;
                break;

            case SEC_STORY_CONNECTOR:
                name = "Story Section";
                height = 500;
                bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                strcpy(story_label, "OUR STORY");
                strcpy(story_heading, "Five Decades of");
                strcpy(story_heading_accent, "Visual Mastery");
                strcpy(story_paragraphs[0], "Founded in 1974 by M.C. Abraham, OMNiON pioneered global outsourcing in publishing and media services from Bangalore, India's Silicon Valley.");
                strcpy(story_paragraphs[1], "Today, under the leadership of Mat Abraham (20+ years at Quad/Graphics, USA), we continue to serve the world's most prestigious brands, retailers, publishers, and agencies with unmatched expertise in premedia services.");
                strcpy(story_paragraphs[2], "Our global delivery model provides 24/7/365 services through world-class infrastructure, cutting-edge technology, and over 500 skilled professionals dedicated to pixel-perfect precision and creative excellence.");
                story_paragraph_count = 3;
                {
                    StoryFeatureBadge b1; strcpy(b1.text, "ISO 9001:2015 Certified"); b1.dotColor = ImVec4(0.95f, 0.7f, 0.2f, 1); story_badges.push_back(b1);
                    StoryFeatureBadge b2; strcpy(b2.text, "ISO 27001 Compliant"); b2.dotColor = ImVec4(0.9f, 0.3f, 0.3f, 1); story_badges.push_back(b2);
                    StoryFeatureBadge b3; strcpy(b3.text, "24/7 Global Operations"); b3.dotColor = ImVec4(0.9f, 0.3f, 0.3f, 1); story_badges.push_back(b3);
                    StoryFeatureBadge b4; strcpy(b4.text, "Enterprise Security"); b4.dotColor = ImVec4(0.95f, 0.5f, 0.2f, 1); story_badges.push_back(b4);
                }
                strcpy(story_button_text, "Partner With Us");
                story_button_action = 0;
                strcpy(story_button_target, "contact");
                strcpy(story_stats_number, "50+");
                strcpy(story_stats_label, "");
                story_label_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                story_heading_color = ImVec4(0.1f, 0.1f, 0.15f, 1);
                story_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                story_text_color = ImVec4(0.3f, 0.3f, 0.35f, 1);
                story_button_bg = ImVec4(0.95f, 0.5f, 0.2f, 1);
                story_button_text_color = ImVec4(1, 1, 1, 1);
                story_stats_bg = ImVec4(0.95f, 0.5f, 0.2f, 1);
                story_stats_text_color = ImVec4(1, 1, 1, 1);
                break;

            case SEC_SERVICES_SECTION_CONNECTOR:
                name = "Services Section";
                height = 600;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
                strcpy(services_label, "OUR SERVICES");
                strcpy(services_heading, "Comprehensive");
                strcpy(services_heading_accent, "PreMedia Solutions");
                strcpy(services_subtitle, "End-to-end visual production services tailored for enterprise needs, delivered with 50+ years of expertise and world-class infrastructure.");
                services_cards_per_row = 3;
                services_card_spacing = 24.0f;
                services_label_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                services_heading_color = ImVec4(0.1f, 0.1f, 0.15f, 1);
                services_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                services_subtitle_color = ImVec4(0.4f, 0.4f, 0.45f, 1);
                {
                    ServicesSectionCard c1;
                    strcpy(c1.title, "Product Imaging");
                    strcpy(c1.description, "High-volume product photography and catalog imaging with color-accurate, print-ready output for e-commerce and retail publications.");
                    c1.iconType = ICON_CAMERA;
                    strcpy(c1.bullets[0], "E-commerce Photography");
                    strcpy(c1.bullets[1], "Catalog Production");
                    strcpy(c1.bullets[2], "360¬∞ Product Views");
                    strcpy(c1.bullets[3], "Ghost Mannequin");
                    c1.bulletCount = 4;
                    strcpy(c1.linkText, "Learn More");
                    services_cards.push_back(c1);

                    ServicesSectionCard c2;
                    strcpy(c2.title, "Packaging Design");
                    strcpy(c2.description, "Strategic packaging solutions that enhance brand presence and consumer engagement from concept to print-ready artwork.");
                    c2.iconType = ICON_SHOPPING;
                    c2.iconBgColor = ImVec4(0.6f, 0.4f, 0.8f, 1.0f);
                    strcpy(c2.bullets[0], "Structural Design");
                    strcpy(c2.bullets[1], "Brand Identity");
                    strcpy(c2.bullets[2], "Print Production");
                    strcpy(c2.bullets[3], "Dieline Creation");
                    c2.bulletCount = 4;
                    strcpy(c2.linkText, "Learn More");
                    services_cards.push_back(c2);

                    ServicesSectionCard c3;
                    strcpy(c3.title, "Photo Retouching");
                    strcpy(c3.description, "Expert-level retouching services delivering flawless imagery while maintaining natural appearance and brand consistency.");
                    c3.iconType = ICON_BULB;
                    strcpy(c3.bullets[0], "High-End Beauty Retouching");
                    strcpy(c3.bullets[1], "Product Enhancement");
                    strcpy(c3.bullets[2], "Color Correction");
                    strcpy(c3.bullets[3], "Composite Imaging");
                    c3.bulletCount = 4;
                    strcpy(c3.linkText, "Learn More");
                    services_cards.push_back(c3);
                }
                break;

            case SEC_CLIENTS_GRID_CONNECTOR:
                name = "Clients Grid";
                height = 400;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
                strcpy(clients_label, "OUR CLIENTS");
                strcpy(clients_heading, "Trusted by");
                strcpy(clients_heading_accent, "Global Leaders");
                strcpy(clients_subtitle, "Partnering with world-renowned brands across industries since 1974");
                clients_per_row = 4;
                clients_card_spacing = 20.0f;
                clients_label_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                clients_heading_color = ImVec4(0.1f, 0.1f, 0.15f, 1);
                clients_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                clients_subtitle_color = ImVec4(0.4f, 0.4f, 0.45f, 1);
                {
                    const char* names[] = {"Nike", "Fender", "Zale Corporation", "Blair", "Quad/Graphics", "Macmillan UK", "Springer-Verlag", "Elsevier"};
                    const char* logos[] = {"NIKE", "FENDER", "ZALE", "BLAIR", "QUAD", "MACMILLAN", "SPRINGER", "ELSEVIER"};
                    for (int i = 0; i < 8; i++) {
                        ClientItem ci;
                        strcpy(ci.name, names[i]);
                        strcpy(ci.logoText, logos[i]);
                        clients_items.push_back(ci);
                    }
                }
                break;

            case SEC_FEATURES_GRID_CONNECTOR:
                name = "Features Grid";
                height = 550;
                bg_color = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
                strcpy(features_label, "INFRASTRUCTURE");
                strcpy(features_heading, "World-Class");
                strcpy(features_heading_accent, "Technology & Facilities");
                strcpy(features_subtitle, "State-of-the-art infrastructure in Bangalore, India's Silicon Valley, powering global operations 24/7");
                features_cards_per_row = 3;
                features_card_spacing = 24.0f;
                features_label_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                features_heading_color = ImVec4(0.1f, 0.1f, 0.15f, 1);
                features_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                features_subtitle_color = ImVec4(0.4f, 0.4f, 0.45f, 1);
                {
                    FeatureCardItem f1;
                    strcpy(f1.title, "Enterprise Data Center");
                    strcpy(f1.description, "Tier-3 certified facility with redundant power, cooling, and network infrastructure ensuring 99.99% uptime.");
                    f1.iconType = ICON_LAPTOP;
                    strcpy(f1.checkmarks[0], "Petabyte-scale storage");
                    strcpy(f1.checkmarks[1], "High-speed fiber connectivity");
                    strcpy(f1.checkmarks[2], "Real-time backup systems");
                    f1.checkmarkCount = 3;
                    features_cards.push_back(f1);

                    FeatureCardItem f2;
                    strcpy(f2.title, "Security & Compliance");
                    strcpy(f2.description, "Military-grade security protocols protecting your valuable assets and intellectual property.");
                    f2.iconType = ICON_LOCK;
                    strcpy(f2.checkmarks[0], "ISO 27001 Certified");
                    strcpy(f2.checkmarks[1], "SOC 2 Type II Compliant");
                    strcpy(f2.checkmarks[2], "GDPR Ready");
                    f2.checkmarkCount = 3;
                    features_cards.push_back(f2);

                    FeatureCardItem f3;
                    strcpy(f3.title, "Production Workstations");
                    strcpy(f3.description, "500+ high-performance workstations with color-calibrated displays and premium software stack.");
                    f3.iconType = ICON_SETTINGS;
                    strcpy(f3.checkmarks[0], "Color-calibrated monitors");
                    strcpy(f3.checkmarks[1], "Adobe Creative Cloud");
                    strcpy(f3.checkmarks[2], "ESKO Suite");
                    f3.checkmarkCount = 3;
                    features_cards.push_back(f3);

                    FeatureCardItem f4;
                    strcpy(f4.title, "AI & Automation");
                    strcpy(f4.description, "Proprietary AI-powered tools accelerating production while maintaining artistic quality.");
                    f4.iconType = ICON_BULB;
                    strcpy(f4.checkmarks[0], "Automated QC systems");
                    strcpy(f4.checkmarks[1], "Smart batch processing");
                    strcpy(f4.checkmarks[2], "ML-enhanced retouching");
                    f4.checkmarkCount = 3;
                    features_cards.push_back(f4);

                    FeatureCardItem f5;
                    strcpy(f5.title, "Global Delivery Network");
                    strcpy(f5.description, "Distributed CDN ensuring fast, secure file delivery to clients worldwide.");
                    f5.iconType = ICON_WIFI;
                    strcpy(f5.checkmarks[0], "Multi-region CDN");
                    strcpy(f5.checkmarks[1], "Secure file transfer");
                    strcpy(f5.checkmarks[2], "Real-time tracking");
                    f5.checkmarkCount = 3;
                    features_cards.push_back(f5);

                    FeatureCardItem f6;
                    strcpy(f6.title, "24/7 Operations");
                    strcpy(f6.description, "Round-the-clock production across multiple shifts for uninterrupted global service.");
                    f6.iconType = ICON_CLOCK;
                    strcpy(f6.checkmarks[0], "Follow-the-sun model");
                    strcpy(f6.checkmarks[1], "Dedicated project managers");
                    strcpy(f6.checkmarks[2], "Real-time communication");
                    f6.checkmarkCount = 3;
                    features_cards.push_back(f6);
                }
                break;

            case SEC_PROCESS_TIMELINE_CONNECTOR:
                name = "Process Timeline";
                height = 450;
                bg_color = ImVec4(0.08f, 0.1f, 0.14f, 1.0f);  // Dark background
                strcpy(process_label, "OUR PROCESS");
                strcpy(process_heading, "Streamlined");
                strcpy(process_heading_accent, "Workflow Excellence");
                strcpy(process_subtitle, "A proven methodology delivering consistent, high-quality results since 1974");
                process_label_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                process_heading_color = ImVec4(1, 1, 1, 1);
                process_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1);
                process_subtitle_color = ImVec4(0.6f, 0.6f, 0.65f, 1);
                process_line_color = ImVec4(0.95f, 0.5f, 0.2f, 0.5f);
                process_bg_color = ImVec4(0.08f, 0.1f, 0.14f, 1.0f);
                {
                    ProcessStep s1;
                    strcpy(s1.title, "Discovery");
                    strcpy(s1.description, "Understanding your brand, requirements, and project scope to create a tailored production plan.");
                    s1.iconType = ICON_BULB;
                    process_steps.push_back(s1);

                    ProcessStep s2;
                    strcpy(s2.title, "Asset Ingestion");
                    strcpy(s2.description, "Secure file transfer, cataloging, and quality assessment of all source materials.");
                    s2.iconType = ICON_UPLOAD;
                    process_steps.push_back(s2);

                    ProcessStep s3;
                    strcpy(s3.title, "Production");
                    strcpy(s3.description, "Expert execution with multi-stage quality checks and brand guideline compliance.");
                    s3.iconType = ICON_SETTINGS;
                    process_steps.push_back(s3);

                    ProcessStep s4;
                    strcpy(s4.title, "Quality Assurance");
                    strcpy(s4.description, "Rigorous QC protocols ensuring pixel-perfect output meeting international standards.");
                    s4.iconType = ICON_CHECK;
                    process_steps.push_back(s4);

                    ProcessStep s5;
                    strcpy(s5.title, "Delivery");
                    strcpy(s5.description, "Secure delivery in required formats with ongoing support and revisions as needed.");
                    s5.iconType = ICON_DOWNLOAD;
                    process_steps.push_back(s5);
                }
                break;

            case SEC_HERO_SECTION_CONNECTOR:
                name = "Hero Section";
                height = 600;
                bg_color = ImVec4(0.08f, 0.1f, 0.14f, 1.0f);  // Dark background
                hero_bg_color = ImVec4(0.08f, 0.1f, 0.14f, 1.0f);
                strcpy(hero_badge_text, "Pioneering Excellence Since 1974");
                hero_badge_icon_left = ICON_STAR;
                hero_badge_icon_right = ICON_STAR;
                strcpy(hero_heading, "Mastering the Art of");
                strcpy(hero_heading_accent, "PreMedia Excellence");
                strcpy(hero_description, "India's premier PreMedia company delivering world-class Imaging, Packaging Design, Retouching, 3D Visualization & Publishing solutions to Fortune 500 brands across the globe with 24/7 operations.");
                strcpy(hero_btn_primary_text, "Explore Services");
                strcpy(hero_btn_secondary_text, "View Portfolio");
                hero_btn_primary_action = ACTION_SCROLL_TO_SECTION;
                hero_btn_secondary_action = ACTION_SCROLL_TO_SECTION;
                strcpy(hero_btn_primary_target, "services");
                strcpy(hero_btn_secondary_target, "portfolio");
                hero_badge_bg = ImVec4(0.15f, 0.18f, 0.22f, 0.9f);  // Dark glass badge
                hero_badge_text_color = ImVec4(0.95f, 0.5f, 0.2f, 1.0f);  // Orange text
                hero_badge_icon_color = ImVec4(0.95f, 0.5f, 0.2f, 1.0f);
                hero_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White heading
                hero_accent_color = ImVec4(0.95f, 0.5f, 0.2f, 1.0f);  // Orange accent
                hero_description_color = ImVec4(0.7f, 0.7f, 0.75f, 1.0f);  // Light gray
                hero_btn_primary_bg = ImVec4(0.95f, 0.5f, 0.2f, 1.0f);
                hero_btn_primary_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                hero_btn_secondary_bg = ImVec4(0.15f, 0.18f, 0.22f, 1.0f);  // Dark button
                hero_btn_secondary_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                hero_btn_secondary_border = ImVec4(0.3f, 0.35f, 0.4f, 1.0f);
                hero_btn_border_radius = 30.0f;
                hero_badge_border_radius = 25.0f;
                {
                    // Default feature badges
                    HeroFeatureBadge b1; strcpy(b1.text, "50+ Years Experience"); b1.checkColor = ImVec4(0.95f, 0.5f, 0.2f, 1); hero_feature_badges.push_back(b1);
                    HeroFeatureBadge b2; strcpy(b2.text, "500+ Global Clients"); b2.checkColor = ImVec4(0.95f, 0.5f, 0.2f, 1); hero_feature_badges.push_back(b2);
                    HeroFeatureBadge b3; strcpy(b3.text, "24/7 Operations"); b3.checkColor = ImVec4(0.95f, 0.5f, 0.2f, 1); hero_feature_badges.push_back(b3);
                    HeroFeatureBadge b4; strcpy(b4.text, "ISO 9001 Certified"); b4.checkColor = ImVec4(0.95f, 0.5f, 0.2f, 1); hero_feature_badges.push_back(b4);

                    // Default stats
                    HeroStatItem s1; s1.iconType = ICON_CALENDAR; strcpy(s1.number, "50+"); strcpy(s1.label, "YEARS OF EXCELLENCE"); s1.iconColor = ImVec4(0.95f, 0.5f, 0.2f, 1); s1.numberColor = ImVec4(0.1f, 0.1f, 0.15f, 1); s1.labelColor = ImVec4(0.4f, 0.4f, 0.45f, 1); hero_stats.push_back(s1);
                    HeroStatItem s2; s2.iconType = ICON_WIFI; strcpy(s2.number, "500+"); strcpy(s2.label, "GLOBAL CLIENTS"); s2.iconColor = ImVec4(0.95f, 0.5f, 0.2f, 1); s2.numberColor = ImVec4(0.1f, 0.1f, 0.15f, 1); s2.labelColor = ImVec4(0.4f, 0.4f, 0.45f, 1); hero_stats.push_back(s2);
                    HeroStatItem s3; s3.iconType = ICON_CAMERA; strcpy(s3.number, "10+"); strcpy(s3.label, "IMAGES PROCESSED"); s3.iconColor = ImVec4(0.95f, 0.5f, 0.2f, 1); s3.numberColor = ImVec4(0.1f, 0.1f, 0.15f, 1); s3.labelColor = ImVec4(0.4f, 0.4f, 0.45f, 1); hero_stats.push_back(s3);
                    HeroStatItem s4; s4.iconType = ICON_STAR; strcpy(s4.number, "99%"); strcpy(s4.label, "CLIENT SATISFACTION"); s4.iconColor = ImVec4(0.95f, 0.5f, 0.2f, 1); s4.numberColor = ImVec4(0.1f, 0.1f, 0.15f, 1); s4.labelColor = ImVec4(0.4f, 0.4f, 0.45f, 1); hero_stats.push_back(s4);
                }
                break;

            default:
                name = "Custom Section";
                title = "Section Title";
                height = 300;
                break;
        }
    }
};

// ============================================================================
// FIGMA-STYLE LAYER SYSTEM
// ============================================================================
enum LayerType {
    LAYER_DIV,          // Generic container
    LAYER_TEXT,         // Text element (heading, paragraph, span)
    LAYER_IMAGE,        // Image element
    LAYER_BUTTON,       // Button or link styled as button
    LAYER_ICON,         // SVG or icon
    LAYER_INPUT,        // Form input
    LAYER_VIDEO,        // Video element
    LAYER_SHAPE         // Decorative shape
};

// ============================================================================
// FIGMA-LIKE TOOL SYSTEM
// ============================================================================
enum ToolType {
    // Basic Tools
    TOOL_SELECT = 0,    // V - Select/Move tool (default)
    TOOL_RECTANGLE,     // R - Rectangle/Container
    TOOL_TEXT,          // T - Text element (paragraph)
    TOOL_IMAGE,         // I - Image element
    TOOL_BUTTON,        // B - Button element
    TOOL_LINE,          // L - Line/Arrow
    TOOL_CIRCLE,        // O - Circle/Ellipse
    TOOL_FRAME,         // F - Frame/Group container

    // Typography Tools
    TOOL_HEADING,       // H - Heading (large text)
    TOOL_SUBHEADING,    // - Subheading (medium text)
    TOOL_PARAGRAPH,     // P - Paragraph text

    // Basic Elements
    TOOL_LOGO,          // Logo placeholder
    TOOL_INPUT,         // Input field
    TOOL_ICON,          // Icon placeholder
    TOOL_DIVIDER,       // Horizontal divider line

    // ==================== WEBSITE SECTIONS (Same as Normal Mode) ====================
    TOOL_SEC_HERO,          // Hero section
    TOOL_SEC_NAVBAR,        // Navigation bar
    TOOL_SEC_ABOUT,         // About section
    TOOL_SEC_SERVICES,      // Services section
    TOOL_SEC_CARDS,         // Cards section
    TOOL_SEC_TEAM,          // Team section
    TOOL_SEC_PRICING,       // Pricing section
    TOOL_SEC_TESTIMONIALS,  // Testimonials section
    TOOL_SEC_GALLERY,       // Gallery section
    TOOL_SEC_BLOG,          // Blog section
    TOOL_SEC_CONTACT,       // Contact section
    TOOL_SEC_FOOTER,        // Footer section
    TOOL_SEC_FAQ,           // FAQ section
    TOOL_SEC_CTA,           // Call to Action section
    TOOL_SEC_FEATURES,      // Features section
    TOOL_SEC_STATS,         // Stats section
    TOOL_SEC_LOGIN,         // Login section
    TOOL_SEC_IMAGE,         // Full-width Image section
    TOOL_SEC_TEXTBOX,       // Text box section
    TOOL_SEC_CUSTOM         // Custom section
};

enum AlignType {
    ALIGN_LEFT,
    ALIGN_CENTER_H,
    ALIGN_RIGHT,
    ALIGN_TOP,
    ALIGN_CENTER_V,
    ALIGN_BOTTOM
};

struct WebLayer {
    int id;
    LayerType type;
    std::string name;

    // Position (absolute, in pixels from top-left of canvas)
    float x, y;
    float width, height;
    int z_index;

    // Content
    std::string text;
    std::string image_path;
    std::string video_path;     // Video file path for hero/banner layers
    std::string href;
    std::string onclick_action;  // JavaScript onclick or action data
    std::string action_type;     // "link", "popup", "scroll", "submit", etc.
    GLuint texture_id;

    // Colors
    ImVec4 bg_color;
    ImVec4 text_color;
    ImVec4 border_color;

    // Typography
    float font_size;
    float font_weight;
    std::string font_family;
    std::string font_style;     // "normal", "italic"
    int text_align;             // 0=left, 1=center, 2=right
    float line_height;
    float letter_spacing;
    std::string text_decoration; // "none", "underline", "line-through"
    std::string text_transform;  // "none", "uppercase", "lowercase", "capitalize"
    std::string text_shadow;     // CSS text-shadow value
    std::string word_spacing;    // CSS word-spacing value

    // Box model
    float padding_top, padding_right, padding_bottom, padding_left;
    float margin_top, margin_right, margin_bottom, margin_left;

    // Border & shape
    float border_width;
    float border_top_width, border_right_width, border_bottom_width, border_left_width;
    float border_radius;
    float border_radius_tl, border_radius_tr, border_radius_br, border_radius_bl;  // Individual corners
    std::string border_style;   // "solid", "dashed", "none"
    ImVec4 border_top_color, border_right_color, border_bottom_color, border_left_color;

    // Effects
    float opacity;
    std::string box_shadow;
    bool has_gradient;
    std::string gradient_css;
    std::string backdrop_filter;  // CSS backdrop-filter (blur, etc.)
    std::string filter;           // CSS filter (blur, brightness, etc.)
    std::string mix_blend_mode;   // CSS mix-blend-mode

    // Transform
    std::string transform;        // CSS transform value
    std::string transform_origin; // CSS transform-origin

    // Background
    std::string background_size;
    std::string background_position;
    std::string background_repeat;

    // Layout
    std::string overflow;
    std::string cursor;
    std::string flex_direction;
    std::string justify_content;
    std::string align_items;
    std::string gap;

    // Button interaction states
    ImVec4 hover_bg_color;       // Background color on hover
    ImVec4 hover_text_color;     // Text color on hover
    float hover_scale;           // Scale transform on hover (1.0 = no change)
    bool disabled;               // Button is disabled
    std::string element_id;      // HTML element ID (for scroll targets)
    std::string button_type;     // "submit", "reset", "button"
    std::string data_target;     // Modal/popup target
    std::string form_id;         // Associated form ID

    // Hero Animation (slideshow)
    std::vector<std::string> animation_images;      // Multiple images for slideshow
    std::vector<GLuint> animation_texture_ids;      // Texture IDs for animation images
    bool enable_animation;                          // Enable slideshow animation
    float animation_speed;                          // Seconds per image
    int current_frame;                              // Current animation frame
    float animation_timer;                          // Timer for animation

    // State
    bool selected;
    bool hovered;
    bool dragging;
    bool resizing;
    int resize_handle;          // 0-7 for 8 handles around the element
    float drag_offset_x, drag_offset_y;

    // Visibility
    bool visible;
    bool locked;

    // Parent-child relationship (for grouping)
    int parent_id;              // -1 if root level
    std::vector<int> child_ids;

    WebLayer() : id(0), type(LAYER_DIV), name("Layer"),
        x(0), y(0), width(100), height(50), z_index(0),
        texture_id(0),
        bg_color(1,1,1,0), text_color(0,0,0,1), border_color(0,0,0,1),
        font_size(16), font_weight(400), font_family("system-ui"), font_style("normal"),
        text_align(0), line_height(1.5f), letter_spacing(0), text_decoration("none"),
        text_transform("none"), text_shadow(""), word_spacing("normal"),
        padding_top(0), padding_right(0), padding_bottom(0), padding_left(0),
        margin_top(0), margin_right(0), margin_bottom(0), margin_left(0),
        border_width(0), border_top_width(0), border_right_width(0), border_bottom_width(0), border_left_width(0),
        border_radius(0),
        border_radius_tl(0), border_radius_tr(0), border_radius_br(0), border_radius_bl(0),
        border_style("none"),
        border_top_color(0,0,0,1), border_right_color(0,0,0,1), border_bottom_color(0,0,0,1), border_left_color(0,0,0,1),
        opacity(1.0f), box_shadow("none"), has_gradient(false), gradient_css(""),
        backdrop_filter(""), filter(""), mix_blend_mode("normal"),
        transform(""), transform_origin(""),
        background_size(""), background_position(""), background_repeat(""),
        overflow("visible"), cursor("default"), flex_direction(""), justify_content(""), align_items(""), gap(""),
        hover_bg_color(0.9f, 0.9f, 0.9f, 1.0f), hover_text_color(0,0,0,1),
        hover_scale(1.02f), disabled(false), button_type("button"),
        enable_animation(false), animation_speed(3.0f), current_frame(0), animation_timer(0.0f),
        selected(false), hovered(false), dragging(false), resizing(false),
        resize_handle(-1), drag_offset_x(0), drag_offset_y(0),
        visible(true), locked(false), parent_id(-1) {}
};

// Page data for multi-page websites
struct WebPage {
    std::string url;                    // Page URL (e.g., "/about", "/contact")
    std::string title;                  // Page title
    std::string screenshot_path;        // Screenshot for this page
    GLuint screenshot_texture_id;
    std::vector<WebLayer> layers;       // Layers for this page
    float canvas_height;                // Page-specific height

    WebPage() : screenshot_texture_id(0), canvas_height(3000) {}
};

// Figma-style project data
// Section structure for grouping layers (Figma mode)
struct FigmaSection {
    int id;
    std::string name;
    float y_start;
    float y_end;
    std::vector<int> layer_ids;
    ImVec4 bg_color;
    bool expanded;  // For collapsible tree view

    FigmaSection() : id(0), y_start(0), y_end(0), expanded(true), bg_color(1,1,1,1) {}
};

struct FigmaProject {
    std::string name;
    float canvas_width;
    float canvas_height;
    ImVec4 canvas_bg_color;
    std::string screenshot_path;    // Original website screenshot for reference
    GLuint screenshot_texture_id;
    std::vector<WebLayer> layers;
    std::vector<FigmaSection> sections;  // Section grouping for Figma mode
    int next_layer_id;

    // Multi-page support
    std::string source_url;                          // Original website URL (e.g., "https://example.com")
    std::string current_page;                        // Current page path (e.g., "/", "/about")
    std::map<std::string, WebPage> pages;            // All imported pages
    std::vector<std::string> page_order;             // Order of pages for UI

    // Viewport state
    float scroll_x, scroll_y;
    float zoom;

    // Selection state
    std::vector<int> selected_layer_ids;
    bool multi_select;

    // Grid/guide settings
    bool show_grid;
    float grid_size;
    bool snap_to_grid;
    bool show_guides;
    std::vector<float> horizontal_guides;
    std::vector<float> vertical_guides;

    // Reference image overlay
    bool show_reference;
    float reference_opacity;
    bool show_bounds;  // Show outlines around all layers
    bool preview_mode; // Preview mode - clicking buttons executes their actions

    // Section view mode
    bool show_sections;  // Toggle between section view and flat layer list

    FigmaProject() : name("Untitled"),
        canvas_width(1920), canvas_height(3000),
        canvas_bg_color(1,1,1,1),
        screenshot_texture_id(0),
        next_layer_id(1),
        current_page("/"),
        scroll_x(0), scroll_y(0), zoom(0.5f),
        multi_select(false),
        show_grid(false), grid_size(10), snap_to_grid(true),
        show_guides(false),
        show_reference(false), reference_opacity(1.0f), show_bounds(false), preview_mode(false),
        show_sections(true) {}
};

// Forward declaration of global project (defined in GLOBAL STATE section below)
static FigmaProject g_FigmaProject;

// Helper: Extract domain from URL
std::string ExtractDomain(const std::string& url) {
    size_t start = url.find("://");
    if (start == std::string::npos) return "";
    start += 3;
    size_t end = url.find("/", start);
    if (end == std::string::npos) end = url.length();
    return url.substr(start, end - start);
}

// Helper: Extract path from URL
std::string ExtractPath(const std::string& url) {
    size_t start = url.find("://");
    if (start == std::string::npos) {
        // No protocol, might be relative path
        if (url.empty() || url[0] == '/') return url;
        return "/" + url;
    }
    start += 3;
    size_t pathStart = url.find("/", start);
    if (pathStart == std::string::npos) return "/";
    return url.substr(pathStart);
}

// Helper: Lowercase ASCII string
std::string ToLowerAscii(const std::string& s) {
    std::string out = s;
    for (char& c : out) {
        if (c >= 'A' && c <= 'Z') c = (char)(c - 'A' + 'a');
    }
    return out;
}

// Helper: Sanitize name to anchor id (lowercase, alnum + dashes)
std::string SanitizeAnchor(const std::string& name) {
    std::string lower = ToLowerAscii(name);
    std::string out;
    out.reserve(lower.size());
    bool last_dash = false;
    for (char c : lower) {
        bool is_alnum = (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
        if (is_alnum) {
            out.push_back(c);
            last_dash = false;
        } else {
            if (!last_dash && !out.empty()) {
                out.push_back('-');
                last_dash = true;
            }
        }
    }
    if (!out.empty() && out.back() == '-') out.pop_back();
    return out;
}

// Helper: Find best section anchor based on button text or href path
std::string FindBestSectionAnchor(const std::string& hint,
                                  const std::vector<FigmaSection>& sections,
                                  const std::vector<std::string>& anchors) {
    if (sections.empty() || anchors.empty()) return "";
    std::string h = ToLowerAscii(hint);
    struct KeywordMap { const char* key; const char* name; };
    const KeywordMap keys[] = {
        {"contact", "contact"},
        {"get in touch", "contact"},
        {"support", "contact"},
        {"about", "about"},
        {"service", "service"},
        {"feature", "feature"},
        {"pricing", "pricing"},
        {"price", "pricing"},
        {"team", "team"},
        {"gallery", "gallery"},
        {"portfolio", "portfolio"},
        {"testimonial", "testimonial"},
        {"faq", "faq"},
        {"blog", "blog"},
        {"cta", "cta"},
        {"footer", "footer"},
        {"hero", "hero"}
    };

    for (const auto& km : keys) {
        if (h.find(km.key) != std::string::npos) {
            for (size_t i = 0; i < sections.size(); i++) {
                std::string sec_name = ToLowerAscii(sections[i].name);
                if (sec_name.find(km.name) != std::string::npos) {
                    return anchors[i];
                }
            }
        }
    }

    // Fallback: first section anchor
    return anchors[0];
}

// Rewrite button actions to internal anchors (no external redirects)
void RewriteFigmaActionsToInternal() {
    if (g_FigmaProject.layers.empty()) return;

    // Build anchors for sections (if available)
    std::vector<std::string> anchors;
    anchors.reserve(g_FigmaProject.sections.size());
    for (const auto& sec : g_FigmaProject.sections) {
        std::string anchor = SanitizeAnchor(sec.name);
        if (anchor.empty()) {
            anchor = "section-" + std::to_string(sec.id);
        }
        anchors.push_back(anchor);
    }

    // If no sections, create a single top anchor
    if (anchors.empty()) {
        anchors.push_back("top");
    }

    // Assign element_id to first layer in each section so scroll targets exist
    if (!g_FigmaProject.sections.empty()) {
        for (size_t i = 0; i < g_FigmaProject.sections.size(); i++) {
            const auto& sec = g_FigmaProject.sections[i];
            if (sec.layer_ids.empty()) continue;
            int first_id = sec.layer_ids[0];
            for (auto& layer : g_FigmaProject.layers) {
                if (layer.id == first_id) {
                    if (layer.element_id.empty()) {
                        layer.element_id = anchors[i];
                    }
                    break;
                }
            }
        }
    } else {
        // No sections: tag first layer as top anchor
        if (!g_FigmaProject.layers.empty() && g_FigmaProject.layers[0].element_id.empty()) {
            g_FigmaProject.layers[0].element_id = anchors[0];
        }
    }

    // Rewrite actions for buttons and clickable layers
    for (auto& layer : g_FigmaProject.layers) {
        bool is_button = (layer.type == LAYER_BUTTON);
        bool has_action = !layer.action_type.empty() && layer.action_type != "none";
        bool has_href = !layer.href.empty();

        if (!is_button && !has_action && !has_href) continue;

        // If href is anchor already, keep it (ensure action type)
        if (has_href && layer.href[0] == '#') {
            if (layer.action_type.empty() || layer.action_type == "none") {
                layer.action_type = "scroll";
            }
            continue;
        }

        // If external or empty, rewrite to internal anchor
        bool external = has_href && !IsInternalUrl(layer.href, g_FigmaProject.source_url) && layer.href[0] != '#';
        if (external || !has_href) {
            std::string hint = layer.text;
            if (!layer.href.empty()) hint += " " + layer.href;
            std::string anchor = FindBestSectionAnchor(hint, g_FigmaProject.sections, anchors);
            if (!anchor.empty()) {
                layer.href = "#" + anchor;
                layer.action_type = "scroll";
            }
        } else {
            // Internal URL but not anchor: convert to anchor based on path
            std::string path = ExtractPath(layer.href);
            std::string anchor = FindBestSectionAnchor(path, g_FigmaProject.sections, anchors);
            if (!anchor.empty()) {
                layer.href = "#" + anchor;
                layer.action_type = "scroll";
            }
        }
    }
}

// Helper: Check if URL is internal (same domain as source)
bool IsInternalUrl(const std::string& href, const std::string& sourceUrl) {
    if (href.empty()) return false;

    // Anchor links are internal
    if (href[0] == '#') return true;

    // Relative paths are internal
    if (href[0] == '/') return true;

    // Check if same domain
    if (href.find("http://") == 0 || href.find("https://") == 0) {
        std::string hrefDomain = ExtractDomain(href);
        std::string sourceDomain = ExtractDomain(sourceUrl);
        return hrefDomain == sourceDomain;
    }

    // Relative path without leading slash
    if (href.find("://") == std::string::npos) return true;

    return false;
}

// Navigate to internal page
void NavigateToPage(const std::string& pagePath) {
    std::string path = pagePath;

    // Normalize path
    if (path.empty() || path == "/") path = "/";
    else if (path[0] != '/') path = "/" + path;

    // Remove query string and hash for page lookup
    size_t queryPos = path.find("?");
    if (queryPos != std::string::npos) path = path.substr(0, queryPos);
    size_t hashPos = path.find("#");
    std::string anchor = "";
    if (hashPos != std::string::npos) {
        anchor = path.substr(hashPos + 1);
        path = path.substr(0, hashPos);
    }
    if (path.empty()) path = "/";

    printf("[Navigate] Attempting to navigate to page: %s\n", path.c_str());

    // Check if page exists
    if (g_FigmaProject.pages.find(path) != g_FigmaProject.pages.end()) {
        // Switch to the page
        g_FigmaProject.current_page = path;
        WebPage& page = g_FigmaProject.pages[path];
        g_FigmaProject.layers = page.layers;
        g_FigmaProject.canvas_height = page.canvas_height;
        g_FigmaProject.screenshot_path = page.screenshot_path;
        g_FigmaProject.screenshot_texture_id = page.screenshot_texture_id;
        g_FigmaProject.scroll_y = 0;
        g_FigmaProject.selected_layer_ids.clear();

        printf("[Navigate] Switched to page: %s (%zu layers)\n", path.c_str(), page.layers.size());

        // If there's an anchor, scroll to it after page switch
        if (!anchor.empty()) {
            for (auto& targetLayer : g_FigmaProject.layers) {
                if (targetLayer.element_id == anchor || targetLayer.name == anchor) {
                    g_FigmaProject.scroll_y = targetLayer.y - 50;
                    if (g_FigmaProject.scroll_y < 0) g_FigmaProject.scroll_y = 0;
                    printf("[Navigate] Scrolled to anchor: #%s\n", anchor.c_str());
                    break;
                }
            }
        }
    } else {
        printf("[Navigate] Page not imported: %s (available pages: %zu)\n", path.c_str(), g_FigmaProject.pages.size());
        for (auto& p : g_FigmaProject.pages) {
            printf("  - %s\n", p.first.c_str());
        }
    }
}

// Execute layer action (open URL, scroll, navigate)
void ExecuteLayerAction(const WebLayer& layer) {
    if (layer.href.empty() && layer.onclick_action.empty()) return;

    std::string href = layer.href.empty() ? layer.onclick_action : layer.href;
    std::string type = layer.action_type;

    printf("[Action] Executing: type='%s', href='%s'\n", type.c_str(), href.c_str());

    // Handle anchor links (scroll to section)
    if (!href.empty() && href[0] == '#') {
        std::string anchor = href.substr(1);
        bool found = false;
        for (auto& targetLayer : g_FigmaProject.layers) {
            if (targetLayer.element_id == anchor || targetLayer.name == anchor) {
                g_FigmaProject.scroll_y = targetLayer.y - 50;
                if (g_FigmaProject.scroll_y < 0) g_FigmaProject.scroll_y = 0;
                printf("[Action] Scrolled to: #%s (y=%.0f)\n", anchor.c_str(), targetLayer.y);
                found = true;
                break;
            }
        }
        if (!found) {
            printf("[Action] Anchor not found: #%s\n", anchor.c_str());
        }
        return;
    }

    // Check if it's an internal link
    if (IsInternalUrl(href, g_FigmaProject.source_url)) {
        std::string path = ExtractPath(href);
        NavigateToPage(path);
        return;
    }

    // External links - handle by type
    if (type == "link" || type == "none" || type.empty()) {
        if (!href.empty() && (href.find("http://") == 0 || href.find("https://") == 0)) {
#ifdef __APPLE__
            std::string cmd = "open \"" + href + "\"";
#elif defined(_WIN32)
            std::string cmd = "start \"\" \"" + href + "\"";
#else
            std::string cmd = "xdg-open \"" + href + "\"";
#endif
            system(cmd.c_str());
            printf("[Action] Opened external URL: %s\n", href.c_str());
        }
    } else if (type == "email") {
#ifdef __APPLE__
        std::string cmd = "open \"" + href + "\"";
#elif defined(_WIN32)
        std::string cmd = "start \"\" \"" + href + "\"";
#else
        std::string cmd = "xdg-open \"" + href + "\"";
#endif
        system(cmd.c_str());
        printf("[Action] Opened email: %s\n", href.c_str());
    } else if (type == "phone") {
#ifdef __APPLE__
        std::string cmd = "open \"" + href + "\"";
#elif defined(_WIN32)
        std::string cmd = "start \"\" \"" + href + "\"";
#else
        std::string cmd = "xdg-open \"" + href + "\"";
#endif
        system(cmd.c_str());
        printf("[Action] Opened phone: %s\n", href.c_str());
    } else if (type == "scroll") {
        // Already handled above for # links
        printf("[Action] Scroll type but no anchor in href\n");
    } else if (type == "popup" || type == "script") {
        printf("[Action] JavaScript action: %s (cannot execute in editor)\n", layer.onclick_action.c_str());
    } else if (type == "submit") {
        printf("[Action] Form submit (cannot execute in editor)\n");
    } else if (type == "button") {
        printf("[Action] Button clicked (no specific action defined)\n");
    }
}

// ============================================================================
// GLOBAL STATE
// ============================================================================
static GLFWwindow* g_Window = nullptr;
static int g_NextSectionId = 1;
static int g_SelectedSectionIndex = -1;
static int g_SelectedCardIndex = 0;      // Selected card index for Card Connector
static int g_SelectedVertBlockIndex = 0; // Selected block index for Vertical Connector

// Copy-Paste System
static bool g_HasCopiedSection = false;
static WebSection g_CopiedSection(0, SEC_CUSTOM);  // Holds copied section data
static float g_CanvasScrollY = 0;
static float g_Zoom = 1.0f;
static bool g_FreeDesignMode = true;           // Free design mode enabled - Figma-like free positioning
static float g_CanvasScrollX = 0;              // Horizontal scroll for free design mode
static ImVec4 g_NormalCanvasBgColor = ImVec4(1, 1, 1, 1);  // Canvas background color for Normal mode
static std::string g_ProjectName = "My Website";
static std::string g_CurrentPage = "Home";
static int g_CurrentPageIndex = 0;
static std::string g_ExportPath = "";
static bool g_ShowExportSuccess = false;
static float g_ExportSuccessTimer = 0;

// Template system state
static bool g_ShowTemplateGallery = false;
static bool g_ShowSaveTemplate = false;
static char g_TemplateNameBuffer[256] = "";

// URL Import state
static bool g_ShowURLImportDialog = false;
static char g_URLImportBuffer[512] = "";
static std::string g_URLImportStatus = "";
static bool g_URLImportInProgress = false;
static float g_URLImportProgress = 0.0f;
static int g_URLImportTimeout = 300; // Timeout in seconds (default 5 minutes)
static bool g_URLImportUseStealth = false; // Use Stealth Browser MCP for anti-bot bypass

// Local Download Import state
static int g_ImportMethod = 0; // 0 = Live Scrape, 1 = Local Download, 2 = Figma-style, 3 = Figma Design (API)
static char g_FigmaAPIToken[256] = "";  // Figma API token
static char g_FigmaFileURL[512] = "";   // Figma file URL or key
static std::string g_DownloadedSitePath = "";
static bool g_DownloadComplete = false;

// Figma-style Editor State
static bool g_FigmaMode = false;                    // True = Figma editor, False = Section editor
// g_FigmaProject is declared above ExecuteLayerAction function
static int g_SelectedLayerId = -1;                  // Currently selected layer
static int g_HoveredLayerId = -1;                   // Layer under mouse click (for topmost selection)
static bool g_ShowFigmaLayers = true;               // Show layers panel
static bool g_ShowFigmaProperties = true;           // Show properties panel
static bool g_FigmaImportInProgress = false;        // Import in progress
static std::string g_FigmaImportStatus = "";        // Import status message

// Tool System State
static ToolType g_CurrentTool = TOOL_SELECT;        // Currently active tool
static bool g_IsDrawing = false;                    // Currently drawing/creating element
static float g_DrawStartX = 0, g_DrawStartY = 0;    // Drawing start position (canvas coords)
static float g_DrawCurrentX = 0, g_DrawCurrentY = 0; // Current draw position for preview

// Resize System State
static bool g_IsResizing = false;                    // Currently resizing an element
static int g_ResizeHandle = -1;                      // Which handle is being dragged (0-7)
static int g_ResizeLayerId = -1;                     // ID of layer being resized
static float g_ResizeStartX = 0, g_ResizeStartY = 0; // Mouse position at resize start
static float g_ResizeOrigX = 0, g_ResizeOrigY = 0;   // Original layer position
static float g_ResizeOrigW = 0, g_ResizeOrigH = 0;   // Original layer size

// Undo/Redo System
struct UndoState {
    std::vector<WebLayer> layers;
    std::string description;
};
static std::vector<UndoState> g_UndoStack;
static std::vector<UndoState> g_RedoStack;
static const int MAX_UNDO_LEVELS = 50;

// Clipboard for Copy/Paste
static std::vector<WebLayer> g_Clipboard;

// ImGui Templates Feature
static bool g_ShowImGuiTemplatesPopup = false;      // Show ImGui templates popup
static bool g_ShowSaveImGuiTemplatePopup = false;   // Show save ImGui template popup
static bool g_ShowCopyTemplatePopup = false;        // Show copy template popup
static bool g_ShowExportOptionsPopup = false;       // Show export options popup
static bool g_ShowIconPickerPopup = false;          // Show icon picker popup
static int* g_IconPickerTarget = nullptr;           // Pointer to icon_type to update
static bool g_AddingNewIcon = false;                // True when adding new icon from + Icon button
struct ImGuiTemplateInfo {
    int id;
    std::string name;
    std::string created_at;
    int layer_count;
    float canvas_width;
    float canvas_height;
};
static std::vector<ImGuiTemplateInfo> g_ImGuiTemplatesList;  // List of saved ImGui templates

// Template Picker Modal State
static bool g_ShowTemplatePicker = false;
static SectionType g_PickerSectionType = SEC_HERO;
static int g_SelectedStyleIndex = -1;

// Section Drag-and-Drop State
static bool g_DraggingSection = false;
static int g_DraggedSectionIndex = -1;
static int g_DropTargetIndex = -1;
static float g_DragOffsetY = 0;

// Template Style Preset Structure
struct StylePreset {
    std::string name;
    std::string description;
    std::string preview_emoji;  // Visual indicator for style
};

// Style presets for each section type (5 variations each)
static const std::map<SectionType, std::vector<StylePreset>> g_StylePresets = {
    {SEC_HERO, {
        {"Modern Gradient", "Deep blue gradient with glass buttons and elegant typography", "üåä"},
        {"Minimalist Light", "Clean white background with subtle shadows and modern fonts", "‚ú®"},
        {"Dark Premium", "Luxury dark background with gold accents and premium feel", "üëë"},
        {"Colorful Creative", "Vibrant gradient with playful animations and bold colors", "üé®"},
        {"Corporate Professional", "Traditional blue and white with trustworthy design", "üíº"}
    }},
    {SEC_CONTACT, {
        {"Luxury Glass Form", "Dark background with frosted glass inputs and gold labels", "üíé"},
        {"Minimalist White", "Clean white form with simple borders and modern typography", "üìù"},
        {"Corporate Professional", "Traditional blue form with structured layout", "üè¢"},
        {"Creative Colorful", "Vibrant gradient background with playful form elements", "üé®"},
        {"Elegant Dark", "Deep dark background with elegant white form fields", "üåô"}
    }},
    {SEC_SERVICES, {
        {"Glass Morph Cards", "Frosted glass cards with blur effects and modern design", "üí´"},
        {"Solid Modern Cards", "Clean solid color cards with sharp borders", "üì¶"},
        {"Gradient Cards", "Cards with beautiful gradient backgrounds", "üåà"},
        {"Icon-First Cards", "Large icons with minimal text and modern feel", "üéØ"},
        {"List Style", "Simple list layout with dividers and clean spacing", "üìã"}
    }},
    {SEC_PRICING, {
        {"3-Tier Glass", "Three pricing tiers with glass effect and highlighted popular plan", "‚≠ê"},
        {"Minimal Cards", "Simple white cards with subtle shadows", "üìÑ"},
        {"Bold Colored", "Vibrant colored cards with strong CTAs", "üéØ"},
        {"Enterprise Dark", "Dark professional cards for B2B", "üíº"},
        {"Comparison Table", "Side-by-side comparison layout", "üìä"}
    }},
    {SEC_TEAM, {
        {"Colorful Avatars", "Team cards with vibrant colored accent borders", "üë•"},
        {"Professional Cards", "Clean white cards with subtle shadows", "üè¢"},
        {"Circle Photos", "Circular avatar photos with minimal design", "‚≠ï"},
        {"Glass Cards", "Frosted glass effect cards", "üíé"},
        {"Grid Layout", "Simple grid with hover effects", "üìê"}
    }},
    {SEC_TESTIMONIALS, {
        {"Quote Cards", "Cards with large quote marks and elegant design", "üí¨"},
        {"Minimal White", "Clean white cards with customer photos", "‚ú®"},
        {"Colored Accents", "Cards with colored left border accent", "üé®"},
        {"Glass Effect", "Frosted glass cards", "üí´"},
        {"Slider Layout", "Horizontal scrolling testimonials", "üì±"}
    }},
    {SEC_GALLERY, {
        {"2x2 Grid", "Four images in square grid layout (2 rows √ó 2 columns)", "‚¨õ"},
        {"1x4 Horizontal", "Four images in horizontal row layout", "‚ñ¨"}
    }},
    {SEC_ABOUT, {
        {"Story Format", "Narrative layout with timeline", "üìñ"},
        {"Stats & Facts", "Data-driven about section", "üìä"},
        {"Mission & Vision", "Split layout with core values", "üéØ"},
        {"Team Intro", "About with team preview", "üë•"},
        {"Minimal Clean", "Simple text-focused layout", "‚ú®"}
    }},
    {SEC_CTA, {
        {"Bold Gradient", "Eye-catching gradient with large button", "üöÄ"},
        {"Minimal White", "Clean white with simple CTA", "‚ú®"},
        {"Dark Impact", "Dark background with bright CTA", "‚ö°"},
        {"Glass Effect", "Frosted glass panel", "üíé"},
        {"Split Layout", "Text on left, form on right", "üìê"}
    }},
    {SEC_FOOTER, {
        {"Multi-Column", "4-column footer with links and social", "üìö"},
        {"Minimal", "Simple single-row footer", "‚ûñ"},
        {"Newsletter", "Footer with newsletter signup", "üìß"},
        {"Social Focus", "Large social icons and minimal text", "üîó"},
        {"Dark Premium", "Dark elegant footer", "üåô"}
    }},
    {SEC_NAVBAR, {
        {"Modern Transparent", "Transparent navbar with blur effect", "üíé"},
        {"Solid White", "Clean white navbar with shadow", "üìÑ"},
        {"Dark Professional", "Dark navbar with high contrast", "üåô"},
        {"Colorful Gradient", "Gradient background navbar", "üåà"},
        {"Minimal Border", "Simple with bottom border only", "‚ûñ"}
    }},
    {SEC_CARDS, {
        {"Glass Cards", "Frosted glass effect cards", "üíé"},
        {"Modern White", "Clean white cards with shadows", "üìÑ"},
        {"Colorful Gradient", "Vibrant gradient backgrounds", "üåà"},
        {"Minimal Border", "Simple bordered cards", "üìê"},
        {"Dark Theme", "Dark cards with light text", "üåô"}
    }},
    {SEC_BLOG, {
        {"Magazine Style", "Large featured images with excerpts", "üì∞"},
        {"Minimal Cards", "Simple text-focused cards", "üìù"},
        {"Grid Layout", "Equal-sized grid of posts", "üìê"},
        {"Timeline", "Chronological timeline layout", "üìÖ"},
        {"List View", "Full-width list with thumbnails", "üìã"}
    }},
    {SEC_FAQ, {
        {"Accordion Style", "Expandable question cards", "üìñ"},
        {"Two Column", "Questions in two columns", "üìê"},
        {"Minimal List", "Simple Q&A list", "üìù"},
        {"Card Style", "Each FAQ in a card", "üí≥"},
        {"Search & Filter", "With search functionality", "üîç"}
    }},
    {SEC_STATS, {
        {"Big Numbers", "Large statistics with icons", "üìä"},
        {"Counter Animation", "Animated counting numbers", "üî¢"},
        {"Chart Style", "With progress bars", "üìà"},
        {"Minimal Cards", "Clean stat cards", "üí≥"},
        {"Colorful Gradient", "Vibrant background stats", "üåà"}
    }},
    {SEC_LOGIN, {
        {"Luxury Glass", "Dark with glass effect", "üíé"},
        {"Minimal White", "Clean white form", "üìÑ"},
        {"Corporate Blue", "Professional blue theme", "üè¢"},
        {"Gradient Background", "Colorful gradient", "üåà"},
        {"Split Screen", "Image on left, form on right", "üìê"}
    }},
    {SEC_FEATURES, {
        {"Icon Grid", "Grid layout with icons and descriptions", "üéØ"},
        {"List Style", "Vertical list with checkmarks", "‚úÖ"},
        {"Highlighted Cards", "Feature cards with accents", "üíé"},
        {"Timeline View", "Features in timeline format", "üìÖ"},
        {"Comparison Table", "Side-by-side feature comparison", "üìä"}
    }},
    {SEC_CUSTOM, {
        {"Modern Default", "Modern clean layout", "‚ú®"},
        {"Minimal", "Simple and minimal", "‚ûñ"},
        {"Colorful", "Vibrant and bold", "üé®"},
        {"Professional", "Corporate and trustworthy", "üíº"},
        {"Creative", "Unique and artistic", "üé≠"}
    }},
    {SEC_IMAGE, {
        {"Full Width", "Large full-width image", "üñºÔ∏è"},
        {"Centered", "Centered image with padding", "üì∑"},
        {"Rounded Corners", "Image with rounded edges", "‚≠ï"},
        {"With Shadow", "Image with drop shadow", "‚ú®"},
        {"Minimal Border", "Simple bordered image", "üìê"}
    }},
    {SEC_TEXTBOX, {
        {"Modern Card", "Text in modern card layout", "üìù"},
        {"Minimal White", "Clean white background", "‚ú®"},
        {"Gradient Background", "Vibrant gradient", "üåà"},
        {"Glass Effect", "Frosted glass card", "üíé"},
        {"Bordered Style", "Simple bordered box", "üìê"}
    }}
};

static char g_TemplateDescBuffer[512] = "";
struct TemplateInfo {
    std::string name;
    std::string filename;
    std::string description;
    std::string created_date;
};
static std::vector<TemplateInfo> g_AvailableTemplates;

// ============================================================================
// TEMPLATE SYSTEM - Save/Load Website Templates
// ============================================================================

// Helper: Escape string for JSON
std::string JsonEscape(const std::string& str) {
    std::string escaped;
    for (char c : str) {
        switch (c) {
            case '\"': escaped += "\\\""; break;
            case '\\': escaped += "\\\\"; break;
            case '\b': escaped += "\\b"; break;
            case '\f': escaped += "\\f"; break;
            case '\n': escaped += "\\n"; break;
            case '\r': escaped += "\\r"; break;
            case '\t': escaped += "\\t"; break;
            default: escaped += c; break;
        }
    }
    return escaped;
}

// Helper: Color to JSON
std::string ColorToJson(const ImVec4& color) {
    char buf[128];
    snprintf(buf, sizeof(buf), "{\"r\":%.3f,\"g\":%.3f,\"b\":%.3f,\"a\":%.3f}",
             color.x, color.y, color.z, color.w);
    return buf;
}

// Helper: JSON to Color
ImVec4 JsonToColor(const std::string& json) {
    ImVec4 color(1, 1, 1, 1);
    sscanf(json.c_str(), "{\"r\":%f,\"g\":%f,\"b\":%f,\"a\":%f}",
           &color.x, &color.y, &color.z, &color.w);
    return color;
}

// ============================================================================
// CONNECTOR SERIALIZATION FUNCTIONS
// ============================================================================

// Serialize TextBlocks to JSON
std::string TextBlocksToJson(const std::vector<TextBlock>& blocks) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < blocks.size(); i++) {
        if (i > 0) oss << ",";
        const auto& block = blocks[i];
        oss << "{\"fontSize\":" << block.fontSize
            << ",\"textColor\":" << ColorToJson(block.textColor)
            << ",\"boldColor\":" << ColorToJson(block.boldColor)
            << ",\"lineSpacing\":" << block.lineSpacing
            << ",\"segments\":[";
        for (size_t j = 0; j < block.segments.size(); j++) {
            if (j > 0) oss << ",";
            oss << "{\"text\":\"" << JsonEscape(block.segments[j].text)
                << "\",\"isBold\":" << (block.segments[j].isBold ? "true" : "false") << "}";
        }
        oss << "]}";
    }
    oss << "]";
    return oss.str();
}

// Serialize BarItems to JSON
std::string BarItemsToJson(const std::vector<BarItem>& items) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < items.size(); i++) {
        if (i > 0) oss << ",";
        const auto& item = items[i];
        oss << "{\"heading\":\"" << JsonEscape(item.heading) << "\""
            << ",\"barColor\":" << ColorToJson(item.barColor)
            << ",\"barWidth\":" << item.barWidth
            << ",\"barHeight\":" << item.barHeight
            << ",\"headingColor\":" << ColorToJson(item.headingColor)
            << ",\"headingSize\":" << item.headingSize
            << ",\"headingBoldness\":" << item.headingBoldness
            << ",\"paddingLeft\":" << item.paddingLeft << "}";
    }
    oss << "]";
    return oss.str();
}

// Serialize FooterColumns to JSON
std::string FooterColumnsToJson(const std::vector<FooterColumn>& columns) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < columns.size(); i++) {
        if (i > 0) oss << ",";
        const auto& col = columns[i];
        oss << "{\"heading\":\"" << JsonEscape(col.heading) << "\",\"items\":[";
        for (size_t j = 0; j < col.items.size(); j++) {
            if (j > 0) oss << ",";
            oss << "\"" << JsonEscape(col.items[j]) << "\"";
        }
        oss << "]}";
    }
    oss << "]";
    return oss.str();
}

// Serialize ThumbnailCards to JSON (without image data - images saved separately)
std::string ConnectorCardsToJson(const std::vector<ThumbnailCard>& cards) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < cards.size(); i++) {
        if (i > 0) oss << ",";
        const auto& card = cards[i];
        oss << "{\"heading\":\"" << JsonEscape(card.heading) << "\""
            << ",\"description\":\"" << JsonEscape(card.description) << "\""
            << ",\"imagePath\":\"" << JsonEscape(card.imagePath) << "\""
            << ",\"headingBoldness\":" << card.headingBoldness
            << ",\"headingSize\":" << card.headingSize
            << ",\"descriptionBoldness\":" << card.descriptionBoldness
            << ",\"descriptionSize\":" << card.descriptionSize
            << ",\"headingColor\":" << ColorToJson(card.headingColor)
            << ",\"descriptionColor\":" << ColorToJson(card.descriptionColor)
            << ",\"cardColor\":" << ColorToJson(card.cardColor)
            << ",\"cardWidth\":" << card.cardWidth
            << ",\"cardHeight\":" << card.cardHeight
            << ",\"borderThickness\":" << card.borderThickness
            << ",\"borderColor\":" << ColorToJson(card.borderColor) << "}";
    }
    oss << "]";
    return oss.str();
}

// Serialize VerticalBlocks to JSON
std::string VerticalBlocksToJson(const std::vector<VerticalBlock>& blocks) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < blocks.size(); i++) {
        if (i > 0) oss << ",";
        const auto& block = blocks[i];
        oss << "{\"type\":" << block.type
            << ",\"text\":\"" << JsonEscape(block.text) << "\""
            << ",\"imagePath\":\"" << JsonEscape(block.imagePath) << "\""
            << ",\"displayWidth\":" << block.displayWidth
            << ",\"posX\":" << block.posX
            << ",\"posY\":" << block.posY << "}";
    }
    oss << "]";
    return oss.str();
}

std::string NavbarItemsToJson(const std::vector<NavbarMenuItem>& items) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < items.size(); i++) {
        if (i > 0) oss << ",";
        const auto& item = items[i];
        oss << "{\"label\":\"" << JsonEscape(item.label) << "\",\"children\":[";
        for (size_t j = 0; j < item.children.size(); j++) {
            if (j > 0) oss << ",";
            oss << "\"" << JsonEscape(item.children[j]) << "\"";
        }
        oss << "]}";
    }
    oss << "]";
    return oss.str();
}

// Serialize CopyrightLinks to JSON
std::string CopyrightLinksToJson(const std::vector<CopyrightLink>& links) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < links.size(); i++) {
        if (i > 0) oss << ",";
        const auto& link = links[i];
        oss << "{\"text\":\"" << JsonEscape(link.text) << "\""
            << ",\"url\":\"" << JsonEscape(link.url) << "\""
            << ",\"isBold\":" << (link.isBold ? "true" : "false")
            << ",\"actionType\":" << link.actionType << "}";
    }
    oss << "]";
    return oss.str();
}

// Serialize ArticleCards to JSON
std::string ArticleCardsToJson(const std::vector<ArticleCard>& cards) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < cards.size(); i++) {
        if (i > 0) oss << ",";
        const auto& card = cards[i];
        oss << "{\"heading\":\"" << JsonEscape(card.heading) << "\""
            << ",\"date\":\"" << JsonEscape(card.date) << "\""
            << ",\"description\":\"" << JsonEscape(card.description) << "\""
            << ",\"readMoreText\":\"" << JsonEscape(card.readMoreText) << "\""
            << ",\"headingColor\":" << ColorToJson(card.headingColor)
            << ",\"dateColor\":" << ColorToJson(card.dateColor)
            << ",\"descriptionColor\":" << ColorToJson(card.descriptionColor)
            << ",\"readMoreColor\":" << ColorToJson(card.readMoreColor)
            << ",\"cardBgColor\":" << ColorToJson(card.cardBgColor)
            << ",\"accentColor\":" << ColorToJson(card.accentColor)
            << ",\"headingSize\":" << card.headingSize
            << ",\"dateSize\":" << card.dateSize
            << ",\"descriptionSize\":" << card.descriptionSize
            << ",\"readMoreSize\":" << card.readMoreSize
            << ",\"cardWidth\":" << card.cardWidth
            << ",\"cardHeight\":" << card.cardHeight
            << ",\"accentWidth\":" << card.accentWidth
            << ",\"cardPadding\":" << card.cardPadding
            << ",\"headingActionType\":" << card.headingActionType
            << ",\"headingActionTarget\":\"" << JsonEscape(card.headingActionTarget) << "\""
            << ",\"readMoreActionType\":" << card.readMoreActionType
            << ",\"readMoreActionTarget\":\"" << JsonEscape(card.readMoreActionTarget) << "\"}";
    }
    oss << "]";
    return oss.str();
}

// Serialize ContactFormFields to JSON
std::string ContactFormFieldsToJson(const std::vector<ContactFormField>& fields) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < fields.size(); i++) {
        if (i > 0) oss << ",";
        const auto& field = fields[i];
        oss << "{\"label\":\"" << JsonEscape(field.label) << "\""
            << ",\"placeholder\":\"" << JsonEscape(field.placeholder) << "\""
            << ",\"fieldType\":" << field.fieldType
            << ",\"width\":" << field.width
            << ",\"required\":" << (field.required ? "true" : "false") << "}";
    }
    oss << "]";
    return oss.str();
}

// Serialize ServiceCards to JSON
std::string ServiceCardsToJson(const std::vector<ServiceCard>& cards) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < cards.size(); i++) {
        if (i > 0) oss << ",";
        const auto& card = cards[i];
        oss << "{\"title\":\"" << JsonEscape(card.title) << "\""
            << ",\"badgeText\":\"" << JsonEscape(card.badgeText) << "\""
            << ",\"imagePath\":\"" << JsonEscape(card.imagePath) << "\""
            << ",\"titleColor\":" << ColorToJson(card.titleColor)
            << ",\"badgeColor\":" << ColorToJson(card.badgeColor)
            << ",\"badgeTextColor\":" << ColorToJson(card.badgeTextColor)
            << ",\"cardBgColor\":" << ColorToJson(card.cardBgColor)
            << ",\"cardWidth\":" << card.cardWidth
            << ",\"cardHeight\":" << card.cardHeight
            << ",\"borderRadius\":" << card.borderRadius
            << ",\"actionType\":" << card.actionType
            << ",\"actionTarget\":\"" << JsonEscape(card.actionTarget) << "\"}";
    }
    oss << "]";
    return oss.str();
}

// Serialize HeroFeatureBadges to JSON
std::string HeroFeatureBadgesToJson(const std::vector<HeroFeatureBadge>& badges) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < badges.size(); i++) {
        if (i > 0) oss << ",";
        const auto& badge = badges[i];
        oss << "{\"text\":\"" << JsonEscape(badge.text) << "\""
            << ",\"checkColor\":" << ColorToJson(badge.checkColor) << "}";
    }
    oss << "]";
    return oss.str();
}

// Serialize HeroStats to JSON
std::string HeroStatsToJson(const std::vector<HeroStatItem>& stats) {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < stats.size(); i++) {
        if (i > 0) oss << ",";
        const auto& stat = stats[i];
        oss << "{\"iconType\":" << stat.iconType
            << ",\"number\":\"" << JsonEscape(stat.number) << "\""
            << ",\"label\":\"" << JsonEscape(stat.label) << "\""
            << ",\"iconColor\":" << ColorToJson(stat.iconColor)
            << ",\"numberColor\":" << ColorToJson(stat.numberColor)
            << ",\"labelColor\":" << ColorToJson(stat.labelColor) << "}";
    }
    oss << "]";
    return oss.str();
}

// Parse JSON string helper - simple extraction
std::string ExtractJsonString(const std::string& json, const std::string& key) {
    std::string searchKey = "\"" + key + "\":\"";
    size_t start = json.find(searchKey);
    if (start == std::string::npos) return "";
    start += searchKey.length();
    size_t end = json.find("\"", start);
    while (end != std::string::npos && end > 0 && json[end-1] == '\\') {
        end = json.find("\"", end + 1);
    }
    if (end == std::string::npos) return "";
    std::string result = json.substr(start, end - start);
    // Unescape
    size_t pos = 0;
    while ((pos = result.find("\\\"", pos)) != std::string::npos) {
        result.replace(pos, 2, "\"");
        pos++;
    }
    pos = 0;
    while ((pos = result.find("\\n", pos)) != std::string::npos) {
        result.replace(pos, 2, "\n");
        pos++;
    }
    return result;
}

float ExtractJsonFloat(const std::string& json, const std::string& key, float defaultVal = 0) {
    std::string searchKey = "\"" + key + "\":";
    size_t start = json.find(searchKey);
    if (start == std::string::npos) return defaultVal;
    start += searchKey.length();
    return std::stof(json.substr(start));
}

bool ExtractJsonBool(const std::string& json, const std::string& key, bool defaultVal = false) {
    std::string searchKey = "\"" + key + "\":";
    size_t start = json.find(searchKey);
    if (start == std::string::npos) return defaultVal;
    start += searchKey.length();
    return json.substr(start, 4) == "true";
}

ImVec4 ExtractJsonColor(const std::string& json, const std::string& key) {
    std::string searchKey = "\"" + key + "\":{";
    size_t start = json.find(searchKey);
    if (start == std::string::npos) return ImVec4(1,1,1,1);
    start += searchKey.length() - 1;
    size_t end = json.find("}", start);
    if (end == std::string::npos) return ImVec4(1,1,1,1);
    return JsonToColor(json.substr(start, end - start + 1));
}

int ExtractJsonInt(const std::string& json, const std::string& key, int defaultVal = 0) {
    std::string searchKey = "\"" + key + "\":";
    size_t start = json.find(searchKey);
    if (start == std::string::npos) return defaultVal;
    start += searchKey.length();
    return std::stoi(json.substr(start));
}

// Parse HeroFeatureBadges from JSON
std::vector<HeroFeatureBadge> HeroFeatureBadgesFromJson(const std::string& json) {
    std::vector<HeroFeatureBadge> badges;
    size_t pos = 0;
    while ((pos = json.find("{", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;
        std::string obj = json.substr(pos, end - pos + 1);
        HeroFeatureBadge badge;
        std::string text = ExtractJsonString(obj, "text");
        strncpy(badge.text, text.c_str(), sizeof(badge.text) - 1);
        badge.text[sizeof(badge.text) - 1] = '\0';
        badge.checkColor = ExtractJsonColor(obj, "checkColor");
        badges.push_back(badge);
        pos = end + 1;
    }
    return badges;
}

// Parse HeroStats from JSON
std::vector<HeroStatItem> HeroStatsFromJson(const std::string& json) {
    std::vector<HeroStatItem> stats;
    size_t pos = 0;
    while ((pos = json.find("{", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;
        std::string obj = json.substr(pos, end - pos + 1);
        HeroStatItem stat;
        stat.iconType = ExtractJsonInt(obj, "iconType", 0);
        std::string num = ExtractJsonString(obj, "number");
        strncpy(stat.number, num.c_str(), sizeof(stat.number) - 1);
        stat.number[sizeof(stat.number) - 1] = '\0';
        std::string lbl = ExtractJsonString(obj, "label");
        strncpy(stat.label, lbl.c_str(), sizeof(stat.label) - 1);
        stat.label[sizeof(stat.label) - 1] = '\0';
        stat.iconColor = ExtractJsonColor(obj, "iconColor");
        stat.numberColor = ExtractJsonColor(obj, "numberColor");
        stat.labelColor = ExtractJsonColor(obj, "labelColor");
        stats.push_back(stat);
        pos = end + 1;
    }
    return stats;
}

// Parse ServiceCards from JSON
std::vector<ServiceCard> ServiceCardsFromJson(const std::string& json) {
    std::vector<ServiceCard> cards;
    if (json.empty() || json == "[]") return cards;

    size_t pos = 0;
    while ((pos = json.find("{", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;
        std::string cardJson = json.substr(pos, end - pos + 1);

        ServiceCard card;
        std::string title = ExtractJsonString(cardJson, "title");
        strncpy(card.title, title.c_str(), sizeof(card.title) - 1);
        std::string badge = ExtractJsonString(cardJson, "badgeText");
        strncpy(card.badgeText, badge.c_str(), sizeof(card.badgeText) - 1);
        card.imagePath = ExtractJsonString(cardJson, "imagePath");
        card.titleColor = ExtractJsonColor(cardJson, "titleColor");
        card.badgeColor = ExtractJsonColor(cardJson, "badgeColor");
        card.badgeTextColor = ExtractJsonColor(cardJson, "badgeTextColor");
        card.cardBgColor = ExtractJsonColor(cardJson, "cardBgColor");
        card.cardWidth = ExtractJsonFloat(cardJson, "cardWidth");
        card.cardHeight = ExtractJsonFloat(cardJson, "cardHeight");
        card.borderRadius = ExtractJsonFloat(cardJson, "borderRadius");
        card.actionType = ExtractJsonInt(cardJson, "actionType");
        std::string target = ExtractJsonString(cardJson, "actionTarget");
        strncpy(card.actionTarget, target.c_str(), sizeof(card.actionTarget) - 1);

        cards.push_back(card);
        pos = end + 1;
    }
    return cards;
}

// Deserialize JSON to TextBlocks
void JsonToTextBlocks(const std::string& json, std::vector<TextBlock>& blocks) {
    blocks.clear();
    if (json.empty() || json == "[]") return;

    // Simple parser - find each block object
    size_t pos = 0;
    while ((pos = json.find("{\"fontSize\":", pos)) != std::string::npos) {
        size_t end = json.find("}]}", pos);
        if (end == std::string::npos) end = json.find("}}", pos);
        if (end == std::string::npos) break;
        end += 2;

        std::string blockJson = json.substr(pos, end - pos);
        TextBlock block;
        block.fontSize = ExtractJsonFloat(blockJson, "fontSize", 16);
        block.textColor = ExtractJsonColor(blockJson, "textColor");
        block.boldColor = ExtractJsonColor(blockJson, "boldColor");
        block.lineSpacing = ExtractJsonFloat(blockJson, "lineSpacing", 1.5f);

        // Parse segments
        size_t segStart = blockJson.find("\"segments\":[");
        if (segStart != std::string::npos) {
            size_t segPos = segStart;
            while ((segPos = blockJson.find("{\"text\":", segPos)) != std::string::npos) {
                size_t segEnd = blockJson.find("}", segPos);
                if (segEnd == std::string::npos) break;
                std::string segJson = blockJson.substr(segPos, segEnd - segPos + 1);
                TextSegment seg;
                seg.text = ExtractJsonString(segJson, "text");
                seg.isBold = ExtractJsonBool(segJson, "isBold");
                block.segments.push_back(seg);
                segPos = segEnd + 1;
            }
        }
        blocks.push_back(block);
        pos = end;
    }
}

// Deserialize JSON to BarItems
void JsonToBarItems(const std::string& json, std::vector<BarItem>& items) {
    items.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"heading\":", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;

        std::string itemJson = json.substr(pos, end - pos + 1);
        BarItem item;
        std::string heading = ExtractJsonString(itemJson, "heading");
        strncpy(item.heading, heading.c_str(), sizeof(item.heading) - 1);
        item.barColor = ExtractJsonColor(itemJson, "barColor");
        item.barWidth = ExtractJsonFloat(itemJson, "barWidth", 800);
        item.barHeight = ExtractJsonFloat(itemJson, "barHeight", 50);
        item.headingColor = ExtractJsonColor(itemJson, "headingColor");
        item.headingSize = ExtractJsonFloat(itemJson, "headingSize", 1.3f);
        item.headingBoldness = ExtractJsonFloat(itemJson, "headingBoldness", 1.5f);
        item.paddingLeft = ExtractJsonFloat(itemJson, "paddingLeft", 20);
        items.push_back(item);
        pos = end + 1;
    }
}

// Deserialize JSON to FooterColumns
void JsonToFooterColumns(const std::string& json, std::vector<FooterColumn>& columns) {
    columns.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"heading\":", pos)) != std::string::npos) {
        size_t end = json.find("]}", pos);
        if (end == std::string::npos) break;
        end += 2;

        std::string colJson = json.substr(pos, end - pos);
        FooterColumn col;
        std::string heading = ExtractJsonString(colJson, "heading");
        strncpy(col.heading, heading.c_str(), sizeof(col.heading) - 1);

        // Parse items array
        size_t itemsStart = colJson.find("\"items\":[");
        if (itemsStart != std::string::npos) {
            size_t itemsEnd = colJson.find("]", itemsStart);
            std::string itemsJson = colJson.substr(itemsStart + 9, itemsEnd - itemsStart - 9);
            size_t itemPos = 0;
            while ((itemPos = itemsJson.find("\"", itemPos)) != std::string::npos) {
                size_t itemEnd = itemsJson.find("\"", itemPos + 1);
                if (itemEnd == std::string::npos) break;
                col.items.push_back(itemsJson.substr(itemPos + 1, itemEnd - itemPos - 1));
                itemPos = itemEnd + 1;
            }
        }
        columns.push_back(col);
        pos = end;
    }
}

// Deserialize JSON to ThumbnailCards
void JsonToConnectorCards(const std::string& json, std::vector<ThumbnailCard>& cards) {
    cards.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"heading\":", pos)) != std::string::npos) {
        size_t end = pos + 1;
        int braceCount = 1;
        while (braceCount > 0 && end < json.length()) {
            if (json[end] == '{') braceCount++;
            else if (json[end] == '}') braceCount--;
            end++;
        }

        std::string cardJson = json.substr(pos, end - pos);
        ThumbnailCard card;
        std::string heading = ExtractJsonString(cardJson, "heading");
        strncpy(card.heading, heading.c_str(), sizeof(card.heading) - 1);
        std::string desc = ExtractJsonString(cardJson, "description");
        strncpy(card.description, desc.c_str(), sizeof(card.description) - 1);
        card.imagePath = ExtractJsonString(cardJson, "imagePath");
        card.headingBoldness = ExtractJsonFloat(cardJson, "headingBoldness", 1.0f);
        card.headingSize = ExtractJsonFloat(cardJson, "headingSize", 1.2f);
        card.descriptionBoldness = ExtractJsonFloat(cardJson, "descriptionBoldness", 0);
        card.descriptionSize = ExtractJsonFloat(cardJson, "descriptionSize", 1.0f);
        card.headingColor = ExtractJsonColor(cardJson, "headingColor");
        card.descriptionColor = ExtractJsonColor(cardJson, "descriptionColor");
        card.cardColor = ExtractJsonColor(cardJson, "cardColor");
        card.cardWidth = ExtractJsonFloat(cardJson, "cardWidth", 280);
        card.cardHeight = ExtractJsonFloat(cardJson, "cardHeight", 340);
        card.borderThickness = ExtractJsonFloat(cardJson, "borderThickness", 1);
        card.borderColor = ExtractJsonColor(cardJson, "borderColor");

        // Load image if path exists
        if (!card.imagePath.empty()) {
            int w, h, n;
            unsigned char* data = stbi_load(card.imagePath.c_str(), &w, &h, &n, 4);
            if (data) {
                glGenTextures(1, &card.textureID);
                glBindTexture(GL_TEXTURE_2D, card.textureID);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                stbi_image_free(data);
                card.imageWidth = w;
                card.imageHeight = h;
            }
        }
        cards.push_back(card);
        pos = end;
    }
}

// Deserialize JSON to VerticalBlocks
void JsonToVerticalBlocks(const std::string& json, std::vector<VerticalBlock>& blocks) {
    blocks.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"type\":", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;

        std::string blockJson = json.substr(pos, end - pos + 1);
        VerticalBlock block;
        block.type = (int)ExtractJsonFloat(blockJson, "type", 0);
        std::string text = ExtractJsonString(blockJson, "text");
        strncpy(block.text, text.c_str(), sizeof(block.text) - 1);
        block.imagePath = ExtractJsonString(blockJson, "imagePath");
        block.displayWidth = ExtractJsonFloat(blockJson, "displayWidth", 150);
        block.posX = ExtractJsonFloat(blockJson, "posX", 400);
        block.posY = ExtractJsonFloat(blockJson, "posY", 50);

        // Load image if path exists and type is image
        if (block.type == 2 && !block.imagePath.empty()) {
            int w, h, n;
            unsigned char* data = stbi_load(block.imagePath.c_str(), &w, &h, &n, 4);
            if (data) {
                glGenTextures(1, &block.textureID);
                glBindTexture(GL_TEXTURE_2D, block.textureID);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                stbi_image_free(data);
                block.imageWidth = w;
                block.imageHeight = h;
            }
        }
        blocks.push_back(block);
        pos = end + 1;
    }
}

void JsonToNavbarItems(const std::string& json, std::vector<NavbarMenuItem>& items) {
    items.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"label\":", pos)) != std::string::npos) {
        // Find the end of this item object (look for },{ or }])
        size_t end = json.find("}", pos);
        // Look ahead to find the full object including children array
        size_t childrenEnd = json.find("]}", pos);
        if (childrenEnd != std::string::npos && childrenEnd < json.length()) {
            end = childrenEnd + 1;
        }
        if (end == std::string::npos) break;

        std::string itemJson = json.substr(pos, end - pos + 1);
        NavbarMenuItem item;

        // Extract label
        std::string label = ExtractJsonString(itemJson, "label");
        strncpy(item.label, label.c_str(), sizeof(item.label) - 1);

        // Extract children array
        size_t childStart = itemJson.find("\"children\":[");
        if (childStart != std::string::npos) {
            childStart += 12; // Length of "\"children\":["
            size_t childEnd = itemJson.find("]", childStart);
            if (childEnd != std::string::npos) {
                std::string childrenStr = itemJson.substr(childStart, childEnd - childStart);
                // Parse children strings
                size_t childPos = 0;
                while ((childPos = childrenStr.find("\"", childPos)) != std::string::npos) {
                    childPos++; // Skip opening quote
                    size_t childEndQuote = childrenStr.find("\"", childPos);
                    if (childEndQuote == std::string::npos) break;
                    std::string childText = childrenStr.substr(childPos, childEndQuote - childPos);
                    if (!childText.empty()) {
                        item.children.push_back(childText);
                    }
                    childPos = childEndQuote + 1;
                }
            }
        }

        items.push_back(item);
        pos = end + 1;
    }
}

// Parse CopyrightLinks from JSON
void JsonToCopyrightLinks(const std::string& json, std::vector<CopyrightLink>& links) {
    links.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"text\":", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;

        std::string linkJson = json.substr(pos, end - pos + 1);
        CopyrightLink link;
        std::string text = ExtractJsonString(linkJson, "text");
        strncpy(link.text, text.c_str(), sizeof(link.text) - 1);
        std::string url = ExtractJsonString(linkJson, "url");
        strncpy(link.url, url.c_str(), sizeof(link.url) - 1);
        link.isBold = ExtractJsonBool(linkJson, "isBold", false);
        link.actionType = (int)ExtractJsonFloat(linkJson, "actionType", 0);

        links.push_back(link);
        pos = end + 1;
    }
}

// Parse ArticleCards from JSON
void JsonToArticleCards(const std::string& json, std::vector<ArticleCard>& cards) {
    cards.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"heading\":", pos)) != std::string::npos) {
        size_t end = pos + 1;
        int braceCount = 1;
        while (braceCount > 0 && end < json.length()) {
            if (json[end] == '{') braceCount++;
            else if (json[end] == '}') braceCount--;
            end++;
        }

        std::string cardJson = json.substr(pos, end - pos);
        ArticleCard card;
        std::string heading = ExtractJsonString(cardJson, "heading");
        strncpy(card.heading, heading.c_str(), sizeof(card.heading) - 1);
        std::string date = ExtractJsonString(cardJson, "date");
        strncpy(card.date, date.c_str(), sizeof(card.date) - 1);
        std::string desc = ExtractJsonString(cardJson, "description");
        strncpy(card.description, desc.c_str(), sizeof(card.description) - 1);
        std::string readMore = ExtractJsonString(cardJson, "readMoreText");
        strncpy(card.readMoreText, readMore.c_str(), sizeof(card.readMoreText) - 1);

        card.headingColor = ExtractJsonColor(cardJson, "headingColor");
        card.dateColor = ExtractJsonColor(cardJson, "dateColor");
        card.descriptionColor = ExtractJsonColor(cardJson, "descriptionColor");
        card.readMoreColor = ExtractJsonColor(cardJson, "readMoreColor");
        card.cardBgColor = ExtractJsonColor(cardJson, "cardBgColor");
        card.accentColor = ExtractJsonColor(cardJson, "accentColor");

        card.headingSize = ExtractJsonFloat(cardJson, "headingSize", 1.0f);
        card.dateSize = ExtractJsonFloat(cardJson, "dateSize", 0.8f);
        card.descriptionSize = ExtractJsonFloat(cardJson, "descriptionSize", 0.85f);
        card.readMoreSize = ExtractJsonFloat(cardJson, "readMoreSize", 0.8f);
        card.cardWidth = ExtractJsonFloat(cardJson, "cardWidth", 500);
        card.cardHeight = ExtractJsonFloat(cardJson, "cardHeight", 180);
        card.accentWidth = ExtractJsonFloat(cardJson, "accentWidth", 4);
        card.cardPadding = ExtractJsonFloat(cardJson, "cardPadding", 20);

        card.headingActionType = (int)ExtractJsonFloat(cardJson, "headingActionType", 0);
        std::string headingTarget = ExtractJsonString(cardJson, "headingActionTarget");
        strncpy(card.headingActionTarget, headingTarget.c_str(), sizeof(card.headingActionTarget) - 1);
        card.readMoreActionType = (int)ExtractJsonFloat(cardJson, "readMoreActionType", 0);
        std::string readMoreTarget = ExtractJsonString(cardJson, "readMoreActionTarget");
        strncpy(card.readMoreActionTarget, readMoreTarget.c_str(), sizeof(card.readMoreActionTarget) - 1);

        cards.push_back(card);
        pos = end;
    }
}

// Parse ContactFormFields from JSON
void JsonToContactFormFields(const std::string& json, std::vector<ContactFormField>& fields) {
    fields.clear();
    if (json.empty() || json == "[]") return;

    size_t pos = 0;
    while ((pos = json.find("{\"label\":", pos)) != std::string::npos) {
        size_t end = json.find("}", pos);
        if (end == std::string::npos) break;

        std::string fieldJson = json.substr(pos, end - pos + 1);
        ContactFormField field;
        std::string label = ExtractJsonString(fieldJson, "label");
        strncpy(field.label, label.c_str(), sizeof(field.label) - 1);
        std::string placeholder = ExtractJsonString(fieldJson, "placeholder");
        strncpy(field.placeholder, placeholder.c_str(), sizeof(field.placeholder) - 1);
        field.fieldType = (int)ExtractJsonFloat(fieldJson, "fieldType", 0);
        field.width = ExtractJsonFloat(fieldJson, "width", 0.5f);
        field.required = ExtractJsonBool(fieldJson, "required", false);

        fields.push_back(field);
        pos = end + 1;
    }
}

// Save current website as a template
bool SaveTemplate(const std::string& name, const std::string& description) {
    // If using database, save to PostgreSQL
    if (g_UseDatabase && g_DBConnection) {
        // Insert or update template (PostgreSQL uses ON CONFLICT instead of ON DUPLICATE KEY)
        std::string query = "INSERT INTO templates (template_name, description, project_name, free_design_mode) VALUES ('" +
            SQLEscape(name) + "', '" + SQLEscape(description) + "', '" + SQLEscape(g_ProjectName) + "', " +
            (g_FreeDesignMode ? "TRUE" : "FALSE") + ") " +
            "ON CONFLICT (template_name) DO UPDATE SET description='" + SQLEscape(description) + "', " +
            "project_name='" + SQLEscape(g_ProjectName) + "', free_design_mode=" + (g_FreeDesignMode ? "TRUE" : "FALSE") + ", updated_date=NOW()";

        PGresult* result = PQexec(g_DBConnection, query.c_str());
        if (PQresultStatus(result) != PGRES_COMMAND_OK) {
            printf("Error inserting template: %s\n", PQerrorMessage(g_DBConnection));
            PQclear(result);
            return false;
        }
        PQclear(result);

        // Get template ID
        query = "SELECT id FROM templates WHERE template_name='" + SQLEscape(name) + "'";
        result = PQexec(g_DBConnection, query.c_str());
        if (PQresultStatus(result) != PGRES_TUPLES_OK) {
            printf("Error getting template ID: %s\n", PQerrorMessage(g_DBConnection));
            PQclear(result);
            return false;
        }

        int template_id = 0;
        if (PQntuples(result) > 0) {
            template_id = atoi(PQgetvalue(result, 0, 0));
        }
        PQclear(result);

        if (template_id == 0) return false;

        // Delete old sections for this template
        query = "DELETE FROM sections WHERE template_id=" + std::to_string(template_id);
        result = PQexec(g_DBConnection, query.c_str());
        PQclear(result);

        // Sync current g_Sections back to g_NormalPages before saving
        if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
            g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
        }

        // Save ALL pages from g_NormalPages
        int globalSectionOrder = 0;
        for (size_t pageIdx = 0; pageIdx < g_NormalPages.size(); pageIdx++) {
            const auto& currentPage = g_NormalPages[pageIdx];
            printf("[SaveTemplate] Saving page %zu: %s (%zu sections)\n", pageIdx, currentPage.name.c_str(), currentPage.sections.size());

        for (size_t i = 0; i < currentPage.sections.size(); i++) {
            const auto& sec = currentPage.sections[i];

            // Read image files as binary data
            std::vector<unsigned char> bg_image_data;
            std::vector<unsigned char> sec_image_data;

            if (!sec.background_image.empty()) {
                printf("Section '%s' has background_image path: '%s'\n", sec.name.c_str(), sec.background_image.c_str());
                bg_image_data = ReadImageFile(sec.background_image);
                if (!bg_image_data.empty()) {
                    printf("  -> Successfully read background image: %zu bytes\n", bg_image_data.size());
                } else {
                    printf("  -> Failed to read background image file!\n");
                }
            }

            if (!sec.section_image.empty()) {
                printf("Section '%s' has section_image path: '%s'\n", sec.name.c_str(), sec.section_image.c_str());
                sec_image_data = ReadImageFile(sec.section_image);
                if (!sec_image_data.empty()) {
                    printf("  -> Successfully read section image: %zu bytes\n", sec_image_data.size());
                } else {
                    printf("  -> Failed to read section image file!\n");
                }
            }

            std::ostringstream oss;
            oss << "INSERT INTO sections ("
                << "template_id, section_order, type, name, section_id, height, y_position, x_position, width, z_index, "
                << "title, subtitle, content, button_text, button_link, "
                << "title_font_size, title_font_weight, subtitle_font_size, subtitle_font_weight, "
                << "content_font_size, content_font_weight, button_font_size, button_font_weight, "
                << "nav_font_size, nav_font_weight, "
                << "title_color, subtitle_color, content_color, bg_color, text_color, "
                << "accent_color, button_bg_color, button_text_color, "
                << "nav_bg_color, nav_text_color, "
                << "padding, text_align, card_width, card_height, card_spacing, card_padding, cards_per_row, heading_to_cards_spacing, "
                << "background_image, background_image_data, section_image, section_image_data, "
                << "use_bg_image, bg_overlay_opacity, "
                << "section_width_percent, horizontal_align, use_manual_position, "
                << "hero_animation_images, hero_animation_images_data, enable_hero_animation, hero_animation_speed, "
                << "gallery_images, gallery_images_data, gallery_columns, gallery_spacing, "
                << "logo_path, logo_data, logo_size, brand_text_position, "
                << "animation_type, animation_duration, animation_delay, card_stagger_delay, "
                // CONNECTOR COLUMNS
                << "text_blocks_json, text_content_width, text_padding, "
                << "bar_items_json, "
                << "footer_columns_json, footer_heading_color, footer_subheading_color, "
                << "footer_heading_size, footer_subheading_size, footer_heading_boldness, footer_subheading_boldness, "
                << "footer_column_width, footer_item_spacing, "
                << "connector_cards_json, connector_cards_per_row, connector_card_spacing, "
                << "vertical_blocks_json, vertical_heading_color, vertical_desc_color, "
                << "vertical_heading_size, vertical_desc_size, vertical_heading_boldness, vertical_desc_boldness, "
                << "vertical_content_width, vertical_spacing, "
                // NAVBAR CONNECTOR COLUMNS
                << "navbar_items_json, navbar_bg_color, navbar_hover_color, navbar_dropdown_color, navbar_text_color, "
                << "navbar_height, navbar_padding_x, navbar_padding_y, navbar_spacing, navbar_rounding, "
                << "navbar_font_scale, navbar_rounded, "
                // COPYRIGHT BAR CONNECTOR COLUMNS
                << "copyright_text, copyright_subtext, copyright_links_json, "
                << "copyright_bg_color, copyright_text_color, copyright_link_color, "
                << "copyright_font_size, copyright_subtext_size, copyright_padding, copyright_bg_opacity, "
                // ARTICLE CARDS CONNECTOR COLUMNS
                << "article_cards_json, article_cards_per_row, article_card_spacing, "
                // CONTACT FORM CONNECTOR COLUMNS
                << "contact_form_fields_json, contact_form_title, contact_form_submit_text, "
                << "contact_form_title_color, contact_form_input_bg, contact_form_input_text, "
                << "contact_form_button_bg, contact_form_button_text, contact_form_button_border, "
                << "contact_form_title_size, contact_form_input_height, contact_form_textarea_height, "
                << "contact_form_button_width, contact_form_button_height, contact_form_spacing, "
                << "contact_form_submit_action, contact_form_submit_target, "
                // SEARCH BAR CONNECTOR COLUMNS
                << "search_placeholder, search_button_text, search_input_bg, search_input_border, "
                << "search_input_text, search_button_bg, search_button_text_color, "
                << "search_input_width, search_input_height, search_button_width, search_border_radius, "
                // MARGIN COLUMNS
                << "margin_top, margin_right, margin_bottom, margin_left, "
                // ICON COLUMNS
                << "icon_type, icon_size, icon_color, icon_stroke_width, "
                // SERVICE CARD COLUMNS
                << "service_cards_json, service_cards_per_row, service_card_spacing, "
                // GLASS BAR COLUMNS
                << "glass_bar_text, glass_bar_highlight, glass_bar_text_color, glass_bar_highlight_color, "
                << "glass_bar_bg_color, glass_bar_opacity, glass_bar_border_radius, glass_bar_padding, "
                // HERO SECTION COLUMNS
                << "hero_badge_text, hero_badge_icon_left, hero_badge_icon_right, "
                << "hero_heading, hero_heading_accent, hero_description, "
                << "hero_btn_primary_text, hero_btn_secondary_text, "
                << "hero_btn_primary_action, hero_btn_primary_target, "
                << "hero_btn_secondary_action, hero_btn_secondary_target, "
                << "hero_feature_badges_json, hero_stats_json, "
                << "hero_bg_color, hero_badge_bg, hero_badge_text_color, hero_badge_icon_color, "
                << "hero_heading_color, hero_accent_color, hero_description_color, "
                << "hero_btn_primary_bg, hero_btn_primary_text_color, "
                << "hero_btn_secondary_bg, hero_btn_secondary_text_color, hero_btn_secondary_border, "
                << "hero_btn_border_radius, hero_badge_border_radius, "
                // PAGE COLUMNS
                << "page_index, page_name"
                << ") VALUES ("
                << template_id << ", " << globalSectionOrder++ << ", " << (int)sec.type << ", "
                << "'" << SQLEscape(sec.name) << "', "
                << "'" << SQLEscape(sec.section_id) << "', "
                << sec.height << ", " << sec.y_position << ", " << sec.x_position << ", " << sec.width << ", " << sec.z_index << ", "
                << "'" << SQLEscape(sec.title) << "', "
                << "'" << SQLEscape(sec.subtitle) << "', "
                << "'" << SQLEscape(sec.content) << "', "
                << "'" << SQLEscape(sec.button_text) << "', "
                << "'" << SQLEscape(sec.button_link) << "', "
                << sec.title_font_size << ", " << sec.title_font_weight << ", "
                << sec.subtitle_font_size << ", " << sec.subtitle_font_weight << ", "
                << sec.content_font_size << ", " << sec.content_font_weight << ", "
                << sec.button_font_size << ", " << sec.button_font_weight << ", "
                << sec.nav_font_size << ", " << sec.nav_font_weight << ", "
                << "'" << ColorToSQL(sec.title_color) << "', "
                << "'" << ColorToSQL(sec.subtitle_color) << "', "
                << "'" << ColorToSQL(sec.content_color) << "', "
                << "'" << ColorToSQL(sec.bg_color) << "', "
                << "'" << ColorToSQL(sec.text_color) << "', "
                << "'" << ColorToSQL(sec.accent_color) << "', "
                << "'" << ColorToSQL(sec.button_bg_color) << "', "
                << "'" << ColorToSQL(sec.button_text_color) << "', "
                << "'" << ColorToSQL(sec.nav_bg_color) << "', "
                << "'" << ColorToSQL(sec.nav_text_color) << "', "
                << sec.padding << ", " << sec.text_align << ", "
                << sec.card_width << ", " << sec.card_height << ", "
                << sec.card_spacing << ", " << sec.card_padding << ", " << sec.cards_per_row << ", " << sec.heading_to_cards_spacing << ", "
                << "'" << SQLEscape(sec.background_image) << "', "
                << (bg_image_data.empty() ? "NULL" : BinaryToHex(bg_image_data)) << ", "
                << "'" << SQLEscape(sec.section_image) << "', "
                << (sec_image_data.empty() ? "NULL" : BinaryToHex(sec_image_data)) << ", "
                << (sec.use_bg_image ? "TRUE" : "FALSE") << ", "
                << sec.bg_overlay_opacity << ", "
                << sec.section_width_percent << ", " << sec.horizontal_align << ", " << (sec.use_manual_position ? "TRUE" : "FALSE") << ", "
                << StringVectorToArray(sec.hero_animation_images) << ", "
                << ImageVectorToByteaArray(sec.hero_animation_images) << ", "
                << (sec.enable_hero_animation ? "TRUE" : "FALSE") << ", "
                << sec.hero_animation_speed << ", "
                << StringVectorToArray(sec.gallery_images) << ", "
                << ImageVectorToByteaArray(sec.gallery_images) << ", "
                << sec.gallery_columns << ", "
                << sec.gallery_spacing << ", "
                << "'" << SQLEscape(sec.logo_path) << "', "
                << (sec.logo_path.empty() ? "NULL" : BinaryToHex(ReadImageFile(sec.logo_path))) << ", "
                << sec.logo_size << ", "
                << sec.brand_text_position << ", "
                << (int)sec.animation_type << ", "
                << sec.animation_duration << ", "
                << sec.animation_delay << ", "
                << sec.card_stagger_delay << ", "
                // CONNECTOR VALUES
                << "'" << SQLEscape(TextBlocksToJson(sec.text_blocks)) << "', "
                << sec.text_content_width << ", " << sec.text_padding << ", "
                << "'" << SQLEscape(BarItemsToJson(sec.bar_items)) << "', "
                << "'" << SQLEscape(FooterColumnsToJson(sec.footer_columns)) << "', "
                << "'" << ColorToSQL(sec.footer_heading_color) << "', "
                << "'" << ColorToSQL(sec.footer_subheading_color) << "', "
                << sec.footer_heading_size << ", " << sec.footer_subheading_size << ", "
                << sec.footer_heading_boldness << ", " << sec.footer_subheading_boldness << ", "
                << sec.footer_column_width << ", " << sec.footer_item_spacing << ", "
                << "'" << SQLEscape(ConnectorCardsToJson(sec.connector_cards)) << "', "
                << sec.connector_cards_per_row << ", " << sec.connector_card_spacing << ", "
                << "'" << SQLEscape(VerticalBlocksToJson(sec.vertical_blocks)) << "', "
                << "'" << ColorToSQL(sec.vertical_heading_color) << "', "
                << "'" << ColorToSQL(sec.vertical_desc_color) << "', "
                << sec.vertical_heading_size << ", " << sec.vertical_desc_size << ", "
                << sec.vertical_heading_boldness << ", " << sec.vertical_desc_boldness << ", "
                << sec.vertical_content_width << ", " << sec.vertical_spacing << ", "
                // NAVBAR CONNECTOR VALUES
                << "'" << SQLEscape(NavbarItemsToJson(sec.navbar_items)) << "', "
                << "'" << ColorToSQL(sec.navbar_bg_color) << "', "
                << "'" << ColorToSQL(sec.navbar_hover_color) << "', "
                << "'" << ColorToSQL(sec.navbar_dropdown_color) << "', "
                << "'" << ColorToSQL(sec.navbar_text_color) << "', "
                << sec.navbar_height << ", " << sec.navbar_padding_x << ", "
                << sec.navbar_padding_y << ", " << sec.navbar_spacing << ", "
                << sec.navbar_rounding << ", " << sec.navbar_font_scale << ", "
                << (sec.navbar_rounded ? "TRUE" : "FALSE") << ", "
                // COPYRIGHT BAR CONNECTOR VALUES
                << "'" << SQLEscape(sec.copyright_text) << "', "
                << "'" << SQLEscape(sec.copyright_subtext) << "', "
                << "'" << SQLEscape(CopyrightLinksToJson(sec.copyright_links)) << "', "
                << "'" << ColorToSQL(sec.copyright_bg_color) << "', "
                << "'" << ColorToSQL(sec.copyright_text_color) << "', "
                << "'" << ColorToSQL(sec.copyright_link_color) << "', "
                << sec.copyright_font_size << ", " << sec.copyright_subtext_size << ", "
                << sec.copyright_padding << ", " << sec.copyright_bg_opacity << ", "
                // ARTICLE CARDS CONNECTOR VALUES
                << "'" << SQLEscape(ArticleCardsToJson(sec.article_cards)) << "', "
                << sec.article_cards_per_row << ", " << sec.article_card_spacing << ", "
                // CONTACT FORM CONNECTOR VALUES
                << "'" << SQLEscape(ContactFormFieldsToJson(sec.contact_form_fields)) << "', "
                << "'" << SQLEscape(sec.contact_form_title) << "', "
                << "'" << SQLEscape(sec.contact_form_submit_text) << "', "
                << "'" << ColorToSQL(sec.contact_form_title_color) << "', "
                << "'" << ColorToSQL(sec.contact_form_input_bg) << "', "
                << "'" << ColorToSQL(sec.contact_form_input_text) << "', "
                << "'" << ColorToSQL(sec.contact_form_button_bg) << "', "
                << "'" << ColorToSQL(sec.contact_form_button_text) << "', "
                << "'" << ColorToSQL(sec.contact_form_button_border) << "', "
                << sec.contact_form_title_size << ", " << sec.contact_form_input_height << ", "
                << sec.contact_form_textarea_height << ", " << sec.contact_form_button_width << ", "
                << sec.contact_form_button_height << ", " << sec.contact_form_spacing << ", "
                << sec.contact_form_submit_action << ", "
                << "'" << SQLEscape(sec.contact_form_submit_target) << "', "
                // SEARCH BAR CONNECTOR VALUES
                << "'" << SQLEscape(sec.search_placeholder) << "', "
                << "'" << SQLEscape(sec.search_button_text) << "', "
                << "'" << ColorToSQL(sec.search_input_bg) << "', "
                << "'" << ColorToSQL(sec.search_input_border) << "', "
                << "'" << ColorToSQL(sec.search_input_text) << "', "
                << "'" << ColorToSQL(sec.search_button_bg) << "', "
                << "'" << ColorToSQL(sec.search_button_text_color) << "', "
                << sec.search_input_width << ", " << sec.search_input_height << ", "
                << sec.search_button_width << ", " << sec.search_border_radius << ", "
                // MARGIN VALUES
                << sec.margin_top << ", " << sec.margin_right << ", " << sec.margin_bottom << ", " << sec.margin_left << ", "
                // ICON VALUES
                << sec.icon_type << ", " << sec.icon_size << ", "
                << "'" << ColorToSQL(sec.icon_color) << "', " << sec.icon_stroke_width << ", "
                // SERVICE CARD VALUES
                << "'" << SQLEscape(ServiceCardsToJson(sec.service_cards)) << "', "
                << sec.service_cards_per_row << ", " << sec.service_card_spacing << ", "
                // GLASS BAR VALUES
                << "'" << SQLEscape(sec.glass_bar_text) << "', "
                << "'" << SQLEscape(sec.glass_bar_highlight) << "', "
                << "'" << ColorToSQL(sec.glass_bar_text_color) << "', "
                << "'" << ColorToSQL(sec.glass_bar_highlight_color) << "', "
                << "'" << ColorToSQL(sec.glass_bar_bg_color) << "', "
                << sec.glass_bar_opacity << ", " << sec.glass_bar_border_radius << ", " << sec.glass_bar_padding << ", "
                // HERO SECTION VALUES
                << "'" << SQLEscape(sec.hero_badge_text) << "', "
                << sec.hero_badge_icon_left << ", " << sec.hero_badge_icon_right << ", "
                << "'" << SQLEscape(sec.hero_heading) << "', "
                << "'" << SQLEscape(sec.hero_heading_accent) << "', "
                << "'" << SQLEscape(sec.hero_description) << "', "
                << "'" << SQLEscape(sec.hero_btn_primary_text) << "', "
                << "'" << SQLEscape(sec.hero_btn_secondary_text) << "', "
                << sec.hero_btn_primary_action << ", "
                << "'" << SQLEscape(sec.hero_btn_primary_target) << "', "
                << sec.hero_btn_secondary_action << ", "
                << "'" << SQLEscape(sec.hero_btn_secondary_target) << "', "
                << "'" << SQLEscape(HeroFeatureBadgesToJson(sec.hero_feature_badges)) << "', "
                << "'" << SQLEscape(HeroStatsToJson(sec.hero_stats)) << "', "
                << "'" << ColorToSQL(sec.hero_bg_color) << "', "
                << "'" << ColorToSQL(sec.hero_badge_bg) << "', "
                << "'" << ColorToSQL(sec.hero_badge_text_color) << "', "
                << "'" << ColorToSQL(sec.hero_badge_icon_color) << "', "
                << "'" << ColorToSQL(sec.hero_heading_color) << "', "
                << "'" << ColorToSQL(sec.hero_accent_color) << "', "
                << "'" << ColorToSQL(sec.hero_description_color) << "', "
                << "'" << ColorToSQL(sec.hero_btn_primary_bg) << "', "
                << "'" << ColorToSQL(sec.hero_btn_primary_text_color) << "', "
                << "'" << ColorToSQL(sec.hero_btn_secondary_bg) << "', "
                << "'" << ColorToSQL(sec.hero_btn_secondary_text_color) << "', "
                << "'" << ColorToSQL(sec.hero_btn_secondary_border) << "', "
                << sec.hero_btn_border_radius << ", " << sec.hero_badge_border_radius << ", "
                // PAGE COLUMNS
                << pageIdx << ", '" << SQLEscape(currentPage.name) << "'"
                << ")";

            PGresult* sec_result = PQexec(g_DBConnection, oss.str().c_str());
            if (PQresultStatus(sec_result) != PGRES_COMMAND_OK) {
                printf("Error inserting section: %s\n", PQerrorMessage(g_DBConnection));
                PQclear(sec_result);
                return false;
            }
            PQclear(sec_result);
        }
        } // End page loop

        printf("Template saved to database: %s (%zu pages)\n", name.c_str(), g_NormalPages.size());
        return true;
    }

    // Otherwise, save to JSON file
    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    std::string filename = basePath + "templates/" + name + ".json";

    std::ofstream file(filename);
    if (!file.is_open()) return false;

    // Get current date
    time_t now = time(0);
    char dateStr[64];
    strftime(dateStr, sizeof(dateStr), "%Y-%m-%d %H:%M:%S", localtime(&now));

    file << "{\n";
    file << "  \"template_name\": \"" << JsonEscape(name) << "\",\n";
    file << "  \"description\": \"" << JsonEscape(description) << "\",\n";
    file << "  \"created_date\": \"" << dateStr << "\",\n";
    file << "  \"project_name\": \"" << JsonEscape(g_ProjectName) << "\",\n";
    file << "  \"sections\": [\n";

    for (size_t i = 0; i < g_Sections.size(); i++) {
        const auto& sec = g_Sections[i];
        file << "    {\n";
        file << "      \"id\": " << sec.id << ",\n";
        file << "      \"type\": " << (int)sec.type << ",\n";
        file << "      \"name\": \"" << JsonEscape(sec.name) << "\",\n";
        file << "      \"section_id\": \"" << JsonEscape(sec.section_id) << "\",\n";
        file << "      \"height\": " << sec.height << ",\n";
        file << "      \"title\": \"" << JsonEscape(sec.title) << "\",\n";
        file << "      \"subtitle\": \"" << JsonEscape(sec.subtitle) << "\",\n";
        file << "      \"content\": \"" << JsonEscape(sec.content) << "\",\n";
        file << "      \"button_text\": \"" << JsonEscape(sec.button_text) << "\",\n";
        file << "      \"button_link\": \"" << JsonEscape(sec.button_link) << "\",\n";
        file << "      \"title_font_size\": " << sec.title_font_size << ",\n";
        file << "      \"subtitle_font_size\": " << sec.subtitle_font_size << ",\n";
        file << "      \"content_font_size\": " << sec.content_font_size << ",\n";
        file << "      \"title_font_weight\": " << sec.title_font_weight << ",\n";
        file << "      \"subtitle_font_weight\": " << sec.subtitle_font_weight << ",\n";
        file << "      \"content_font_weight\": " << sec.content_font_weight << ",\n";
        file << "      \"title_color\": " << ColorToJson(sec.title_color) << ",\n";
        file << "      \"subtitle_color\": " << ColorToJson(sec.subtitle_color) << ",\n";
        file << "      \"content_color\": " << ColorToJson(sec.content_color) << ",\n";
        file << "      \"bg_color\": " << ColorToJson(sec.bg_color) << ",\n";
        file << "      \"text_color\": " << ColorToJson(sec.text_color) << ",\n";
        file << "      \"accent_color\": " << ColorToJson(sec.accent_color) << ",\n";
        file << "      \"button_bg_color\": " << ColorToJson(sec.button_bg_color) << ",\n";
        file << "      \"button_text_color\": " << ColorToJson(sec.button_text_color) << ",\n";
        file << "      \"button_font_size\": " << sec.button_font_size << ",\n";
        file << "      \"button_font_weight\": " << sec.button_font_weight << ",\n";
        file << "      \"padding\": " << sec.padding << ",\n";
        file << "      \"text_align\": " << sec.text_align << ",\n";
        file << "      \"nav_font_size\": " << sec.nav_font_size << ",\n";
        file << "      \"nav_font_weight\": " << sec.nav_font_weight << ",\n";
        file << "      \"card_width\": " << sec.card_width << ",\n";
        file << "      \"card_height\": " << sec.card_height << ",\n";
        file << "      \"card_spacing\": " << sec.card_spacing << ",\n";
        file << "      \"cards_per_row\": " << sec.cards_per_row << ",\n";
        file << "      \"background_image\": \"" << JsonEscape(sec.background_image) << "\",\n";
        file << "      \"section_image\": \"" << JsonEscape(sec.section_image) << "\",\n";
        file << "      \"use_bg_image\": " << (sec.use_bg_image ? "true" : "false") << ",\n";
        file << "      \"bg_overlay_opacity\": " << sec.bg_overlay_opacity << "\n";
        file << "    }" << (i < g_Sections.size() - 1 ? "," : "") << "\n";
    }

    file << "  ]\n";
    file << "}\n";
    file.close();

    return true;
}

// ============================================================================
// CSS PARSING HELPER FUNCTIONS
// ============================================================================

// Helper function to extract a JSON string value
std::string ExtractJSONValue(const std::string& json, const std::string& key) {
    std::string search = "\"" + key + "\"";
    size_t pos = json.find(search);
    if (pos == std::string::npos) return "";

    // Find the colon after the key
    pos = json.find(':', pos);
    if (pos == std::string::npos) return "";
    pos++;

    // Skip whitespace
    while (pos < json.size() && (json[pos] == ' ' || json[pos] == '\t' || json[pos] == '\n')) pos++;

    // Extract value (handle strings with quotes and values without quotes)
    if (json[pos] == '"') {
        pos++;  // Skip opening quote
        size_t end = json.find('"', pos);
        if (end == std::string::npos) return "";
        return json.substr(pos, end - pos);
    } else {
        // Number or keyword (true/false/null)
        size_t end = pos;
        while (end < json.size() && json[end] != ',' && json[end] != '}' && json[end] != '\n') end++;
        std::string value = json.substr(pos, end - pos);
        // Trim whitespace
        size_t trimEnd = value.find_last_not_of(" \t\n\r");
        if (trimEnd != std::string::npos) value = value.substr(0, trimEnd + 1);
        return value;
    }
}

// ============================================================================
// CSS VALUE PARSING UTILITIES
// ============================================================================

// Parse CSS line-height value (e.g., "normal", "1.6", "24px") and return as float multiplier
float ParseLineHeight(const std::string& value, float fontSize) {
    if (value.empty() || value == "normal") return 1.2f;  // Default line-height

    // If it's a number without units (e.g., "1.6"), use it as multiplier
    if (value.find("px") == std::string::npos && value.find("%") == std::string::npos) {
        float multiplier = (float)atof(value.c_str());
        return (multiplier > 0.5f && multiplier < 5.0f) ? multiplier : 1.2f;
    }

    // If it has "px", convert to multiplier based on fontSize
    if (value.find("px") != std::string::npos) {
        float pixels = (float)atof(value.c_str());
        return pixels / fontSize;
    }

    return 1.2f;  // Default
}

// Parse CSS letter-spacing value (e.g., "normal", "0.5px", "0.05em") and return pixels
float ParseLetterSpacing(const std::string& value, float fontSize) {
    if (value.empty() || value == "normal") return 0.0f;

    // If it has "px"
    if (value.find("px") != std::string::npos) {
        return (float)atof(value.c_str());
    }

    // If it has "em"
    if (value.find("em") != std::string::npos) {
        float em = (float)atof(value.c_str());
        return em * fontSize;
    }

    return 0.0f;
}

// Parse background-position (e.g., "center center", "50% 50%", "left top")
void ParseBackgroundPosition(const std::string& value, float& xPercent, float& yPercent) {
    // Default to center
    xPercent = 0.5f;
    yPercent = 0.5f;

    if (value.empty() || value == "0% 0%") {
        xPercent = 0.0f;
        yPercent = 0.0f;
        return;
    }

    // Parse "center", "left", "right", "top", "bottom", or percentages
    if (value.find("center") != std::string::npos) {
        xPercent = 0.5f;
        yPercent = 0.5f;
    } else if (value.find("left") != std::string::npos) {
        xPercent = 0.0f;
    } else if (value.find("right") != std::string::npos) {
        xPercent = 1.0f;
    }

    if (value.find("top") != std::string::npos) {
        yPercent = 0.0f;
    } else if (value.find("bottom") != std::string::npos) {
        yPercent = 1.0f;
    }

    // Try to parse percentages (e.g., "50% 75%")
    size_t firstPercent = value.find('%');
    if (firstPercent != std::string::npos) {
        // Find start of number
        size_t start = 0;
        while (start < firstPercent && !isdigit(value[start]) && value[start] != '-') start++;
        if (start < firstPercent) {
            xPercent = (float)atof(value.substr(start).c_str()) / 100.0f;
        }

        // Find second percentage
        size_t secondPercent = value.find('%', firstPercent + 1);
        if (secondPercent != std::string::npos) {
            start = firstPercent + 1;
            while (start < secondPercent && !isdigit(value[start]) && value[start] != '-') start++;
            if (start < secondPercent) {
                yPercent = (float)atof(value.substr(start).c_str()) / 100.0f;
            }
        }
    }
}

// Parse CSS gradient string and extract colors
// Supports: linear-gradient(to right, #667eea 0%, #764ba2 100%)
bool ParseGradient(const std::string& gradientStr, std::vector<ImVec4>& colors, bool& isRadial, float& angle) {
    if (gradientStr.empty() || gradientStr == "none") return false;

    // Detect gradient type
    isRadial = (gradientStr.find("radial") != std::string::npos);
    angle = 0.0f; // Default: top to bottom (0 degrees)

    // Parse direction for linear gradients
    if (!isRadial) {
        if (gradientStr.find("to right") != std::string::npos) angle = 90.0f;
        else if (gradientStr.find("to left") != std::string::npos) angle = 270.0f;
        else if (gradientStr.find("to bottom") != std::string::npos) angle = 180.0f;
        else if (gradientStr.find("to top") != std::string::npos) angle = 0.0f;
        else if (gradientStr.find("to bottom right") != std::string::npos) angle = 135.0f;
        else if (gradientStr.find("to bottom left") != std::string::npos) angle = 225.0f;

        // Parse degree angle (e.g., "45deg")
        size_t degPos = gradientStr.find("deg");
        if (degPos != std::string::npos) {
            size_t start = degPos;
            while (start > 0 && (isdigit(gradientStr[start-1]) || gradientStr[start-1] == '.')) start--;
            if (start < degPos) {
                angle = (float)atof(gradientStr.substr(start, degPos - start).c_str());
            }
        }
    }

    // Extract colors (look for rgb/rgba/hex patterns)
    colors.clear();

    // Find all rgb/rgba color values
    size_t pos = 0;
    while ((pos = gradientStr.find("rgb", pos)) != std::string::npos) {
        size_t start = pos;
        size_t end = gradientStr.find(')', start);
        if (end == std::string::npos) break;

        std::string colorStr = gradientStr.substr(start, end - start + 1);
        ImVec4 color = SQLToColor(colorStr);
        colors.push_back(color);

        pos = end + 1;
    }

    // Parse hex colors (#667eea)
    pos = 0;
    while ((pos = gradientStr.find('#', pos)) != std::string::npos) {
        if (pos + 7 <= gradientStr.size()) {
            std::string hexStr = gradientStr.substr(pos, 7); // #RRGGBB

            // Simple hex parser
            if (hexStr.length() == 7) {
                int r, g, b;
                if (sscanf(hexStr.c_str(), "#%02x%02x%02x", &r, &g, &b) == 3) {
                    ImVec4 color(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f);
                    colors.push_back(color);
                }
            }
        }
        pos++;
    }

    return !colors.empty();
}

// Calculate UV coordinates for background-size: cover
// This scales the image to fill the area while maintaining aspect ratio (cropping overflow)
void CalculateCoverUV(float containerW, float containerH, float imageW, float imageH,
                      float posX, float posY, ImVec2& uv0, ImVec2& uv1) {
    if (imageW <= 0 || imageH <= 0 || containerW <= 0 || containerH <= 0) {
        uv0 = ImVec2(0, 0);
        uv1 = ImVec2(1, 1);
        return;
    }

    float containerAspect = containerW / containerH;
    float imageAspect = imageW / imageH;

    float scaleX, scaleY;

    if (containerAspect > imageAspect) {
        // Container is wider than image - scale to width
        scaleX = 1.0f;
        scaleY = imageAspect / containerAspect;
    } else {
        // Container is taller than image - scale to height
        scaleX = containerAspect / imageAspect;
        scaleY = 1.0f;
    }

    // Apply background-position to center the visible part
    float offsetX = (1.0f - scaleX) * posX;
    float offsetY = (1.0f - scaleY) * posY;

    uv0 = ImVec2(offsetX, offsetY);
    uv1 = ImVec2(offsetX + scaleX, offsetY + scaleY);
}

// ============================================================================
// CSS PARSING FUNCTIONS
// ============================================================================

// Parse CSS JSON data and populate WebSection CSS properties
void ParseCSSData(WebSection& sec, const std::string& css_json) {
    if (css_json.empty() || css_json == "null") return;

    // Extract button CSS properties
    sec.button_border_radius = std::max(0.0f, (float)atof(ExtractJSONValue(css_json, "borderRadius").c_str()));
    sec.button_border_width = std::max(0.0f, (float)atof(ExtractJSONValue(css_json, "borderWidth").c_str()));

    std::string borderColor = ExtractJSONValue(css_json, "borderColor");
    if (!borderColor.empty() && borderColor.find("rgb") != std::string::npos) {
        sec.button_border_color = SQLToColor(borderColor);
    }

    sec.button_box_shadow = ExtractJSONValue(css_json, "boxShadow");
    if (sec.button_box_shadow.empty()) sec.button_box_shadow = "none";

    sec.button_padding = ExtractJSONValue(css_json, "padding");
    if (sec.button_padding.empty()) sec.button_padding = "10px 20px";

    // Extract section CSS properties (look for these after "section": marker)
    size_t section_marker = css_json.find("\"section\"");
    if (section_marker != std::string::npos) {
        std::string section_json = css_json.substr(section_marker);

        sec.section_border_radius = std::max(0.0f, (float)atof(ExtractJSONValue(section_json, "borderRadius").c_str()));
        sec.section_box_shadow = ExtractJSONValue(section_json, "boxShadow");
        if (sec.section_box_shadow.empty()) sec.section_box_shadow = "none";

        sec.section_border = ExtractJSONValue(section_json, "border");
        if (sec.section_border.empty()) sec.section_border = "none";

        std::string opacity_str = ExtractJSONValue(section_json, "opacity");
        if (!opacity_str.empty()) {
            sec.section_opacity = std::max(0.0f, std::min(1.0f, (float)atof(opacity_str.c_str())));
        }

        sec.section_line_height = ExtractJSONValue(section_json, "lineHeight");
        if (sec.section_line_height.empty()) sec.section_line_height = "normal";

        sec.section_letter_spacing = ExtractJSONValue(section_json, "letterSpacing");
        if (sec.section_letter_spacing.empty()) sec.section_letter_spacing = "normal";
    }
}

// Parse interactive_data JSON to load card items
void ParseInteractiveData(WebSection& sec, const std::string& json) {
    if (json.empty() || json == "null") return;

    // Look for "cards" array in JSON
    size_t cards_pos = json.find("\"cards\"");
    if (cards_pos == std::string::npos) return;

    // Find the opening bracket of the cards array
    size_t array_start = json.find('[', cards_pos);
    if (array_start == std::string::npos) return;

    // Parse each card item (simple manual parsing)
    size_t pos = array_start + 1;
    int card_count = 0;

    while (pos < json.size() && card_count < 12) {  // Limit to 12 cards
        // Find next card object
        size_t obj_start = json.find('{', pos);
        if (obj_start == std::string::npos) break;

        size_t obj_end = json.find('}', obj_start);
        if (obj_end == std::string::npos) break;

        std::string card_json = json.substr(obj_start, obj_end - obj_start + 1);

        // Create card item
        WebSection::CardItem card;
        card.title = ExtractJSONValue(card_json, "title");
        card.description = ExtractJSONValue(card_json, "description");
        card.link = ExtractJSONValue(card_json, "link");

        // Extract colors
        std::string bgColor = ExtractJSONValue(card_json, "bg_color");
        if (!bgColor.empty() && bgColor.find("rgb") != std::string::npos) {
            card.bg_color = SQLToColor(bgColor);
        } else {
            card.bg_color = ImVec4(1, 1, 1, 1);
        }

        std::string titleColor = ExtractJSONValue(card_json, "text_color");
        if (!titleColor.empty() && titleColor.find("rgb") != std::string::npos) {
            card.title_color = SQLToColor(titleColor);
        } else {
            card.title_color = ImVec4(0, 0, 0, 1);
        }

        card.desc_color = card.title_color;

        // Extract font sizes
        std::string titleSize = ExtractJSONValue(card_json, "title_font_size");
        card.title_font_size = titleSize.empty() ? 16.0f : (float)atof(titleSize.c_str());

        std::string titleWeight = ExtractJSONValue(card_json, "title_font_weight");
        card.title_font_weight = titleWeight.empty() ? 500.0f : (float)atof(titleWeight.c_str());

        card.desc_font_size = 14.0f;
        card.desc_font_weight = 400.0f;

        // Set default dimensions
        card.width = sec.card_width;
        card.height = sec.card_height;

        sec.items.push_back(card);
        card_count++;

        pos = obj_end + 1;

        // Check if there are more cards
        size_t comma = json.find(',', pos);
        if (comma == std::string::npos || comma > json.find(']', pos)) break;
        pos = comma + 1;
    }

    // Parse paragraphs array
    size_t paragraphs_pos = json.find("\"paragraphs\"");
    if (paragraphs_pos != std::string::npos) {
        size_t para_array_start = json.find('[', paragraphs_pos);
        if (para_array_start != std::string::npos) {
            size_t para_pos = para_array_start + 1;
            int para_count = 0;

            while (para_pos < json.size() && para_count < 10) {  // Limit to 10 paragraphs
                size_t obj_start = json.find('{', para_pos);
                if (obj_start == std::string::npos) break;

                size_t obj_end = json.find('}', obj_start);
                if (obj_end == std::string::npos) break;

                std::string para_json = json.substr(obj_start, obj_end - obj_start + 1);

                // Create paragraph
                WebSection::Paragraph para;
                para.text = ExtractJSONValue(para_json, "text");

                std::string fontSize = ExtractJSONValue(para_json, "fontSize");
                para.font_size = fontSize.empty() ? 16.0f : (float)atof(fontSize.c_str());

                std::string fontWeight = ExtractJSONValue(para_json, "fontWeight");
                para.font_weight = fontWeight.empty() ? 400.0f : (float)atof(fontWeight.c_str());

                std::string color = ExtractJSONValue(para_json, "color");
                if (!color.empty() && color.find("rgb") != std::string::npos) {
                    para.color = SQLToColor(color);
                } else {
                    para.color = ImVec4(0, 0, 0, 1);
                }

                para.font_family = ExtractJSONValue(para_json, "fontFamily");

                if (!para.text.empty()) {
                    sec.paragraphs.push_back(para);
                    para_count++;
                }

                para_pos = obj_end + 1;

                // Check if there are more paragraphs
                size_t comma = json.find(',', para_pos);
                if (comma == std::string::npos || comma > json.find(']', para_pos)) break;
                para_pos = comma + 1;
            }
        }
    }

    // Parse nav_items array (for navbar sections)
    size_t nav_items_pos = json.find("\"nav_items\"");
    if (nav_items_pos != std::string::npos) {
        size_t nav_array_start = json.find('[', nav_items_pos);
        if (nav_array_start != std::string::npos) {
            size_t nav_pos = nav_array_start + 1;
            int nav_count = 0;

            while (nav_pos < json.size() && nav_count < 10) {  // Limit to 10 nav items
                size_t obj_start = json.find('{', nav_pos);
                if (obj_start == std::string::npos) break;

                size_t obj_end = json.find('}', obj_start);
                if (obj_end == std::string::npos) break;

                std::string nav_json = json.substr(obj_start, obj_end - obj_start + 1);

                // Create nav item
                WebSection::NavItem nav;
                nav.label = ExtractJSONValue(nav_json, "text");
                nav.link = ExtractJSONValue(nav_json, "href");

                std::string fontSize = ExtractJSONValue(nav_json, "fontSize");
                nav.font_size = fontSize.empty() ? 16.0f : (float)atof(fontSize.c_str());

                std::string fontWeight = ExtractJSONValue(nav_json, "fontWeight");
                nav.font_weight = fontWeight.empty() ? 400.0f : (float)atof(fontWeight.c_str());

                std::string color = ExtractJSONValue(nav_json, "color");
                if (!color.empty() && color.find("rgb") != std::string::npos) {
                    nav.text_color = SQLToColor(color);
                } else {
                    nav.text_color = ImVec4(0, 0, 0, 1);
                }

                if (!nav.label.empty()) {
                    sec.nav_items.push_back(nav);
                    nav_count++;
                }

                nav_pos = obj_end + 1;

                // Check if there are more nav items
                size_t comma = json.find(',', nav_pos);
                if (comma == std::string::npos || comma > json.find(']', nav_pos)) break;
                nav_pos = comma + 1;
            }
        }
    }

    // Parse gallery_images array (for gallery sections)
    size_t gallery_pos = json.find("\"gallery_images\"");
    if (gallery_pos != std::string::npos) {
        size_t gallery_array_start = json.find('[', gallery_pos);
        if (gallery_array_start != std::string::npos) {
            size_t gal_pos = gallery_array_start + 1;
            int gal_count = 0;

            while (gal_pos < json.size() && gal_count < 12) {  // Limit to 12 gallery images
                size_t obj_start = json.find('{', gal_pos);
                if (obj_start == std::string::npos) break;

                size_t obj_end = json.find('}', obj_start);
                if (obj_end == std::string::npos) break;

                std::string gal_json = json.substr(obj_start, obj_end - obj_start + 1);

                // Extract image src
                std::string src = ExtractJSONValue(gal_json, "src");
                if (!src.empty()) {
                    sec.gallery_images.push_back(src);
                    gal_count++;
                }

                gal_pos = obj_end + 1;

                // Check if there are more gallery images
                size_t comma = json.find(',', gal_pos);
                if (comma == std::string::npos || comma > json.find(']', gal_pos)) break;
                gal_pos = comma + 1;
            }
        }
    }

    // Parse hero_animation_images array (for hero sections)
    size_t hero_anim_pos = json.find("\"hero_animation_images\"");
    if (hero_anim_pos != std::string::npos) {
        size_t hero_array_start = json.find('[', hero_anim_pos);
        if (hero_array_start != std::string::npos) {
            size_t hero_pos = hero_array_start + 1;
            int hero_count = 0;

            while (hero_pos < json.size() && hero_count < 5) {  // Limit to 5 hero animation images
                // Find next string value (images are stored as simple strings in array)
                size_t str_start = json.find('"', hero_pos);
                if (str_start == std::string::npos || str_start > json.find(']', hero_pos)) break;

                size_t str_end = json.find('"', str_start + 1);
                if (str_end == std::string::npos) break;

                std::string img_url = json.substr(str_start + 1, str_end - str_start - 1);
                if (!img_url.empty()) {
                    sec.hero_animation_images.push_back(img_url);
                    hero_count++;
                }

                hero_pos = str_end + 1;

                // Check if there are more images
                size_t comma = json.find(',', hero_pos);
                if (comma == std::string::npos || comma > json.find(']', hero_pos)) break;
                hero_pos = comma + 1;
            }

            // Enable hero animation if we have multiple images
            if (sec.hero_animation_images.size() > 1) {
                sec.enable_hero_animation = true;

                // Extract animation speed
                std::string speed = ExtractJSONValue(json, "hero_animation_speed");
                sec.hero_animation_speed = speed.empty() ? 2.0f : (float)atof(speed.c_str());
            }
        }
    }
}

// Parse layout_data JSON to load spacing, flexbox, grid, and positioning properties
void ParseLayoutData(WebSection& sec, const std::string& json) {
    if (json.empty() || json == "null") return;

    // Parse padding (4-sided)
    size_t padding_pos = json.find("\"padding\"");
    if (padding_pos != std::string::npos) {
        std::string top = ExtractJSONValue(json.substr(padding_pos), "top");
        std::string right = ExtractJSONValue(json.substr(padding_pos), "right");
        std::string bottom = ExtractJSONValue(json.substr(padding_pos), "bottom");
        std::string left = ExtractJSONValue(json.substr(padding_pos), "left");

        if (!top.empty()) sec.padding_top = std::max(0.0f, (float)atof(top.c_str()));
        if (!right.empty()) sec.padding_right = std::max(0.0f, (float)atof(right.c_str()));
        if (!bottom.empty()) sec.padding_bottom = std::max(0.0f, (float)atof(bottom.c_str()));
        if (!left.empty()) sec.padding_left = std::max(0.0f, (float)atof(left.c_str()));
    }

    // Parse flexbox properties
    size_t flexbox_pos = json.find("\"flexbox\"");
    if (flexbox_pos != std::string::npos) {
        std::string flexbox_json = json.substr(flexbox_pos);

        sec.display = ExtractJSONValue(flexbox_json, "display");
        if (sec.display.empty()) sec.display = "block";

        sec.flex_direction = ExtractJSONValue(flexbox_json, "flexDirection");
        if (sec.flex_direction.empty()) sec.flex_direction = "row";

        sec.justify_content = ExtractJSONValue(flexbox_json, "justifyContent");
        if (sec.justify_content.empty()) sec.justify_content = "normal";

        sec.align_items = ExtractJSONValue(flexbox_json, "alignItems");
        if (sec.align_items.empty()) sec.align_items = "normal";

        std::string gap_str = ExtractJSONValue(flexbox_json, "gap");
        if (!gap_str.empty()) sec.gap = std::max(0.0f, (float)atof(gap_str.c_str()));
    }

    // Parse grid properties
    size_t grid_pos = json.find("\"grid\"");
    if (grid_pos != std::string::npos) {
        std::string grid_json = json.substr(grid_pos);

        sec.grid_template_columns = ExtractJSONValue(grid_json, "gridTemplateColumns");
        if (sec.grid_template_columns.empty()) sec.grid_template_columns = "none";

        sec.grid_template_rows = ExtractJSONValue(grid_json, "gridTemplateRows");
        if (sec.grid_template_rows.empty()) sec.grid_template_rows = "none";
    }

    // Parse background positioning
    size_t bg_pos = json.find("\"background\"");
    if (bg_pos != std::string::npos) {
        std::string bg_json = json.substr(bg_pos);

        sec.background_position = ExtractJSONValue(bg_json, "backgroundPosition");
        if (sec.background_position.empty()) sec.background_position = "0% 0%";

        sec.background_repeat = ExtractJSONValue(bg_json, "backgroundRepeat");
        if (sec.background_repeat.empty()) sec.background_repeat = "repeat";

        sec.background_size = ExtractJSONValue(bg_json, "backgroundSize");
        if (sec.background_size.empty()) sec.background_size = "auto";

        sec.background_image_css = ExtractJSONValue(bg_json, "backgroundImage");
        if (sec.background_image_css.empty()) sec.background_image_css = "none";

        // Parse gradients from background-image
        if (sec.background_image_css.find("gradient") != std::string::npos) {
            float gradientAngle = 0.0f;
            sec.has_gradient = ParseGradient(sec.background_image_css, sec.gradient_colors,
                                            sec.gradient_is_radial, gradientAngle);
        }
    }

    // Parse position properties (for overlays)
    size_t pos_pos = json.find("\"position\"");
    if (pos_pos != std::string::npos) {
        std::string pos_json = json.substr(pos_pos);

        sec.css_position = ExtractJSONValue(pos_json, "position");
        if (sec.css_position.empty()) sec.css_position = "static";

        sec.css_top = ExtractJSONValue(pos_json, "top");
        if (sec.css_top.empty()) sec.css_top = "auto";

        sec.css_left = ExtractJSONValue(pos_json, "left");
        if (sec.css_left.empty()) sec.css_left = "auto";

        sec.css_right = ExtractJSONValue(pos_json, "right");
        if (sec.css_right.empty()) sec.css_right = "auto";

        sec.css_bottom = ExtractJSONValue(pos_json, "bottom");
        if (sec.css_bottom.empty()) sec.css_bottom = "auto";

        std::string z_str = ExtractJSONValue(pos_json, "zIndex");
        if (!z_str.empty() && z_str != "auto") sec.css_z_index = atoi(z_str.c_str());
    }

    // Parse typography
    size_t typo_pos = json.find("\"typography\"");
    if (typo_pos != std::string::npos) {
        std::string typo_json = json.substr(typo_pos);

        sec.font_family = ExtractJSONValue(typo_json, "fontFamily");
        if (sec.font_family.empty()) sec.font_family = "system-ui";
    }
}

// Load all available templates
void LoadAvailableTemplates() {
    g_AvailableTemplates.clear();

    // If using database, load from PostgreSQL
    if (g_UseDatabase && g_DBConnection) {
        std::string query = "SELECT template_name, description, created_date FROM templates ORDER BY created_date DESC";
        PGresult* result = PQexec(g_DBConnection, query.c_str());
        if (PQresultStatus(result) != PGRES_TUPLES_OK) {
            printf("Error loading templates: %s\n", PQerrorMessage(g_DBConnection));
            PQclear(result);
            return;
        }

        int nrows = PQntuples(result);
        for (int row_num = 0; row_num < nrows; row_num++) {
            TemplateInfo info;
            info.name = PQgetisnull(result, row_num, 0) ? "" : PQgetvalue(result, row_num, 0);
            info.filename = info.name;  // For database mode, filename is just the name
            info.description = PQgetisnull(result, row_num, 1) ? "Template" : PQgetvalue(result, row_num, 1);
            info.created_date = PQgetisnull(result, row_num, 2) ? "" : PQgetvalue(result, row_num, 2);
            g_AvailableTemplates.push_back(info);
        }
        PQclear(result);

        printf("Loaded %zu templates from database\n", g_AvailableTemplates.size());
        return;
    }

    // Otherwise, load from JSON files
    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    std::string cmd = "ls " + basePath + "templates/*.json 2>/dev/null";

    FILE* pipe = popen(cmd.c_str(), "r");
    if (!pipe) return;

    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), pipe)) {
        std::string filepath = buffer;
        if (!filepath.empty() && filepath.back() == '\n') filepath.pop_back();

        // Extract filename
        size_t lastSlash = filepath.find_last_of('/');
        std::string filename = (lastSlash != std::string::npos) ? filepath.substr(lastSlash + 1) : filepath;
        std::string name = filename.substr(0, filename.find_last_of('.'));

        // Read template metadata
        std::ifstream file(filepath);
        if (file.is_open()) {
            TemplateInfo info;
            info.name = name;
            info.filename = filepath;
            info.description = "Template";
            info.created_date = "";

            std::string line;
            while (std::getline(file, line)) {
                if (line.find("\"description\"") != std::string::npos) {
                    size_t start = line.find(":") + 1;
                    size_t first_quote = line.find("\"", start);
                    size_t last_quote = line.find_last_of("\"");
                    if (first_quote != std::string::npos && last_quote != std::string::npos && first_quote < last_quote) {
                        info.description = line.substr(first_quote + 1, last_quote - first_quote - 1);
                    }
                }
                if (line.find("\"created_date\"") != std::string::npos) {
                    size_t start = line.find(":") + 1;
                    size_t first_quote = line.find("\"", start);
                    size_t last_quote = line.find_last_of("\"");
                    if (first_quote != std::string::npos && last_quote != std::string::npos && first_quote < last_quote) {
                        info.created_date = line.substr(first_quote + 1, last_quote - first_quote - 1);
                    }
                }
            }
            file.close();
            g_AvailableTemplates.push_back(info);
        }
    }
    pclose(pipe);
}

// Helper: Extract string value from JSON line
std::string ExtractJsonString(const std::string& line) {
    size_t first = line.find("\":");
    if (first == std::string::npos) return "";
    first = line.find("\"", first + 2);
    if (first == std::string::npos) return "";
    size_t last = line.find_last_of("\"");
    if (last == std::string::npos || last <= first) return "";
    return line.substr(first + 1, last - first - 1);
}

// Helper: Extract number value from JSON line
float ExtractJsonNumber(const std::string& line) {
    size_t pos = line.find(":");
    if (pos == std::string::npos) return 0;
    std::string numStr = line.substr(pos + 1);
    // Remove trailing comma and whitespace
    size_t end = numStr.find_first_of(",\n\r");
    if (end != std::string::npos) numStr = numStr.substr(0, end);
    return std::stof(numStr);
}

// Helper: Extract color from JSON object string
ImVec4 ExtractJsonColor(const std::string& line) {
    ImVec4 color(1, 1, 1, 1);
    size_t rPos = line.find("\"r\":");
    size_t gPos = line.find("\"g\":");
    size_t bPos = line.find("\"b\":");
    size_t aPos = line.find("\"a\":");

    if (rPos != std::string::npos) {
        std::string rStr = line.substr(rPos + 4);
        color.x = std::stof(rStr);
    }
    if (gPos != std::string::npos) {
        std::string gStr = line.substr(gPos + 4);
        color.y = std::stof(gStr);
    }
    if (bPos != std::string::npos) {
        std::string bStr = line.substr(bPos + 4);
        color.z = std::stof(bStr);
    }
    if (aPos != std::string::npos) {
        std::string aStr = line.substr(aPos + 4);
        color.w = std::stof(aStr);
    }
    return color;
}

// ============================================================================
// CREATE OMNION WEBSITE FROM SCREENSHOT
// ============================================================================
void CreateOMNiONWebsite() {
    g_Sections.clear();
    g_SelectedSectionIndex = -1;
    g_NextSectionId = 1;

    // Enable Free Design Mode for proper positioning
    g_FreeDesignMode = true;

    // Layout constants - matching original omnion.us (max-width: 1080px, 80% container)
    const float PAGE_WIDTH = 1050.0f;
    const float CONTENT_PADDING = 20.0f;
    const float LEFT_COLUMN_WIDTH = 700.0f;   // ~67% for main content
    const float RIGHT_COLUMN_WIDTH = 300.0f;  // ~28% for sidebar
    const float COLUMN_GAP = 50.0f;           // Clear gap between columns
    const float RIGHT_COLUMN_X = LEFT_COLUMN_WIDTH + COLUMN_GAP;
    float currentY = 0.0f;

    // ========== 1. NAVBAR CONNECTOR (Full Width) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_NAVBAR_CONNECTOR);
        sec.name = "OMNiON Navbar";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = PAGE_WIDTH;
        sec.height = 60;
        sec.z_index = 0;

        sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White
        sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);  // Light orange hover
        sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);  // #666 gray
        sec.navbar_height = 60.0f;
        sec.navbar_padding_x = 15.0f;
        sec.navbar_padding_y = 15.0f;
        sec.navbar_spacing = 20.0f;
        sec.navbar_font_scale = 0.85f;
        sec.navbar_items.clear();

        // HOME with children
        NavbarMenuItem home;
        strcpy(home.label, "HOME");
        home.actionType = ACTION_LINK_TO_PAGE;
        strcpy(home.actionTarget, "Home");
        home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
        sec.navbar_items.push_back(home);

        // PREMEDIA with children
        NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA");
        premedia.actionType = ACTION_LINK_TO_PAGE;
        strcpy(premedia.actionTarget, "Premedia");
        premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
        sec.navbar_items.push_back(premedia);

        // SERVICES with children
        NavbarMenuItem services; strcpy(services.label, "SERVICES");
        services.actionType = ACTION_LINK_TO_PAGE;
        strcpy(services.actionTarget, "Services");
        services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
        sec.navbar_items.push_back(services);

        // PACKAGING with children
        NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING");
        packaging.actionType = ACTION_LINK_TO_PAGE;
        strcpy(packaging.actionTarget, "Packaging");
        packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
        sec.navbar_items.push_back(packaging);

        // IMAGING with children
        NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING");
        imaging.actionType = ACTION_LINK_TO_PAGE;
        strcpy(imaging.actionTarget, "Imaging");
        imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
        sec.navbar_items.push_back(imaging);

        // MOBILE-APPS with children
        NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS");
        mobileApps.actionType = ACTION_LINK_TO_PAGE;
        strcpy(mobileApps.actionTarget, "Mobile-Apps");
        mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
        sec.navbar_items.push_back(mobileApps);

        // NEWS with children
        NavbarMenuItem news; strcpy(news.label, "NEWS");
        news.actionType = ACTION_LINK_TO_PAGE;
        strcpy(news.actionTarget, "News");
        news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
        sec.navbar_items.push_back(news);

        // CONTACT US with children
        NavbarMenuItem contact; strcpy(contact.label, "CONTACT US");
        contact.actionType = ACTION_LINK_TO_PAGE;
        strcpy(contact.actionTarget, "Contact-Us");
        contact.children = {"OUTSOURCING", "JOB OPENINGS"};
        sec.navbar_items.push_back(contact);

        g_Sections.push_back(sec);
        currentY += 65;
    }

    // ========== 2. SERVICES CARDS ROW (Full Width) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_CARD_CONNECTOR);
        sec.name = "Services Cards";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = PAGE_WIDTH;
        sec.height = 90;
        sec.z_index = 1;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.connector_cards_per_row = 10;
        sec.connector_card_spacing = 5.0f;
        sec.connector_cards.clear();

        const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING",
            "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};

        for (int i = 0; i < 10; i++) {
            ThumbnailCard card;
            strcpy(card.heading, serviceNames[i]);
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);  // #e8651a orange
            card.headingSize = 0.65f;
            card.headingBoldness = 0.5f;
            card.cardWidth = 90;
            card.cardHeight = 55;
            card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
            card.borderThickness = 0;
            strcpy(card.description, "");
            sec.connector_cards.push_back(card);
        }
        g_Sections.push_back(sec);
        currentY += 95;
    }

    float twoColumnStartY = currentY;

    // ========== 3. "WHO ARE WE?" BAR (Left Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_BAR_CONNECTOR);
        sec.name = "Who Are We Bar";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = LEFT_COLUMN_WIDTH;
        sec.height = 38;
        sec.z_index = 2;
        sec.bar_items.clear();

        BarItem bar;
        strcpy(bar.heading, "WHO ARE WE?");
        bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);  // #e8651a orange
        bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        bar.barWidth = LEFT_COLUMN_WIDTH;
        bar.barHeight = 35.0f;
        bar.headingSize = 1.0f;
        bar.headingBoldness = 1.0f;
        bar.paddingLeft = 12.0f;
        sec.bar_items.push_back(bar);
        g_Sections.push_back(sec);
        currentY += 45;
    }

    // ========== 4. MAIN TEXT CONTENT (Left Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "About Text";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = LEFT_COLUMN_WIDTH;
        sec.height = 80;
        sec.z_index = 3;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = LEFT_COLUMN_WIDTH - 40;  // More margin
        sec.text_padding = 5.0f;
        sec.text_blocks.clear();

        TextBlock block1;
        block1.fontSize = 13.0f;
        block1.textColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);  // #666
        block1.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);  // #333
        block1.lineSpacing = 1.6f;

        TextSegment s1; s1.text = "At OMNiON, we work with clients and partners around the world and across diverse markets to provide "; s1.isBold = false;
        block1.segments.push_back(s1);
        TextSegment s2; s2.text = "premedia services"; s2.isBold = true;
        block1.segments.push_back(s2);
        TextSegment s3; s3.text = ", "; s3.isBold = false;
        block1.segments.push_back(s3);
        TextSegment s4; s4.text = "mobile publishing services"; s4.isBold = true;
        block1.segments.push_back(s4);
        TextSegment s5; s5.text = " & "; s5.isBold = false;
        block1.segments.push_back(s5);
        TextSegment s6; s6.text = "creative production solutions"; s6.isBold = true;
        block1.segments.push_back(s6);
        TextSegment s7; s7.text = " ranging from imaging, packaging artwork, prepress, design, animation & programming services to more complex projects."; s7.isBold = false;
        block1.segments.push_back(s7);
        sec.text_blocks.push_back(block1);

        TextBlock block2;
        block2.fontSize = 13.0f;
        block2.textColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        block2.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block2.lineSpacing = 1.6f;

        TextSegment f1; f1.text = "OMNiON Founders - "; f1.isBold = false;
        block2.segments.push_back(f1);
        TextSegment f2; f2.text = "M. C. ABRAHAM"; f2.isBold = true;
        block2.segments.push_back(f2);
        TextSegment f3; f3.text = ", based in Bangalore, India and his son - "; f3.isBold = false;
        block2.segments.push_back(f3);
        TextSegment f4; f4.text = "MAT ABRAHAM"; f4.isBold = true;
        block2.segments.push_back(f4);
        TextSegment f5; f5.text = ", based in New Jersey, USA has led premedia technology at Quad/Graphics, Inc."; f5.isBold = false;
        block2.segments.push_back(f5);
        sec.text_blocks.push_back(block2);

        g_Sections.push_back(sec);
        currentY += 90;
    }

    // ========== 5. LARGE IMAGE SECTION (Left Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_IMAGE);
        sec.name = "Design Tools Image";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = LEFT_COLUMN_WIDTH;
        sec.height = 300;
        sec.z_index = 4;
        sec.bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        sec.title = "";
        sec.subtitle = "";
        g_Sections.push_back(sec);
        currentY += 310;
    }

    // ========== 6. BOTTOM TEXT CONTENT (Left Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Premedia Description";
        sec.x_position = 0;
        sec.y_position = currentY;
        sec.width = LEFT_COLUMN_WIDTH;
        sec.height = 60;
        sec.z_index = 5;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = LEFT_COLUMN_WIDTH - 40;
        sec.text_padding = 5.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 13.0f;
        block.textColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        block.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.lineSpacing = 1.6f;

        TextSegment p1; p1.text = "Our top-quality "; p1.isBold = false;
        block.segments.push_back(p1);
        TextSegment p2; p2.text = "premedia"; p2.isBold = true;
        block.segments.push_back(p2);
        TextSegment p3; p3.text = " services help you publish your content across all channels, print, web or alternate media in the best possible way. It goes without saying that we will save you money, but more importantly we will help you do your job better."; p3.isBold = false;
        block.segments.push_back(p3);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
    }

    // ========== 7. SIDEBAR - RIGHT COLUMN ==========
    {
        WebSection sec(g_NextSectionId++, SEC_VERTICAL_CONNECTOR);
        sec.name = "Sidebar Content";
        sec.x_position = RIGHT_COLUMN_X;
        sec.y_position = twoColumnStartY;  // Start at same Y as "WHO ARE WE?"
        sec.width = RIGHT_COLUMN_WIDTH;
        sec.height = 520;
        sec.z_index = 10;  // Higher z-index to be on top

        sec.bg_color = ImVec4(0.98f, 0.98f, 0.98f, 1.0f);  // Slight gray background
        sec.vertical_content_width = RIGHT_COLUMN_WIDTH - 30;  // More padding
        sec.vertical_heading_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);  // #333
        sec.vertical_desc_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);     // #666
        sec.vertical_heading_size = 0.95f;
        sec.vertical_desc_size = 0.8f;
        sec.vertical_heading_boldness = 1.2f;
        sec.vertical_spacing = 8.0f;
        sec.vertical_blocks.clear();

        // Search box info text
        VerticalBlock search; search.type = 1; strcpy(search.text, "Our unique innovations & turn-key solutions based on our experience will help you succeed.");
        sec.vertical_blocks.push_back(search);

        VerticalBlock h1; h1.type = 0; strcpy(h1.text, "Reduce Time to Market / Save Time");
        sec.vertical_blocks.push_back(h1);
        VerticalBlock d1; d1.type = 1; strcpy(d1.text, "We are Staffed for 24/7 Production and Enjoy A 10+ Hour Time Zone Advantage");
        sec.vertical_blocks.push_back(d1);

        VerticalBlock h2; h2.type = 0; strcpy(h2.text, "Expand Range of Services");
        sec.vertical_blocks.push_back(h2);
        VerticalBlock d2; d2.type = 1; strcpy(d2.text, "OMNiON blends a wide range of professional services under one roof and this increases your ability to deal with the multi-dimensional challenges of today's markets.");
        sec.vertical_blocks.push_back(d2);

        VerticalBlock h3; h3.type = 0; strcpy(h3.text, "Complement Resources");
        sec.vertical_blocks.push_back(h3);
        VerticalBlock d3; d3.type = 1; strcpy(d3.text, "Our staff becomes an extension of yours - we aim to become the perfect complement to your internal resources.");
        sec.vertical_blocks.push_back(d3);

        g_Sections.push_back(sec);
    }

    // Calculate Y position after two-column section ends
    float fullWidthY = twoColumnStartY + 530;  // After sidebar ends

    // ========== 8. "WHAT WE'VE DONE..." BAR (Full Width) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_BAR_CONNECTOR);
        sec.name = "What We've Done Bar";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 38;
        sec.z_index = 11;
        sec.bar_items.clear();

        BarItem bar;
        strcpy(bar.heading, "WHAT WE'VE DONE...");
        bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);  // Orange
        bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        bar.barWidth = PAGE_WIDTH;
        bar.barHeight = 35.0f;
        bar.headingSize = 1.0f;
        bar.headingBoldness = 1.0f;
        bar.paddingLeft = 12.0f;
        sec.bar_items.push_back(bar);
        g_Sections.push_back(sec);
        fullWidthY += 45;
    }

    // ========== 9. WHAT WE'VE DONE TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Portfolio Description";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 60;
        sec.z_index = 12;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 12.0f;
        block.textColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        block.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.lineSpacing = 1.5f;

        TextSegment t1; t1.text = "OMNiON provides a wide range of digital premedia services, some of which are showcased below:\nNOTE: All trademarks and copyrights are the property of their respective owners and used for demonstration of the ability of our artists to perform such work."; t1.isBold = false;
        block.segments.push_back(t1);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 70;
    }

    // ========== 10. PORTFOLIO IMAGE SECTION ==========
    {
        WebSection sec(g_NextSectionId++, SEC_IMAGE);
        sec.name = "Portfolio Gallery";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 350;
        sec.z_index = 13;
        sec.bg_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
        sec.title = "";
        sec.subtitle = "";
        g_Sections.push_back(sec);
        fullWidthY += 360;
    }

    // ========== 11. "OMNION BENEFITS" BAR ==========
    {
        WebSection sec(g_NextSectionId++, SEC_BAR_CONNECTOR);
        sec.name = "Benefits Bar";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 38;
        sec.z_index = 14;
        sec.bar_items.clear();

        BarItem bar;
        strcpy(bar.heading, "OMNION BENEFITS");
        bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
        bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        bar.barWidth = PAGE_WIDTH;
        bar.barHeight = 35.0f;
        bar.headingSize = 1.0f;
        bar.headingBoldness = 1.0f;
        bar.paddingLeft = 12.0f;
        sec.bar_items.push_back(bar);
        g_Sections.push_back(sec);
        fullWidthY += 45;
    }

    // ========== 12. BENEFITS INTRO TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Benefits Intro";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 35;
        sec.z_index = 15;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 14.0f;
        block.textColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
        block.lineSpacing = 1.4f;

        TextSegment t1; t1.text = "OMNiON's consistently delivered benefits are guaranteed to satisfy you:"; t1.isBold = true;
        block.segments.push_back(t1);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 40;
    }

    // ========== 13. CORE VALUE (Left Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_VERTICAL_CONNECTOR);
        sec.name = "Core Value";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH / 2 - 20;
        sec.height = 200;
        sec.z_index = 16;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.vertical_content_width = PAGE_WIDTH / 2 - 50;
        sec.vertical_heading_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        sec.vertical_desc_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        sec.vertical_heading_size = 1.0f;
        sec.vertical_desc_size = 0.85f;
        sec.vertical_heading_boldness = 1.2f;
        sec.vertical_spacing = 6.0f;
        sec.vertical_blocks.clear();

        VerticalBlock h; h.type = 0; strcpy(h.text, "Core Value");
        sec.vertical_blocks.push_back(h);

        VerticalBlock d1; d1.type = 1; strcpy(d1.text, "‚Ä¢ Proven 40-Yr Track Record\n‚Ä¢ Best Talent in India\n‚Ä¢ Consistently High Quality\n‚Ä¢ World-Class Scaleable Resources\n‚Ä¢ Industry Best Practices\n‚Ä¢ Offshore Cost Savings");
        sec.vertical_blocks.push_back(d1);

        g_Sections.push_back(sec);
    }

    // ========== 14. END-TO-END SERVICES (Right Column) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_VERTICAL_CONNECTOR);
        sec.name = "End-to-End Services";
        sec.x_position = PAGE_WIDTH / 2 + 20;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH / 2 - 20;
        sec.height = 200;
        sec.z_index = 17;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.vertical_content_width = PAGE_WIDTH / 2 - 50;
        sec.vertical_heading_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        sec.vertical_desc_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        sec.vertical_heading_size = 1.0f;
        sec.vertical_desc_size = 0.85f;
        sec.vertical_heading_boldness = 1.2f;
        sec.vertical_spacing = 6.0f;
        sec.vertical_blocks.clear();

        VerticalBlock h; h.type = 0; strcpy(h.text, "End-to-End Services");
        sec.vertical_blocks.push_back(h);

        VerticalBlock d1; d1.type = 1; strcpy(d1.text, "‚Ä¢ Digital, Imaging, Retouching\n‚Ä¢ Design, Publishing, ePublishing, XML\n‚Ä¢ Mobile, Tablet, iPad, iPhone\n‚Ä¢ Visualization, CGI, Interactive, Website\n‚Ä¢ Technology & Programming\n‚Ä¢ Video, 3D, 2D & Animation");
        sec.vertical_blocks.push_back(d1);

        g_Sections.push_back(sec);
        fullWidthY += 210;
    }

    // ========== 15. FOOTER GUARANTEE TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Guarantee Footer";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 50;
        sec.z_index = 18;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 12.0f;
        block.textColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        block.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.lineSpacing = 1.5f;

        TextSegment t1; t1.text = "We back all our services with an unconditional satisfaction guarantee. If you are not satisfied, neither are we and you do not pay us if that is the case. Yes, its unconditional. Try us: "; t1.isBold = false;
        block.segments.push_back(t1);
        TextSegment t2; t2.text = "Sales@OMNiON.biz"; t2.isBold = true;
        block.segments.push_back(t2);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 60;
    }

    // ========== 16. "COMPREHENSIVE TECHNOLOGY SOLUTIONS" BAR ==========
    {
        WebSection sec(g_NextSectionId++, SEC_BAR_CONNECTOR);
        sec.name = "Technology Solutions Bar";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 38;
        sec.z_index = 19;
        sec.bar_items.clear();

        BarItem bar;
        strcpy(bar.heading, "COMPREHENSIVE TECHNOLOGY SOLUTIONS");
        bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
        bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        bar.barWidth = PAGE_WIDTH;
        bar.barHeight = 35.0f;
        bar.headingSize = 1.0f;
        bar.headingBoldness = 1.0f;
        bar.paddingLeft = 12.0f;
        sec.bar_items.push_back(bar);
        g_Sections.push_back(sec);
        fullWidthY += 45;
    }

    // ========== 17. END-TO-END SOLUTIONS INTRO TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Technology Intro";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 40;
        sec.z_index = 20;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 14.0f;
        block.textColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
        block.lineSpacing = 1.4f;

        TextSegment t1; t1.text = "We provide end-to-end solutions in a wide range of Operating Systems, Content Management Systems, Technologies and Platforms:"; t1.isBold = true;
        block.segments.push_back(t1);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 50;
    }

    // ========== 18. TECHNOLOGY 5-COLUMN FOOTER ==========
    {
        WebSection sec(g_NextSectionId++, SEC_FOOTER_CONNECTOR);
        sec.name = "Technology Columns";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 220;
        sec.z_index = 21;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.footer_heading_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
        sec.footer_subheading_color = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
        sec.footer_heading_size = 0.95f;
        sec.footer_subheading_size = 0.8f;
        sec.footer_heading_boldness = 1.2f;
        sec.footer_subheading_boldness = 0.0f;
        sec.footer_column_width = 180;
        sec.footer_item_spacing = 4.0f;
        sec.footer_columns.clear();

        // Mobile column
        FooterColumn col1;
        strcpy(col1.heading, "Mobile:");
        col1.items.push_back("‚Ä¢ iPhone & iPad Apps");
        col1.items.push_back("‚Ä¢ Android Apps");
        col1.items.push_back("‚Ä¢ Tablet Apps");
        col1.items.push_back("‚Ä¢ Mobile Web Apps");
        col1.items.push_back("‚Ä¢ Adobe Flash & Flex");
        col1.items.push_back("‚Ä¢ Microsoft Silverlight");
        col1.items.push_back("‚Ä¢ Maya, StudioMax");
        sec.footer_columns.push_back(col1);

        // CMS Websites column
        FooterColumn col2;
        strcpy(col2.heading, "CMS Websites:");
        col2.items.push_back("‚Ä¢ WordPress");
        col2.items.push_back("‚Ä¢ Joomla");
        col2.items.push_back("‚Ä¢ Drupal");
        col2.items.push_back("‚Ä¢ Yahoo ECommerce");
        col2.items.push_back("‚Ä¢ Sharepoint");
        col2.items.push_back("‚Ä¢ BlogEngine");
        sec.footer_columns.push_back(col2);

        // Platforms column
        FooterColumn col3;
        strcpy(col3.heading, "Platforms:");
        col3.items.push_back("‚Ä¢ Apple Macintosh");
        col3.items.push_back("‚Ä¢ Microsoft");
        col3.items.push_back("‚Ä¢ Linux");
        col3.items.push_back("‚Ä¢ FreeBSD");
        col3.items.push_back("‚Ä¢ LAMP/WAMP/XAMPP");
        col3.items.push_back("‚Ä¢ Yahoo Business");
        sec.footer_columns.push_back(col3);

        // Databases column
        FooterColumn col4;
        strcpy(col4.heading, "Databases:");
        col4.items.push_back("‚Ä¢ MariaDB");
        col4.items.push_back("‚Ä¢ MySQL");
        col4.items.push_back("‚Ä¢ SQL Server");
        col4.items.push_back("‚Ä¢ Oracle");
        col4.items.push_back("‚Ä¢ MS Access");
        col4.items.push_back("‚Ä¢ XML");
        sec.footer_columns.push_back(col4);

        // Languages column
        FooterColumn col5;
        strcpy(col5.heading, "Languages:");
        col5.items.push_back("‚Ä¢ Cocoa, Objective C");
        col5.items.push_back("‚Ä¢ PHP, HTML5, CSS3, JavaScript, jQuery, AJAX");
        col5.items.push_back("‚Ä¢ ASP.NET, C, C#, C++");
        col5.items.push_back("‚Ä¢ RTML, Yahoo Templates");
        col5.items.push_back("‚Ä¢ Web Services, RESTful, SOAP");
        sec.footer_columns.push_back(col5);

        g_Sections.push_back(sec);
        fullWidthY += 230;
    }

    // ========== 19. TECHNOLOGY OUTSOURCING TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Outsourcing Text";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 40;
        sec.z_index = 22;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 12.0f;
        block.textColor = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        block.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.lineSpacing = 1.5f;

        TextSegment t1; t1.text = "Talk to us if you would like a reliable technology outsourcing partner that will give you the attention you need."; t1.isBold = false;
        block.segments.push_back(t1);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 50;
    }

    // ========== 20. OMNION CLEVER SOLUTIONS TEXT ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Clever Solutions Text";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 80;
        sec.z_index = 23;

        sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 10.0f;
        sec.text_blocks.clear();

        TextBlock block;
        block.fontSize = 12.0f;
        block.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
        block.boldColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        block.lineSpacing = 1.6f;

        TextSegment t1; t1.text = "OMNiON's clever solutions makes technology fit with customers' business goals and not vice versa. Be it professional website design, logo creation, photography, Search Engine Optimisation (SEO), ecommerce, online marketing, website development, content management systems (CMS) or flash animations, we have the flexibility to work with clients in the way that best meets their objectives. Any website that is to become successful as a sales and marketing tool needs to be intuitive and easy to use for first-time and repeat visitors. We don't employ repetitive template solutions or formulaic approaches here. We specialize in Web 2.0 development, best-in-class website design, cutting-edge Interactive development, Rich Internet Application (RIA) development, Internet marketing, search engine optimization (SEO) and interactive programmers."; t1.isBold = false;
        block.segments.push_back(t1);
        sec.text_blocks.push_back(block);

        g_Sections.push_back(sec);
        fullWidthY += 90;
    }

    // ========== 21. ARTICLE CARDS - USING ARTICLE CONNECTOR ==========
    {
        WebSection sec(g_NextSectionId++, SEC_ARTICLE_CONNECTOR);
        sec.name = "Article Cards";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 200;
        sec.z_index = 24;
        sec.padding_left = 20;
        sec.padding_top = 15;

        sec.bg_color = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
        sec.article_cards_per_row = 2;
        sec.article_card_spacing = 30;
        sec.article_cards.clear();

        // Article Card 1 - Tablet Publishing
        ArticleCard card1;
        strcpy(card1.heading, "WHY TABLET PUBLISHING IS POISED TO REVOLUTIONIZE HIGHER EDUCATION");
        strcpy(card1.date, "6 Jan 2012");
        strcpy(card1.description, "Today, only 57% of students who attend college in the U.S. actually graduate. The country ranks 12th among 36 developed countries. President Obama's administration has a stated goal...");
        strcpy(card1.readMoreText, "READ MORE");
        card1.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);  // Orange clickable heading
        card1.dateColor = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
        card1.descriptionColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        card1.readMoreColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        card1.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
        card1.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);  // Orange left accent
        card1.cardWidth = 480;
        card1.cardHeight = 170;
        card1.accentWidth = 4;
        card1.cardPadding = 15;
        card1.headingSize = 0.95f;
        card1.dateSize = 0.75f;
        card1.descriptionSize = 0.8f;
        card1.readMoreSize = 0.75f;
        card1.headingActionType = ACTION_EXTERNAL_URL;
        strcpy(card1.headingActionTarget, "#tablet-publishing");
        card1.readMoreActionType = ACTION_EXTERNAL_URL;
        strcpy(card1.readMoreActionTarget, "#tablet-publishing");
        sec.article_cards.push_back(card1);

        // Article Card 2 - Apple Publishing
        ArticleCard card2;
        strcpy(card2.heading, "DID APPLE HELP SAVE PUBLISHING?");
        strcpy(card2.date, "5 Jan 2012");
        strcpy(card2.description, "Despite the ongoing Justice Department antitrust probe, Apple's (NASDAQ:AAPL) myriad syndication partnerships may have actually helped maintain the competitiveness of online publishing...");
        strcpy(card2.readMoreText, "READ MORE");
        card2.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
        card2.dateColor = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
        card2.descriptionColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
        card2.readMoreColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
        card2.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
        card2.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
        card2.cardWidth = 480;
        card2.cardHeight = 170;
        card2.accentWidth = 4;
        card2.cardPadding = 15;
        card2.headingSize = 0.95f;
        card2.dateSize = 0.75f;
        card2.descriptionSize = 0.8f;
        card2.readMoreSize = 0.75f;
        card2.headingActionType = ACTION_EXTERNAL_URL;
        strcpy(card2.headingActionTarget, "#apple-publishing");
        card2.readMoreActionType = ACTION_EXTERNAL_URL;
        strcpy(card2.readMoreActionTarget, "#apple-publishing");
        sec.article_cards.push_back(card2);

        g_Sections.push_back(sec);
        fullWidthY += 210;
    }

    // ========== 23. ORANGE SERVICES FOOTER (4 columns) ==========
    {
        WebSection sec(g_NextSectionId++, SEC_FOOTER_CONNECTOR);
        sec.name = "Services Footer";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 450;
        sec.z_index = 25;

        sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);  // Orange background
        sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White headings
        sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);  // White subheadings
        sec.footer_heading_size = 1.1f;
        sec.footer_subheading_size = 0.85f;
        sec.footer_heading_boldness = 1.5f;
        sec.footer_subheading_boldness = 0.0f;
        sec.footer_column_width = 240;
        sec.footer_item_spacing = 6.0f;
        sec.footer_columns.clear();

        // IMAGING SERVICES column
        FooterColumn col1;
        strcpy(col1.heading, "IMAGING SERVICES");
        col1.items.push_back("SILO");
        col1.items.push_back("MASKING");
        col1.items.push_back("RETOUCHING");
        col1.items.push_back("CLIPPING PATH");
        col1.items.push_back("COLOR CORRECTION");
        col1.items.push_back("SIZING");
        col1.items.push_back("VECTORIZING");
        col1.items.push_back("COLORIZING");
        col1.items.push_back("PHOTOGRAPHY");
        col1.items.push_back("SWATCH MATCHING");
        col1.items.push_back("CGI & MODELLING");
        sec.footer_columns.push_back(col1);

        // PACKAGING SERVICES + 3D & CGI column
        FooterColumn col2;
        strcpy(col2.heading, "PACKAGING SERVICES");
        col2.items.push_back("ARTWORK");
        col2.items.push_back("ADAPTATION");
        col2.items.push_back("LOCALIZATION");
        col2.items.push_back("TRAPPING");
        col2.items.push_back("COLOR SEPARATION");
        col2.items.push_back("ARTWORK MANAGEMENT");
        col2.items.push_back("");
        col2.items.push_back("3D & CGI SERVICES");
        col2.items.push_back("3D MODELLING");
        sec.footer_columns.push_back(col2);

        // ADVERTISING SERVICES + TECHNOLOGY column
        FooterColumn col3;
        strcpy(col3.heading, "ADVERTISING SERVICES");
        col3.items.push_back("BANNER ADS");
        col3.items.push_back("WEB, MOBILE & TABLET AD PROGRAMMING");
        col3.items.push_back("PRINT, RICH & MOBILE, MEDIA ADS");
        col3.items.push_back("AD DESIGN, IMAGING, LAYOUT, ILLUSTRATION");
        col3.items.push_back("BRANDING & CREATIVE");
        col3.items.push_back("");
        col3.items.push_back("TECHNOLOGY SERVICES");
        col3.items.push_back("CMS WEBSITE");
        col3.items.push_back("SEO");
        col3.items.push_back("YAHOO RTML");
        col3.items.push_back("ECOMMERCE WEBSITE");
        col3.items.push_back("APPLE DEVELOPMENT");
        col3.items.push_back("APPLICATION DEV");
        sec.footer_columns.push_back(col3);

        // PUBLISHING SERVICES + NEW MEDIA column
        FooterColumn col4;
        strcpy(col4.heading, "PUBLISHING SERVICES");
        col4.items.push_back("TABLET PUBLISHING");
        col4.items.push_back("IPAD PUBLISHING");
        col4.items.push_back("DESIGN & LAYOUT");
        col4.items.push_back("PROOF READING & COPY EDITING");
        col4.items.push_back("HTML, XML & TAGGING");
        col4.items.push_back("EPUB, EBOOK, DIGITIZATION");
        col4.items.push_back("");
        col4.items.push_back("NEW MEDIA SERVICES");
        col4.items.push_back("PACKAGING");
        col4.items.push_back("MAGAZINES");
        col4.items.push_back("CATALOGS");
        col4.items.push_back("BOOKS");
        col4.items.push_back("NEWSPAPERS");
        col4.items.push_back("DIGITAL ASSET MANAGEMENT (DAM)");
        col4.items.push_back("DATA MANAGEMENT");
        sec.footer_columns.push_back(col4);

        g_Sections.push_back(sec);
        fullWidthY += 460;
    }

    // ========== 24. DARK BOTTOM FOOTER ==========
    {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        sec.name = "Copyright Footer";
        sec.x_position = 0;
        sec.y_position = fullWidthY;
        sec.width = PAGE_WIDTH;
        sec.height = 60;
        sec.z_index = 27;

        sec.bg_color = ImVec4(0.18f, 0.18f, 0.18f, 1.0f);  // Dark gray
        sec.text_content_width = PAGE_WIDTH - 40;
        sec.text_padding = 15.0f;
        sec.text_blocks.clear();

        TextBlock block1;
        block1.fontSize = 11.0f;
        block1.textColor = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
        block1.boldColor = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        block1.lineSpacing = 1.8f;

        TextSegment t1; t1.text = "Website under development."; t1.isBold = false;
        block1.segments.push_back(t1);
        sec.text_blocks.push_back(block1);

        TextBlock block2;
        block2.fontSize = 10.0f;
        block2.textColor = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
        block2.boldColor = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
        block2.lineSpacing = 1.5f;

        TextSegment t2; t2.text = "2025 OMNION PREMEDIA PVT. LTD., BANGALORE, INDIA. ALL RIGHTS RESERVED. | "; t2.isBold = false;
        block2.segments.push_back(t2);
        TextSegment t3; t3.text = "Privacy Policy"; t3.isBold = true;
        block2.segments.push_back(t3);
        TextSegment t4; t4.text = " | "; t4.isBold = false;
        block2.segments.push_back(t4);
        TextSegment t5; t5.text = "Terms of service"; t5.isBold = true;
        block2.segments.push_back(t5);
        sec.text_blocks.push_back(block2);

        g_Sections.push_back(sec);
    }

    // ========================================================================
    // SAVE PAGE 1 (HOME) AND CREATE PAGE 2 (PREMEDIA)
    // ========================================================================

    // Clear existing pages and add Home page
    g_NormalPages.clear();
    NormalModePage homePage("Home");
    homePage.sections = g_Sections;
    g_NormalPages.push_back(homePage);

    // ========== CREATE PAGE 2: PREMEDIA ==========
    {
        NormalModePage premediaPage("Premedia");
        std::vector<WebSection> premediaSections;
        int premediaSectionId = 1000;  // Start ID for Premedia page
        float premediaY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(premediaSectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = premediaY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            // HOME with children
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            // PREMEDIA with children
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            // SERVICES with children
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            // PACKAGING with children
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            // IMAGING with children
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            // MOBILE-APPS with children
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            // NEWS with children
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            // CONTACT US with children
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            premediaSections.push_back(sec);
            premediaY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(premediaSectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = premediaY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            premediaSections.push_back(sec);
            premediaY += 95;
        }

        // ========== PREMEDIA ORANGE BAR ==========
        {
            WebSection sec(premediaSectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Premedia Bar";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH;
            sec.height = 45;
            sec.z_index = 1;
            sec.bar_items.clear();

            BarItem bar;
            strcpy(bar.heading, "PREMEDIA");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH;
            bar.barHeight = 42.0f;
            bar.headingSize = 1.2f;
            bar.headingBoldness = 1.5f;
            bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            premediaSections.push_back(sec);
            premediaY += 50;
        }

        // ========== PACKAGING ARTICLE CARD ==========
        {
            WebSection sec(premediaSectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Packaging Article";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH / 2 - 10;
            sec.height = 420;
            sec.z_index = 2;
            sec.padding_left = 20;
            sec.padding_top = 15;

            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1;
            sec.article_card_spacing = 20;
            sec.article_cards.clear();

            ArticleCard card;
            strcpy(card.heading, "PACKAGING");
            strcpy(card.date, "");
            strcpy(card.description, "With the average supermarket stocking over 40,000 separate lines, and an estimated 75% of all purchases more likely to be made on impulse within a 10 second time-frame rather than [...] ");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.dateColor = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480;
            card.cardHeight = 380;
            card.accentWidth = 0;
            card.cardPadding = 15;
            card.headingSize = 1.0f;
            card.descriptionSize = 0.85f;
            card.readMoreSize = 0.75f;
            sec.article_cards.push_back(card);
            premediaSections.push_back(sec);
        }

        // ========== MAGAZINES ARTICLE CARD ==========
        {
            WebSection sec(premediaSectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Magazines Article";
            sec.x_position = PAGE_WIDTH / 2 + 10;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH / 2 - 10;
            sec.height = 420;
            sec.z_index = 3;
            sec.padding_left = 20;
            sec.padding_top = 15;

            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1;
            sec.article_card_spacing = 20;
            sec.article_cards.clear();

            ArticleCard card;
            strcpy(card.heading, "MAGAZINES");
            strcpy(card.date, "");
            strcpy(card.description, "OMNiON can serve your magazines premedia needs to your precise requirements using the latest creative, imaging techniques & design treatments. We produce the highest quality [...] ");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.dateColor = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480;
            card.cardHeight = 380;
            card.accentWidth = 0;
            card.cardPadding = 15;
            card.headingSize = 1.0f;
            card.descriptionSize = 0.85f;
            card.readMoreSize = 0.75f;
            sec.article_cards.push_back(card);
            premediaSections.push_back(sec);
        }

        premediaY += 430;

        // ========== WHY OMNION SECTION ==========
        {
            WebSection sec(premediaSectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Why OMNiON";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH;
            sec.height = 400;
            sec.z_index = 4;

            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60;
            sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            // Title
            TextBlock titleBlock;
            titleBlock.fontSize = 20.0f;
            titleBlock.textColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.boldColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment titleSeg; titleSeg.text = "WHY OMNION?"; titleSeg.isBold = true;
            titleBlock.segments.push_back(titleSeg);
            sec.text_blocks.push_back(titleBlock);

            // Content
            TextBlock contentBlock;
            contentBlock.fontSize = 13.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;

            TextSegment s1; s1.text = "Our "; s1.isBold = false;
            contentBlock.segments.push_back(s1);
            TextSegment s2; s2.text = "unique innovations"; s2.isBold = true;
            contentBlock.segments.push_back(s2);
            TextSegment s3; s3.text = " & "; s3.isBold = false;
            contentBlock.segments.push_back(s3);
            TextSegment s4; s4.text = "turn-key solutions"; s4.isBold = true;
            contentBlock.segments.push_back(s4);
            TextSegment s5; s5.text = " based on our extensive experience & depth of knowledge will help you succeed. Our founder, "; s5.isBold = false;
            contentBlock.segments.push_back(s5);
            TextSegment s6; s6.text = "M. C. Abraham"; s6.isBold = true;
            contentBlock.segments.push_back(s6);
            TextSegment s7; s7.text = ", is India's most experienced, successful & widely regarded publishing & media services outsourcing expert having pioneered the industry back in 1974 & our co-founder, "; s7.isBold = false;
            contentBlock.segments.push_back(s7);
            TextSegment s8; s8.text = "Mat Abraham"; s8.isBold = true;
            contentBlock.segments.push_back(s8);
            TextSegment s9; s9.text = ", managed media solutions technology for Quad/Graphics, USA with over 20 years experience serving all the top media & brand customers in the world."; s9.isBold = false;
            contentBlock.segments.push_back(s9);
            sec.text_blocks.push_back(contentBlock);

            // Question block
            TextBlock questionBlock;
            questionBlock.fontSize = 12.0f;
            questionBlock.textColor = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
            questionBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            questionBlock.lineSpacing = 1.5f;
            TextSegment q1; q1.text = "WHAT DO QUAD/GRAPHICS-USA, SPRINGER VERLAG-GERMANY & REED ELSEVIER-HOLLAND HAVE IN COMMON WITH M. C. ABRAHAM?"; q1.isBold = false;
            questionBlock.segments.push_back(q1);
            sec.text_blocks.push_back(questionBlock);

            // Answer block
            TextBlock answerBlock;
            answerBlock.fontSize = 13.0f;
            answerBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            answerBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            answerBlock.lineSpacing = 1.6f;
            TextSegment a1; a1.text = "Over the last 20 yrs, they have "; a1.isBold = false;
            answerBlock.segments.push_back(a1);
            TextSegment a2; a2.text = "ALL"; a2.isBold = true;
            answerBlock.segments.push_back(a2);
            TextSegment a3; a3.text = " acquired premedia startups in India founded, managed & co-owned by OMNiON Chairman & Managing Director - M. C. Abraham, the latest one being in 2012!"; a3.isBold = false;
            answerBlock.segments.push_back(a3);
            sec.text_blocks.push_back(answerBlock);

            premediaSections.push_back(sec);
            premediaY += 410;
        }

        // ========== REDUCE TIME / EXPAND SERVICES ==========
        {
            WebSection sec(premediaSectionId++, SEC_VERTICAL_CONNECTOR);
            sec.name = "Benefits";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH;
            sec.height = 200;
            sec.z_index = 5;

            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_heading_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.vertical_desc_color = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            sec.vertical_heading_size = 1.1f;
            sec.vertical_desc_size = 0.9f;
            sec.vertical_heading_boldness = 1.2f;
            sec.vertical_content_width = PAGE_WIDTH - 60;
            sec.vertical_spacing = 12;
            sec.vertical_blocks.clear();

            VerticalBlock h1; h1.type = 0; strcpy(h1.text, "Reduce Time to Market / Save Time");
            sec.vertical_blocks.push_back(h1);
            VerticalBlock d1; d1.type = 1; strcpy(d1.text, "We are Staffed for 24/7 Production and Enjoy A 10+ Hour Time Zone Advantage");
            sec.vertical_blocks.push_back(d1);

            VerticalBlock h2; h2.type = 0; strcpy(h2.text, "Expand Range of Services");
            sec.vertical_blocks.push_back(h2);
            VerticalBlock d2; d2.type = 1; strcpy(d2.text, "OMNiON blends a wide range of professional services under one roof and this increases your ability to deal with the multi-dimensional challenges of today's markets.");
            sec.vertical_blocks.push_back(d2);

            premediaSections.push_back(sec);
            premediaY += 210;
        }

        // ========== ORANGE FOOTER ==========
        {
            WebSection sec(premediaSectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Services Footer";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH;
            sec.height = 400;
            sec.z_index = 6;

            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f;
            sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f;
            sec.footer_column_width = 240;
            sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();

            FooterColumn col1;
            strcpy(col1.heading, "PREMEDIA SERVICES");
            col1.items.push_back("Packaging");
            col1.items.push_back("Magazines");
            col1.items.push_back("Catalogs");
            col1.items.push_back("Newspapers");
            col1.items.push_back("Prepress");
            sec.footer_columns.push_back(col1);

            FooterColumn col2;
            strcpy(col2.heading, "CREATIVE SERVICES");
            col2.items.push_back("Web Design");
            col2.items.push_back("Graphic Design");
            col2.items.push_back("Logo Design");
            col2.items.push_back("Branding");
            col2.items.push_back("Print Design");
            sec.footer_columns.push_back(col2);

            FooterColumn col3;
            strcpy(col3.heading, "TECHNOLOGY");
            col3.items.push_back("Mobile Apps");
            col3.items.push_back("Web Development");
            col3.items.push_back("CMS Solutions");
            col3.items.push_back("E-commerce");
            col3.items.push_back("SEO/SEM");
            sec.footer_columns.push_back(col3);

            FooterColumn col4;
            strcpy(col4.heading, "CONTACT");
            col4.items.push_back("New Jersey, USA");
            col4.items.push_back("Bangalore, India");
            col4.items.push_back("info@omnion.us");
            col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);

            premediaSections.push_back(sec);
            premediaY += 410;
        }

        // ========== COPYRIGHT BAR ==========
        {
            WebSection sec(premediaSectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0;
            sec.y_position = premediaY;
            sec.width = PAGE_WIDTH;
            sec.height = 60;
            sec.z_index = 7;

            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_font_size = 11.0f;
            sec.copyright_subtext_size = 10.0f;
            sec.copyright_padding = 15.0f;
            sec.copyright_bg_opacity = 1.0f;

            CopyrightLink link1;
            strcpy(link1.text, "Privacy Policy");
            strcpy(link1.url, "#privacy");
            link1.isBold = true;
            sec.copyright_links.push_back(link1);

            CopyrightLink link2;
            strcpy(link2.text, "Terms of Service");
            strcpy(link2.url, "#terms");
            link2.isBold = true;
            sec.copyright_links.push_back(link2);

            premediaSections.push_back(sec);
        }

        premediaPage.sections = premediaSections;
        g_NormalPages.push_back(premediaPage);
    }

    // ========== CREATE PAGE 3: SERVICES ==========
    {
        NormalModePage servicesPage("Services");
        std::vector<WebSection> serviceSections;
        int sectionId = 2000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            serviceSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            serviceSections.push_back(sec);
            pageY += 95;
        }

        // SERVICES ORANGE BAR
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Services Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 1;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "SERVICES");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            serviceSections.push_back(sec);
            pageY += 50;
        }

        // CREATIVE ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Creative Article";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 2;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "CREATIVE");
            strcpy(card.date, "");
            strcpy(card.description, "Our creative team delivers innovative design solutions that capture your brand essence. From concept to completion, we transform ideas into compelling visual experiences that engage and inspire your audience.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            serviceSections.push_back(sec);
        }

        // CATALOG ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Catalog Article";
            sec.x_position = PAGE_WIDTH / 2 + 10; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 3;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "CATALOG");
            strcpy(card.date, "");
            strcpy(card.description, "Professional catalog production with attention to detail. We handle everything from photography and retouching to layout and printing, ensuring your products are presented in the best possible light.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            serviceSections.push_back(sec);
        }
        pageY += 430;

        // WHY OMNION SECTION
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Why OMNiON";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 300; sec.z_index = 4;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();
            TextBlock titleBlock;
            titleBlock.fontSize = 20.0f;
            titleBlock.textColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.boldColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment titleSeg; titleSeg.text = "OUR SERVICES"; titleSeg.isBold = true;
            titleBlock.segments.push_back(titleSeg);
            sec.text_blocks.push_back(titleBlock);
            TextBlock contentBlock;
            contentBlock.fontSize = 13.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment s1; s1.text = "OMNiON provides comprehensive "; s1.isBold = false;
            contentBlock.segments.push_back(s1);
            TextSegment s2; s2.text = "creative, catalog, and technology services"; s2.isBold = true;
            contentBlock.segments.push_back(s2);
            TextSegment s3; s3.text = " to help businesses grow and succeed in today's competitive market. Our experienced team delivers high-quality solutions tailored to your specific needs."; s3.isBold = false;
            contentBlock.segments.push_back(s3);
            sec.text_blocks.push_back(contentBlock);
            serviceSections.push_back(sec);
            pageY += 310;
        }

        // ORANGE FOOTER
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Services Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 5;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f; sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 240; sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();
            FooterColumn col1; strcpy(col1.heading, "CREATIVE SERVICES");
            col1.items.push_back("Web Design"); col1.items.push_back("Graphic Design");
            col1.items.push_back("Logo Design"); col1.items.push_back("Branding");
            sec.footer_columns.push_back(col1);
            FooterColumn col2; strcpy(col2.heading, "CATALOG SERVICES");
            col2.items.push_back("Product Photography"); col2.items.push_back("Retouching");
            col2.items.push_back("Layout Design"); col2.items.push_back("Print Production");
            sec.footer_columns.push_back(col2);
            FooterColumn col3; strcpy(col3.heading, "TECHNOLOGY");
            col3.items.push_back("Mobile Apps"); col3.items.push_back("Web Development");
            col3.items.push_back("CMS Solutions"); col3.items.push_back("E-commerce");
            sec.footer_columns.push_back(col3);
            FooterColumn col4; strcpy(col4.heading, "CONTACT");
            col4.items.push_back("info@omnion.us"); col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);
            serviceSections.push_back(sec);
            pageY += 410;
        }

        // COPYRIGHT BAR
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 6;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            serviceSections.push_back(sec);
        }

        servicesPage.sections = serviceSections;
        g_NormalPages.push_back(servicesPage);
    }

    // ========== CREATE PAGE 4: PACKAGING ==========
    {
        NormalModePage packagingPage("Packaging");
        std::vector<WebSection> packagingSections;
        int sectionId = 3000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            packagingSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            packagingSections.push_back(sec);
            pageY += 95;
        }

        // PACKAGING ORANGE BAR
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Packaging Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 1;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "PACKAGING");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            packagingSections.push_back(sec);
            pageY += 50;
        }

        // RETAIL PACKAGING ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Retail Packaging Article";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 2;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "RETAIL PACKAGING");
            strcpy(card.date, "");
            strcpy(card.description, "With the average supermarket stocking over 40,000 separate lines, and an estimated 75% of all purchases more likely to be made on impulse within a 10 second time-frame, your packaging needs to stand out.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            packagingSections.push_back(sec);
        }

        // LUXURY PACKAGING ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Luxury Packaging Article";
            sec.x_position = PAGE_WIDTH / 2 + 10; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 3;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "LUXURY PACKAGING");
            strcpy(card.date, "");
            strcpy(card.description, "Premium packaging solutions for luxury brands. We create sophisticated, high-end packaging that reflects the quality and exclusivity of your products, from concept design to final production.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            packagingSections.push_back(sec);
        }
        pageY += 430;

        // WHY OMNION SECTION
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Why OMNiON";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 300; sec.z_index = 4;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();
            TextBlock titleBlock;
            titleBlock.fontSize = 20.0f;
            titleBlock.textColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.boldColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment titleSeg; titleSeg.text = "PACKAGING EXPERTISE"; titleSeg.isBold = true;
            titleBlock.segments.push_back(titleSeg);
            sec.text_blocks.push_back(titleBlock);
            TextBlock contentBlock;
            contentBlock.fontSize = 13.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment s1; s1.text = "Our "; s1.isBold = false;
            contentBlock.segments.push_back(s1);
            TextSegment s2; s2.text = "packaging design and production team"; s2.isBold = true;
            contentBlock.segments.push_back(s2);
            TextSegment s3; s3.text = " brings decades of experience in creating impactful packaging solutions. From food & beverage to cosmetics and electronics, we deliver packaging that sells."; s3.isBold = false;
            contentBlock.segments.push_back(s3);
            sec.text_blocks.push_back(contentBlock);
            packagingSections.push_back(sec);
            pageY += 310;
        }

        // ORANGE FOOTER
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Packaging Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 5;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f; sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 240; sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();
            FooterColumn col1; strcpy(col1.heading, "PACKAGING TYPES");
            col1.items.push_back("Retail Packaging"); col1.items.push_back("Luxury Packaging");
            col1.items.push_back("Food Packaging"); col1.items.push_back("Cosmetic Packaging");
            sec.footer_columns.push_back(col1);
            FooterColumn col2; strcpy(col2.heading, "SERVICES");
            col2.items.push_back("Design & Concept"); col2.items.push_back("3D Mockups");
            col2.items.push_back("Print Production"); col2.items.push_back("Quality Control");
            sec.footer_columns.push_back(col2);
            FooterColumn col3; strcpy(col3.heading, "INDUSTRIES");
            col3.items.push_back("Food & Beverage"); col3.items.push_back("Cosmetics");
            col3.items.push_back("Electronics"); col3.items.push_back("Pharmaceuticals");
            sec.footer_columns.push_back(col3);
            FooterColumn col4; strcpy(col4.heading, "CONTACT");
            col4.items.push_back("info@omnion.us"); col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);
            packagingSections.push_back(sec);
            pageY += 410;
        }

        // COPYRIGHT BAR
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 6;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            packagingSections.push_back(sec);
        }

        packagingPage.sections = packagingSections;
        g_NormalPages.push_back(packagingPage);
    }

    // ========== CREATE PAGE 5: IMAGING ==========
    {
        NormalModePage imagingPage("Imaging");
        std::vector<WebSection> imagingSections;
        int sectionId = 4000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            imagingSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            imagingSections.push_back(sec);
            pageY += 95;
        }

        // IMAGING ORANGE BAR
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Imaging Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 1;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "IMAGING");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            imagingSections.push_back(sec);
            pageY += 50;
        }

        // PHOTO RETOUCHING ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Photo Retouching Article";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 2;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "PHOTO RETOUCHING");
            strcpy(card.date, "");
            strcpy(card.description, "Professional photo retouching services that enhance your images while maintaining natural appearance. From basic color correction to complex compositing, we deliver flawless results every time.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            imagingSections.push_back(sec);
        }

        // COLOR MANAGEMENT ARTICLE CARD
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "Color Management Article";
            sec.x_position = PAGE_WIDTH / 2 + 10; sec.y_position = pageY;
            sec.width = PAGE_WIDTH / 2 - 10; sec.height = 420; sec.z_index = 3;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 1; sec.article_card_spacing = 20;
            sec.article_cards.clear();
            ArticleCard card;
            strcpy(card.heading, "COLOR MANAGEMENT");
            strcpy(card.date, "");
            strcpy(card.description, "Accurate color reproduction across all media. Our color management expertise ensures consistency from screen to print, maintaining brand integrity across all your marketing materials.");
            strcpy(card.readMoreText, "READ MORE");
            card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.descriptionColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            card.readMoreColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            card.cardBgColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            card.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card.cardWidth = 480; card.cardHeight = 380; card.accentWidth = 0; card.cardPadding = 15;
            sec.article_cards.push_back(card);
            imagingSections.push_back(sec);
        }
        pageY += 430;

        // WHY OMNION SECTION
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Why OMNiON";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 300; sec.z_index = 4;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();
            TextBlock titleBlock;
            titleBlock.fontSize = 20.0f;
            titleBlock.textColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.boldColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment titleSeg; titleSeg.text = "IMAGING EXCELLENCE"; titleSeg.isBold = true;
            titleBlock.segments.push_back(titleSeg);
            sec.text_blocks.push_back(titleBlock);
            TextBlock contentBlock;
            contentBlock.fontSize = 13.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment s1; s1.text = "With over "; s1.isBold = false;
            contentBlock.segments.push_back(s1);
            TextSegment s2; s2.text = "40 years of imaging expertise"; s2.isBold = true;
            contentBlock.segments.push_back(s2);
            TextSegment s3; s3.text = ", OMNiON delivers world-class image processing, retouching, and color management services. Our skilled team handles millions of images annually for leading brands worldwide."; s3.isBold = false;
            contentBlock.segments.push_back(s3);
            sec.text_blocks.push_back(contentBlock);
            imagingSections.push_back(sec);
            pageY += 310;
        }

        // ORANGE FOOTER
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Imaging Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 5;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f; sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 240; sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();
            FooterColumn col1; strcpy(col1.heading, "IMAGING SERVICES");
            col1.items.push_back("Photo Retouching"); col1.items.push_back("Color Correction");
            col1.items.push_back("Compositing"); col1.items.push_back("Clipping Paths");
            sec.footer_columns.push_back(col1);
            FooterColumn col2; strcpy(col2.heading, "SPECIALTIES");
            col2.items.push_back("Product Photography"); col2.items.push_back("Fashion Retouching");
            col2.items.push_back("Beauty Retouching"); col2.items.push_back("3D Rendering");
            sec.footer_columns.push_back(col2);
            FooterColumn col3; strcpy(col3.heading, "TECHNOLOGY");
            col3.items.push_back("Adobe Creative Suite"); col3.items.push_back("Color Management");
            col3.items.push_back("Automated Workflows"); col3.items.push_back("DAM Systems");
            sec.footer_columns.push_back(col3);
            FooterColumn col4; strcpy(col4.heading, "CONTACT");
            col4.items.push_back("info@omnion.us"); col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);
            imagingSections.push_back(sec);
            pageY += 410;
        }

        // COPYRIGHT BAR
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 6;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            imagingSections.push_back(sec);
        }

        imagingPage.sections = imagingSections;
        g_NormalPages.push_back(imagingPage);
    }

    // ========== CREATE PAGE 6: MOBILE-APPS ==========
    {
        NormalModePage mobileAppsPage("Mobile-Apps");
        std::vector<WebSection> mobileAppsSections;
        int sectionId = 5000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            mobileAppsSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            mobileAppsSections.push_back(sec);
            pageY += 95;
        }

        // ========== MOBILE-APPS ORANGE BAR ==========
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Mobile-Apps Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 2;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "MOBILE-APPS");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            mobileAppsSections.push_back(sec);
            pageY += 50;
        }

        // ========== INTRO TEXT ==========
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Mobile Apps Intro";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 120; sec.z_index = 3;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            TextBlock block1;
            block1.fontSize = 13.0f;
            block1.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            block1.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            block1.lineSpacing = 1.6f;
            TextSegment s1; s1.text = "Our Mobile Tablet App Development services are comprehensive & cutting-edge."; s1.isBold = false;
            block1.segments.push_back(s1);
            sec.text_blocks.push_back(block1);

            TextBlock block2;
            block2.fontSize = 13.0f;
            block2.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            block2.lineSpacing = 1.6f;
            TextSegment s2; s2.text = "OMNiON is committed to making your mobile/tablet apps the most technologically advanced apps made. We use cutting-edge technologies in a cost-effective way to make your mobile solution most competitive. Our savvy use of a wide range of today's mobile technologies can also save you time, so that you can put more emphasis on profitability."; s2.isBold = false;
            block2.segments.push_back(s2);
            sec.text_blocks.push_back(block2);

            TextBlock block3;
            block3.fontSize = 13.0f;
            block3.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            block3.lineSpacing = 1.6f;
            TextSegment s3; s3.text = "OMNiON can develop your tablet app in any of the following mobile platforms:"; s3.isBold = false;
            block3.segments.push_back(s3);
            sec.text_blocks.push_back(block3);

            mobileAppsSections.push_back(sec);
            pageY += 130;
        }

        // ========== IOS APPS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_VERTICAL_CONNECTOR);
            sec.name = "iOS Apps";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 80; sec.z_index = 4;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_heading_color = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            sec.vertical_desc_color = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            sec.vertical_heading_size = 1.1f; sec.vertical_desc_size = 0.9f;
            sec.vertical_heading_boldness = 1.2f; sec.vertical_content_width = PAGE_WIDTH - 60;
            sec.vertical_spacing = 8; sec.vertical_blocks.clear();
            VerticalBlock h1; h1.type = 0; strcpy(h1.text, "IOS APPS");
            sec.vertical_blocks.push_back(h1);
            VerticalBlock d1; d1.type = 1; strcpy(d1.text, "OMNiON's iOS team creates Mobile Apps for iPad & iPhone on the iOS mobile operating system from Apple.");
            sec.vertical_blocks.push_back(d1);
            mobileAppsSections.push_back(sec);
            pageY += 90;
        }

        // ========== ANDROID APPS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_VERTICAL_CONNECTOR);
            sec.name = "Android Apps";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 80; sec.z_index = 5;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_heading_color = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            sec.vertical_desc_color = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            sec.vertical_heading_size = 1.1f; sec.vertical_desc_size = 0.9f;
            sec.vertical_heading_boldness = 1.2f; sec.vertical_content_width = PAGE_WIDTH - 60;
            sec.vertical_spacing = 8; sec.vertical_blocks.clear();
            VerticalBlock h1; h1.type = 0; strcpy(h1.text, "ANDROID APPS");
            sec.vertical_blocks.push_back(h1);
            VerticalBlock d1; d1.type = 1; strcpy(d1.text, "OMNiON's Android team creates Mobile/Tablet Apps for Nexus, Samsung Tabs, etc. on the Android mobile OS.");
            sec.vertical_blocks.push_back(d1);
            mobileAppsSections.push_back(sec);
            pageY += 90;
        }

        // ========== MOBILE WEB APPS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_VERTICAL_CONNECTOR);
            sec.name = "Mobile Web Apps";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 80; sec.z_index = 6;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_heading_color = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            sec.vertical_desc_color = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            sec.vertical_heading_size = 1.1f; sec.vertical_desc_size = 0.9f;
            sec.vertical_heading_boldness = 1.2f; sec.vertical_content_width = PAGE_WIDTH - 60;
            sec.vertical_spacing = 8; sec.vertical_blocks.clear();
            VerticalBlock h1; h1.type = 0; strcpy(h1.text, "MOBILE WEB APPS");
            sec.vertical_blocks.push_back(h1);
            VerticalBlock d1; d1.type = 1; strcpy(d1.text, "OMNiON's Mobile Web team uses PHP, HTML5, CSS3 & JavaScript Mobile Frameworks such as Sencha & Phonegap to develop Mobile Web Apps.");
            sec.vertical_blocks.push_back(d1);
            mobileAppsSections.push_back(sec);
            pageY += 90;
        }

        // ========== HOW WE CREATE APPS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "How We Create Apps";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 180; sec.z_index = 7;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            TextBlock titleBlock;
            titleBlock.fontSize = 16.0f;
            titleBlock.textColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.boldColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment t1; t1.text = "HOW WE CREATE APPS AT OMNION..."; t1.isBold = true;
            titleBlock.segments.push_back(t1);
            sec.text_blocks.push_back(titleBlock);

            TextBlock contentBlock;
            contentBlock.fontSize = 13.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment c1; c1.text = "Each platform has its own strengths & quirks, so in order to maximize the potential for any given app on any one platform, we've created dedicated teams that develop applications for all three platforms. Our mobile app team never fails to provide the most creative and engaging mobile applications."; c1.isBold = false;
            contentBlock.segments.push_back(c1);
            sec.text_blocks.push_back(contentBlock);

            TextBlock contactBlock;
            contactBlock.fontSize = 13.0f;
            contactBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contactBlock.lineSpacing = 1.6f;
            TextSegment ct1; ct1.text = "Talk to us... we will give you a free estimate for your mobile app project! Email us at MobileApps@OMNiON.biz"; ct1.isBold = false;
            contactBlock.segments.push_back(ct1);
            sec.text_blocks.push_back(contactBlock);

            mobileAppsSections.push_back(sec);
            pageY += 190;
        }

        // ========== ORANGE FOOTER ==========
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Mobile Apps Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 8;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f; sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 240; sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();
            FooterColumn col1; strcpy(col1.heading, "MOBILE PLATFORMS");
            col1.items.push_back("iOS Apps"); col1.items.push_back("Android Apps");
            col1.items.push_back("Mobile Web Apps"); col1.items.push_back("Cross-Platform");
            sec.footer_columns.push_back(col1);
            FooterColumn col2; strcpy(col2.heading, "SERVICES");
            col2.items.push_back("App Development"); col2.items.push_back("UI/UX Design");
            col2.items.push_back("App Testing"); col2.items.push_back("App Maintenance");
            sec.footer_columns.push_back(col2);
            FooterColumn col3; strcpy(col3.heading, "TECHNOLOGIES");
            col3.items.push_back("Swift / Objective-C"); col3.items.push_back("Kotlin / Java");
            col3.items.push_back("React Native"); col3.items.push_back("Flutter");
            sec.footer_columns.push_back(col3);
            FooterColumn col4; strcpy(col4.heading, "CONTACT");
            col4.items.push_back("MobileApps@OMNiON.biz"); col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);
            mobileAppsSections.push_back(sec);
            pageY += 410;
        }

        // ========== COPYRIGHT BAR ==========
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 9;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            mobileAppsSections.push_back(sec);
        }

        mobileAppsPage.sections = mobileAppsSections;
        g_NormalPages.push_back(mobileAppsPage);
    }

    // ========== CREATE PAGE 7: NEWS ==========
    {
        NormalModePage newsPage("News");
        std::vector<WebSection> newsSections;
        int sectionId = 6000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            newsSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            newsSections.push_back(sec);
            pageY += 95;
        }

        // ========== NEWS ORANGE BAR ==========
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "News Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 2;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "NEWS");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            newsSections.push_back(sec);
            pageY += 50;
        }

        // ========== NEWS ARTICLE CARDS - ROW 1 ==========
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "News Articles Row 1";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 200; sec.z_index = 3;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 2; sec.article_card_spacing = 30;
            sec.article_cards.clear();

            ArticleCard card1;
            strcpy(card1.heading, "WHY TABLET PUBLISHING IS POISED TO REVOLUTIONIZE HIGHER EDUCATION");
            strcpy(card1.date, "6 Jan 2012");
            strcpy(card1.description, "Today, only 57% of students who attend college in the U.S. actually graduate. The country ranks 12th among 36 developed countries. President Obama's administration has a stated [...]");
            strcpy(card1.readMoreText, "READ MORE");
            card1.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
            card1.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardWidth = 480; card1.cardHeight = 170; card1.accentWidth = 4;
            sec.article_cards.push_back(card1);

            ArticleCard card2;
            strcpy(card2.heading, "DID APPLE HELP SAVE PUBLISHING?");
            strcpy(card2.date, "5 Jan 2012");
            strcpy(card2.description, "Despite the ongoing Justice Department antitrust probe, Apple's (NASDAQ:AAPL) myriad syndication partnerships may have actually helped maintain the competitiveness of online publishing [...]");
            strcpy(card2.readMoreText, "READ MORE");
            card2.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card2.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
            card2.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card2.cardWidth = 480; card2.cardHeight = 170; card2.accentWidth = 4;
            sec.article_cards.push_back(card2);

            newsSections.push_back(sec);
            pageY += 210;
        }

        // ========== NEWS ARTICLE CARDS - ROW 2 ==========
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "News Articles Row 2";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 200; sec.z_index = 4;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 2; sec.article_card_spacing = 30;
            sec.article_cards.clear();

            ArticleCard card1;
            strcpy(card1.heading, "THE BUSINESS IMPACT OF CUSTOMER EXPERIENCE");
            strcpy(card1.date, "4 Jan 2012");
            strcpy(card1.description, "THE BUSINESS IMPACT OF CUSTOMER EXPERIENCE I just published Forrester's fourth annual report \"The Business Impact of Customer Experience\" using updated data from the 2012 Customer Experience Index. Once again [...]");
            strcpy(card1.readMoreText, "READ MORE");
            card1.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
            card1.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardWidth = 480; card1.cardHeight = 170; card1.accentWidth = 4;
            sec.article_cards.push_back(card1);

            ArticleCard card2;
            strcpy(card2.heading, "CATALOGUE MIXES CATALOG SHOPPING AND TABLETS WITH SUCCESS");
            strcpy(card2.date, "3 Jan 2012");
            strcpy(card2.description, "CATALOGUE MIXES CATALOG SHOPPING AND TABLETS WITH SUCCESS Best Buy, Crate & Barrel and Williams-Sonoma are letting consumers check the real-time availability of [...]");
            strcpy(card2.readMoreText, "READ MORE");
            card2.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card2.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
            card2.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card2.cardWidth = 480; card2.cardHeight = 170; card2.accentWidth = 4;
            sec.article_cards.push_back(card2);

            newsSections.push_back(sec);
            pageY += 210;
        }

        // ========== NEWS ARTICLE CARDS - ROW 3 ==========
        {
            WebSection sec(sectionId++, SEC_ARTICLE_CONNECTOR);
            sec.name = "News Articles Row 3";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 200; sec.z_index = 5;
            sec.padding_left = 20; sec.padding_top = 15;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.article_cards_per_row = 2; sec.article_card_spacing = 30;
            sec.article_cards.clear();

            ArticleCard card1;
            strcpy(card1.heading, "BRANDS SEE TABLET PUBLISHING THROUGH APPS AS ANOTHER WAY TO REACH COSUMERS");
            strcpy(card1.date, "2 Jan 2012");
            strcpy(card1.description, "BRANDS SEE TABLET PUBLISHING THROUGH APPS AS ANOTHER WAY TO REACH COSUMERS Here is another example of a brand launching an iPad app as part of [...]");
            strcpy(card1.readMoreText, "READ MORE");
            card1.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardBgColor = ImVec4(0.97f, 0.97f, 0.97f, 1.0f);
            card1.accentColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            card1.cardWidth = 480; card1.cardHeight = 170; card1.accentWidth = 4;
            sec.article_cards.push_back(card1);

            newsSections.push_back(sec);
            pageY += 210;
        }

        // ========== ORANGE FOOTER ==========
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "News Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 6;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.1f; sec.footer_subheading_size = 0.85f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 240; sec.footer_item_spacing = 6.0f;
            sec.footer_columns.clear();
            FooterColumn col1; strcpy(col1.heading, "PREMEDIA SERVICES");
            col1.items.push_back("Packaging"); col1.items.push_back("Magazines");
            col1.items.push_back("Catalogs"); col1.items.push_back("Newspapers");
            sec.footer_columns.push_back(col1);
            FooterColumn col2; strcpy(col2.heading, "CREATIVE SERVICES");
            col2.items.push_back("Web Design"); col2.items.push_back("Graphic Design");
            col2.items.push_back("Logo Design"); col2.items.push_back("Branding");
            sec.footer_columns.push_back(col2);
            FooterColumn col3; strcpy(col3.heading, "TECHNOLOGY");
            col3.items.push_back("Mobile Apps"); col3.items.push_back("Web Development");
            col3.items.push_back("CMS Solutions"); col3.items.push_back("E-commerce");
            sec.footer_columns.push_back(col3);
            FooterColumn col4; strcpy(col4.heading, "CONTACT");
            col4.items.push_back("info@omnion.us"); col4.items.push_back("+1 555 123 4567");
            sec.footer_columns.push_back(col4);
            newsSections.push_back(sec);
            pageY += 410;
        }

        // ========== COPYRIGHT BAR ==========
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 7;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            newsSections.push_back(sec);
        }

        newsPage.sections = newsSections;
        g_NormalPages.push_back(newsPage);
    }

    // ========== CREATE PAGE 8: CONTACT US ==========
    {
        NormalModePage contactPage("Contact-Us");
        std::vector<WebSection> contactSections;
        int sectionId = 7000;
        float pageY = 0;

        // ========== NAVBAR CONNECTOR ==========
        {
            WebSection sec(sectionId++, SEC_NAVBAR_CONNECTOR);
            sec.name = "OMNiON Navbar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 0;
            sec.navbar_bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_hover_color = ImVec4(0.9f, 0.4f, 0.1f, 0.1f);
            sec.navbar_dropdown_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.navbar_text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.navbar_height = 60.0f; sec.navbar_padding_x = 15.0f;
            sec.navbar_padding_y = 15.0f; sec.navbar_spacing = 20.0f; sec.navbar_font_scale = 0.85f;
            sec.navbar_items.clear();
            NavbarMenuItem home; strcpy(home.label, "HOME"); home.actionType = ACTION_LINK_TO_PAGE; strcpy(home.actionTarget, "Home");
            home.children = {"ABOUT", "VALUES", "OUTSOURCING", "HOW WE WORK", "OUR FOUNDER", "PRIVACY POLICY", "TERMS OF SERVICES"};
            sec.navbar_items.push_back(home);
            NavbarMenuItem premedia; strcpy(premedia.label, "PREMEDIA"); premedia.actionType = ACTION_LINK_TO_PAGE; strcpy(premedia.actionTarget, "Premedia");
            premedia.children = {"PACKAGING", "MAGAZINES", "CATALOGS", "BOOKS", "NEWSPAPERS", "DIGITAL ASSET MANAGEMENT (DAM)", "DATA MANAGEMENT"};
            sec.navbar_items.push_back(premedia);
            NavbarMenuItem services; strcpy(services.label, "SERVICES"); services.actionType = ACTION_LINK_TO_PAGE; strcpy(services.actionTarget, "Services");
            services.children = {"PACKAGING", "CREATIVE", "PUBLISHING", "ADVERTISING", "PREPRESS", "NEW MEDIA", "INTERNET", "NEWSPAPERS", "PHOTOGRAPHY", "ANIMATION", "CATALOG"};
            sec.navbar_items.push_back(services);
            NavbarMenuItem packaging; strcpy(packaging.label, "PACKAGING"); packaging.actionType = ACTION_LINK_TO_PAGE; strcpy(packaging.actionTarget, "Packaging");
            packaging.children = {"ARTWORK", "ADAPTATION", "LOCALIZATION", "TRAPPING", "COLOR SEPARATION", "DIGITAL ASSET MANAGEMENT (DAM)", "3D PROTOTYPING"};
            sec.navbar_items.push_back(packaging);
            NavbarMenuItem imaging; strcpy(imaging.label, "IMAGING"); imaging.actionType = ACTION_LINK_TO_PAGE; strcpy(imaging.actionTarget, "Imaging");
            imaging.children = {"SILO", "MASKING", "CLIPPING PATH", "SIZING", "COLOR CORRECTION", "SWATCH MATCHING", "VECTORISING", "COLORIZING", "CGI"};
            sec.navbar_items.push_back(imaging);
            NavbarMenuItem mobileApps; strcpy(mobileApps.label, "MOBILE-APPS"); mobileApps.actionType = ACTION_LINK_TO_PAGE; strcpy(mobileApps.actionTarget, "Mobile-Apps");
            mobileApps.children = {"IOS APPS", "ANDROID APPS", "MOBILE WEB APPS", "TABLET PUBLISHING APPS"};
            sec.navbar_items.push_back(mobileApps);
            NavbarMenuItem news; strcpy(news.label, "NEWS"); news.actionType = ACTION_LINK_TO_PAGE; strcpy(news.actionTarget, "News");
            news.children = {"BOOKS", "MAGAZINES", "CATALOGS", "ADVERTISING", "PACKAGING", "INTERACTIVE", "VIDEO", "PREPRESS", "TECHNOLOGY"};
            sec.navbar_items.push_back(news);
            NavbarMenuItem contact; strcpy(contact.label, "CONTACT US"); contact.actionType = ACTION_LINK_TO_PAGE; strcpy(contact.actionTarget, "Contact-Us");
            contact.children = {"OUTSOURCING", "JOB OPENINGS"};
            sec.navbar_items.push_back(contact);
            contactSections.push_back(sec);
            pageY += 65;
        }

        // ========== 10 SERVICE CARDS STRIP ==========
        {
            WebSection sec(sectionId++, SEC_CARD_CONNECTOR);
            sec.name = "Services Cards";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 90; sec.z_index = 1;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.connector_cards_per_row = 10; sec.connector_card_spacing = 5.0f;
            sec.connector_cards.clear();
            const char* serviceNames[] = {"PACKAGING", "IMAGING", "PREPRESS", "PUBLISHING", "NEW MEDIA", "CREATIVE", "CATALOG", "TECHNOLOGY", "ADVERTISING", "ANIMATION"};
            for (int i = 0; i < 10; i++) {
                ThumbnailCard card;
                strcpy(card.heading, serviceNames[i]);
                card.headingColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
                card.headingSize = 0.65f; card.headingBoldness = 0.5f;
                card.cardWidth = 90; card.cardHeight = 55;
                card.cardColor = ImVec4(0.88f, 0.88f, 0.88f, 1.0f);
                card.borderThickness = 0; strcpy(card.description, "");
                sec.connector_cards.push_back(card);
            }
            contactSections.push_back(sec);
            pageY += 95;
        }

        // ========== CONTACT US ORANGE BAR ==========
        {
            WebSection sec(sectionId++, SEC_BAR_CONNECTOR);
            sec.name = "Contact Us Bar";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 45; sec.z_index = 2;
            sec.bar_items.clear();
            BarItem bar;
            strcpy(bar.heading, "CONTACT US");
            bar.barColor = ImVec4(0.91f, 0.40f, 0.10f, 1.0f);
            bar.headingColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            bar.barWidth = PAGE_WIDTH; bar.barHeight = 42.0f;
            bar.headingSize = 1.2f; bar.headingBoldness = 1.5f; bar.paddingLeft = 15.0f;
            sec.bar_items.push_back(bar);
            contactSections.push_back(sec);
            pageY += 50;
        }

        // ========== CONTACT INFO SECTION ==========
        {
            WebSection sec(sectionId++, SEC_VERTICAL_CONNECTOR);
            sec.name = "Contact Info";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 180; sec.z_index = 3;
            sec.bg_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
            sec.vertical_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_desc_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.vertical_heading_size = 1.3f; sec.vertical_desc_size = 1.1f;
            sec.vertical_heading_boldness = 1.5f; sec.vertical_content_width = PAGE_WIDTH - 60;
            sec.vertical_spacing = 8; sec.vertical_blocks.clear();

            VerticalBlock h1; h1.type = 0; strcpy(h1.text, "S : OMNiONbiz");
            sec.vertical_blocks.push_back(h1);
            VerticalBlock h2; h2.type = 0; strcpy(h2.text, "E-MAIL : SALES@OMNION.BIZ");
            sec.vertical_blocks.push_back(h2);
            VerticalBlock h3; h3.type = 0; strcpy(h3.text, "PHONE: +1-212-537-6356");
            sec.vertical_blocks.push_back(h3);
            VerticalBlock h4; h4.type = 0; strcpy(h4.text, "WE ARE OPEN 24 / 7 * 365 CALL US ANY TIME");
            sec.vertical_blocks.push_back(h4);

            contactSections.push_back(sec);
            pageY += 190;
        }

        // ========== TALK TO THE BEST SECTION ==========
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Talk to the Best";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 200; sec.z_index = 4;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            TextBlock titleBlock;
            titleBlock.fontSize = 18.0f;
            titleBlock.textColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment t1; t1.text = "Talk to the Best! Get in touch..."; t1.isBold = true;
            titleBlock.segments.push_back(t1);
            sec.text_blocks.push_back(titleBlock);

            TextBlock contentBlock;
            contentBlock.fontSize = 12.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment c1; c1.text = "If you would like to experience the best in outsourced services, talk to us. We would love to hear from you, whether it is an inquiry about working with us on project, outsource or partner basis - or - if you just have a question - one of our local representatives will be sure to get in touch with you."; c1.isBold = false;
            contentBlock.segments.push_back(c1);
            sec.text_blocks.push_back(contentBlock);

            TextBlock contactBlock;
            contactBlock.fontSize = 12.0f;
            contactBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contactBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contactBlock.lineSpacing = 1.5f;
            TextSegment e1; e1.text = "E-Mail : "; e1.isBold = false; contactBlock.segments.push_back(e1);
            TextSegment e2; e2.text = "Sales@OMNiON.biz"; e2.isBold = true; contactBlock.segments.push_back(e2);
            sec.text_blocks.push_back(contactBlock);

            TextBlock phoneBlock;
            phoneBlock.fontSize = 12.0f;
            phoneBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            phoneBlock.lineSpacing = 1.3f;
            TextSegment p1; p1.text = "Skype ID : omnionbiz"; p1.isBold = false; phoneBlock.segments.push_back(p1);
            sec.text_blocks.push_back(phoneBlock);

            TextBlock usaBlock;
            usaBlock.fontSize = 12.0f;
            usaBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            usaBlock.lineSpacing = 1.3f;
            TextSegment u1; u1.text = "USA Phone: +1-212-380-1654 or +1-212-537-6356"; u1.isBold = false; usaBlock.segments.push_back(u1);
            sec.text_blocks.push_back(usaBlock);

            TextBlock euBlock;
            euBlock.fontSize = 12.0f;
            euBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            euBlock.lineSpacing = 1.3f;
            TextSegment eu1; eu1.text = "EU Phone: +44-207-993-5830"; eu1.isBold = false; euBlock.segments.push_back(eu1);
            sec.text_blocks.push_back(euBlock);

            TextBlock indiaBlock;
            indiaBlock.fontSize = 12.0f;
            indiaBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            indiaBlock.lineSpacing = 1.3f;
            TextSegment in1; in1.text = "India Phone: +91-80-41202794"; in1.isBold = false; indiaBlock.segments.push_back(in1);
            sec.text_blocks.push_back(indiaBlock);

            contactSections.push_back(sec);
            pageY += 210;
        }

        // ========== JOB OPENINGS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Job Openings";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 120; sec.z_index = 5;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            TextBlock titleBlock;
            titleBlock.fontSize = 18.0f;
            titleBlock.textColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment t1; t1.text = "JOB OPENINGS"; t1.isBold = true;
            titleBlock.segments.push_back(t1);
            sec.text_blocks.push_back(titleBlock);

            TextBlock contentBlock;
            contentBlock.fontSize = 12.0f;
            contentBlock.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            contentBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            contentBlock.lineSpacing = 1.6f;
            TextSegment c1; c1.text = "We are always hiring the best talent anywhere in the world at our Global Operations HQ in Bangalore, India. If you are the best at what you do, and feel you can be a valuable member of the best media solutions and services team in the world, please send us your resume at: "; c1.isBold = false;
            contentBlock.segments.push_back(c1);
            TextSegment c2; c2.text = "Talent@OMNiON.in"; c2.isBold = true;
            contentBlock.segments.push_back(c2);
            sec.text_blocks.push_back(contentBlock);

            contactSections.push_back(sec);
            pageY += 130;
        }

        // ========== ADDRESS SECTION ==========
        {
            WebSection sec(sectionId++, SEC_TEXT_CONNECTOR);
            sec.name = "Address";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 100; sec.z_index = 6;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.text_content_width = PAGE_WIDTH - 60; sec.text_padding = 20.0f;
            sec.text_blocks.clear();

            TextBlock titleBlock;
            titleBlock.fontSize = 16.0f;
            titleBlock.textColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.boldColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            titleBlock.lineSpacing = 1.8f;
            TextSegment t1; t1.text = "Address"; t1.isBold = true;
            titleBlock.segments.push_back(t1);
            sec.text_blocks.push_back(titleBlock);

            TextBlock addr1Block;
            addr1Block.fontSize = 11.0f;
            addr1Block.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            addr1Block.lineSpacing = 1.5f;
            TextSegment a1; a1.text = "OMNiON PreMedia Private Limited Regal Entry, 2nd Floor Ambalpadi PO, Karavali Junction Udupi - 576103, Karnataka. 0820 - 2520200"; a1.isBold = false;
            addr1Block.segments.push_back(a1);
            sec.text_blocks.push_back(addr1Block);

            TextBlock addr2Block;
            addr2Block.fontSize = 11.0f;
            addr2Block.textColor = ImVec4(0.35f, 0.35f, 0.35f, 1.0f);
            addr2Block.lineSpacing = 1.5f;
            TextSegment a2; a2.text = "OMNiON PreMedia Pvt. Ltd. #516, 3rd floor, Krishvi Aspire, C.M.H. road, Indiranagar 1st stage, Bangalore - 560038 080 - 25210200"; a2.isBold = false;
            addr2Block.segments.push_back(a2);
            sec.text_blocks.push_back(addr2Block);

            contactSections.push_back(sec);
            pageY += 110;
        }

        // ========== CONTACT FORM ==========
        {
            WebSection sec(sectionId++, SEC_CONTACT_FORM_CONNECTOR);
            sec.name = "Contact Form";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 400; sec.z_index = 7;
            sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.padding_left = 30; sec.padding_top = 20;

            strcpy(sec.contact_form_title, "Contact Us");
            strcpy(sec.contact_form_submit_text, "Submit");
            strcpy(sec.contact_form_submit_target, "Sales@OMNiON.biz");
            sec.contact_form_submit_action = ACTION_EMAIL;
            sec.contact_form_title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            sec.contact_form_input_bg = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
            sec.contact_form_input_text = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
            sec.contact_form_button_bg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.contact_form_button_text = ImVec4(0.2f, 0.6f, 0.9f, 1.0f);
            sec.contact_form_button_border = ImVec4(0.2f, 0.6f, 0.9f, 1.0f);
            sec.contact_form_title_size = 1.0f;
            sec.contact_form_input_height = 45.0f;
            sec.contact_form_textarea_height = 150.0f;
            sec.contact_form_button_width = 100.0f;
            sec.contact_form_button_height = 40.0f;
            sec.contact_form_spacing = 20.0f;
            sec.contact_form_fields.clear();

            ContactFormField nameField; strcpy(nameField.placeholder, "Name"); nameField.fieldType = 0; nameField.width = 0.5f;
            sec.contact_form_fields.push_back(nameField);
            ContactFormField emailField; strcpy(emailField.placeholder, "Email Address"); emailField.fieldType = 1; emailField.width = 0.5f;
            sec.contact_form_fields.push_back(emailField);
            ContactFormField phoneField; strcpy(phoneField.placeholder, "Phone No."); phoneField.fieldType = 2; phoneField.width = 0.5f;
            sec.contact_form_fields.push_back(phoneField);
            ContactFormField firmField; strcpy(firmField.placeholder, "Firm Name"); firmField.fieldType = 0; firmField.width = 0.5f;
            sec.contact_form_fields.push_back(firmField);
            ContactFormField messageField; strcpy(messageField.placeholder, "Message"); messageField.fieldType = 3; messageField.width = 1.0f;
            sec.contact_form_fields.push_back(messageField);

            contactSections.push_back(sec);
            pageY += 410;
        }

        // ========== ORANGE FOOTER (6 columns) ==========
        {
            WebSection sec(sectionId++, SEC_FOOTER_CONNECTOR);
            sec.name = "Services Footer";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 550; sec.z_index = 8;
            sec.bg_color = ImVec4(0.85f, 0.42f, 0.15f, 1.0f);
            sec.footer_heading_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            sec.footer_subheading_color = ImVec4(1.0f, 1.0f, 1.0f, 0.85f);
            sec.footer_heading_size = 1.0f; sec.footer_subheading_size = 0.75f;
            sec.footer_heading_boldness = 1.5f; sec.footer_column_width = 160; sec.footer_item_spacing = 4.0f;
            sec.footer_columns.clear();

            FooterColumn col1; strcpy(col1.heading, "IMAGING SERVICES");
            col1.items.push_back("SILO"); col1.items.push_back("MASKING");
            col1.items.push_back("RETOUCHING"); col1.items.push_back("CLIPPING PATH");
            col1.items.push_back("COLOR CORRECTION"); col1.items.push_back("SIZING");
            col1.items.push_back("VECTORIZING"); col1.items.push_back("COLORIZING");
            col1.items.push_back("PHOTOGRAPHY"); col1.items.push_back("SWATCH MATCHING");
            col1.items.push_back("CGI & MODELLING");
            sec.footer_columns.push_back(col1);

            FooterColumn col2; strcpy(col2.heading, "PACKAGING SERVICES");
            col2.items.push_back("ARTWORK"); col2.items.push_back("ADAPTATION");
            col2.items.push_back("LOCALIZATION"); col2.items.push_back("TRAPPING");
            col2.items.push_back("COLOR SEPARATION"); col2.items.push_back("ARTWORK MANAGEMENT");
            sec.footer_columns.push_back(col2);

            FooterColumn col3; strcpy(col3.heading, "3D & CGI SERVICES");
            col3.items.push_back("3D MODELLING");
            sec.footer_columns.push_back(col3);

            FooterColumn col4; strcpy(col4.heading, "ADVERTISING SERVICES");
            col4.items.push_back("BANNER ADS"); col4.items.push_back("WEB, MOBILE & TABLET AD");
            col4.items.push_back("PRINT, RICH & MOBILE ADS"); col4.items.push_back("AD DESIGN, IMAGING");
            col4.items.push_back("BRANDING & CREATIVE");
            sec.footer_columns.push_back(col4);

            FooterColumn col5; strcpy(col5.heading, "TECHNOLOGY SERVICES");
            col5.items.push_back("CMS WEBSITE"); col5.items.push_back("SEO");
            col5.items.push_back("YAHOO RTML"); col5.items.push_back("ECOMMERCE WEBSITE");
            sec.footer_columns.push_back(col5);

            FooterColumn col6; strcpy(col6.heading, "PUBLISHING SERVICES");
            col6.items.push_back("TABLET PUBLISHING"); col6.items.push_back("IPAD PUBLISHING");
            col6.items.push_back("DESIGN & LAYOUT"); col6.items.push_back("PROOF READING");
            col6.items.push_back("HTML, XML & TAGGING"); col6.items.push_back("EPUB, EBOOK");
            sec.footer_columns.push_back(col6);

            contactSections.push_back(sec);
            pageY += 560;
        }

        // ========== COPYRIGHT BAR ==========
        {
            WebSection sec(sectionId++, SEC_COPYRIGHT_CONNECTOR);
            sec.name = "Copyright";
            sec.x_position = 0; sec.y_position = pageY;
            sec.width = PAGE_WIDTH; sec.height = 60; sec.z_index = 9;
            strcpy(sec.copyright_text, "Website under development.");
            strcpy(sec.copyright_subtext, "2025 OMNION. ALL RIGHTS RESERVED.");
            sec.copyright_bg_color = ImVec4(0.15f, 0.15f, 0.15f, 1.0f);
            sec.copyright_text_color = ImVec4(0.6f, 0.6f, 0.6f, 1.0f);
            sec.copyright_link_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            sec.copyright_bg_opacity = 1.0f;
            CopyrightLink link1; strcpy(link1.text, "Privacy Policy"); strcpy(link1.url, "#privacy"); link1.isBold = true;
            sec.copyright_links.push_back(link1);
            CopyrightLink link2; strcpy(link2.text, "Terms of Service"); strcpy(link2.url, "#terms"); link2.isBold = true;
            sec.copyright_links.push_back(link2);
            contactSections.push_back(sec);
        }

        contactPage.sections = contactSections;
        g_NormalPages.push_back(contactPage);
    }

    // Set current page to Home (Page 1)
    g_CurrentPageIndex = 0;
    g_NormalPageIndex = 0;

    g_SelectedSectionIndex = 0;
    if (!g_Sections.empty()) {
        g_Sections[0].selected = true;
    }

    printf("OMNiON Website created with %zu sections in Free Design Mode!\n", g_Sections.size());
    printf("Created %zu pages: Home, Premedia, Services, Packaging, Imaging\n", g_NormalPages.size());
}

// Load template from file
bool LoadTemplate(const std::string& filepath) {
    // Clear current sections and pages
    g_Sections.clear();
    g_NormalPages.clear();
    g_SelectedSectionIndex = -1;
    g_CurrentPageIndex = 0;

    // If using database, load from PostgreSQL
    if (g_UseDatabase && g_DBConnection) {
        // Extract template name from filepath or use directly
        std::string template_name = filepath;
        size_t lastSlash = filepath.find_last_of('/');
        if (lastSlash != std::string::npos) {
            template_name = filepath.substr(lastSlash + 1);
            size_t dotPos = template_name.find_last_of('.');
            if (dotPos != std::string::npos) {
                template_name = template_name.substr(0, dotPos);
            }
        }

        printf("[LoadTemplate] Searching for template: '%s'\n", template_name.c_str());

        // Get template ID
        std::string query = "SELECT id, project_name FROM templates WHERE template_name='" + SQLEscape(template_name) + "'";
        printf("[LoadTemplate] Query: %s\n", query.c_str());

        PGresult* result = PQexec(g_DBConnection, query.c_str());
        if (PQresultStatus(result) != PGRES_TUPLES_OK) {
            printf("[LoadTemplate] ERROR: Query failed: %s\n", PQerrorMessage(g_DBConnection));
            PQclear(result);
            return false;
        }

        int nrows = PQntuples(result);
        printf("[LoadTemplate] Query returned %d rows\n", nrows);

        if (nrows == 0) {
            printf("[LoadTemplate] ERROR: Template not found in database!\n");
            printf("[LoadTemplate] Listing all templates in database:\n");

            // Debug: List all templates
            PGresult* debug_result = PQexec(g_DBConnection, "SELECT template_name FROM templates ORDER BY id DESC LIMIT 10");
            if (PQresultStatus(debug_result) == PGRES_TUPLES_OK) {
                int debug_rows = PQntuples(debug_result);
                for (int i = 0; i < debug_rows; i++) {
                    printf("  - %s\n", PQgetvalue(debug_result, i, 0));
                }
            }
            PQclear(debug_result);

            PQclear(result);
            return false;
        }

        int template_id = atoi(PQgetvalue(result, 0, 0));
        g_ProjectName = PQgetisnull(result, 0, 1) ? "" : PQgetvalue(result, 0, 1);
        PQclear(result);

        // Check if this is a Figma template and if it's a Normal mode template
        query = "SELECT is_figma_template, figma_screenshot_path, figma_canvas_width, figma_canvas_height, is_normal_mode, free_design_mode FROM templates WHERE id=" + std::to_string(template_id);
        result = PQexec(g_DBConnection, query.c_str());
        bool isFigmaTemplate = false;
        bool isNormalModeTemplate = false;
        if (PQresultStatus(result) == PGRES_TUPLES_OK && PQntuples(result) > 0) {
            const char* figmaVal = PQgetvalue(result, 0, 0);
            isFigmaTemplate = (figmaVal && (figmaVal[0] == 't' || figmaVal[0] == 'T' || figmaVal[0] == '1'));

            // Check is_normal_mode column (index 4)
            if (!PQgetisnull(result, 0, 4)) {
                const char* normalVal = PQgetvalue(result, 0, 4);
                isNormalModeTemplate = (normalVal && (normalVal[0] == 't' || normalVal[0] == 'T' || normalVal[0] == '1'));
            }

            // Load free_design_mode (index 5)
            if (!PQgetisnull(result, 0, 5)) {
                const char* freeVal = PQgetvalue(result, 0, 5);
                g_FreeDesignMode = (freeVal && (freeVal[0] == 't' || freeVal[0] == 'T' || freeVal[0] == '1'));
            }

            if (isFigmaTemplate) {
                printf("[LoadTemplate] This is a %s template, loading...\n", isNormalModeTemplate ? "Normal mode" : "Figma");

                // Clear and setup Figma project
                g_FigmaProject = FigmaProject();
                g_FigmaProject.name = template_name;
                g_FigmaProject.screenshot_path = PQgetisnull(result, 0, 1) ? "" : PQgetvalue(result, 0, 1);
                g_FigmaProject.canvas_width = PQgetisnull(result, 0, 2) ? 1920 : atof(PQgetvalue(result, 0, 2));
                g_FigmaProject.canvas_height = PQgetisnull(result, 0, 3) ? 3000 : atof(PQgetvalue(result, 0, 3));
                PQclear(result);

                // Load screenshot texture
                if (!g_FigmaProject.screenshot_path.empty()) {
                    int w, h, n;
                    unsigned char* data = stbi_load(g_FigmaProject.screenshot_path.c_str(), &w, &h, &n, 4);
                    if (data) {
                        glGenTextures(1, &g_FigmaProject.screenshot_texture_id);
                        glBindTexture(GL_TEXTURE_2D, g_FigmaProject.screenshot_texture_id);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                        stbi_image_free(data);
                        printf("[LoadTemplate] Loaded Figma screenshot: %dx%d\n", w, h);
                    }
                }

                // Load figma_layers
                query = "SELECT layer_order, layer_type, name, x, y, width, height, text, font_size, opacity, image_path, bg_color, text_color, href, onclick_action, action_type, z_index, border_color, border_radius, border_width FROM figma_layers WHERE template_id=" + std::to_string(template_id) + " ORDER BY layer_order";
                result = PQexec(g_DBConnection, query.c_str());
                if (PQresultStatus(result) == PGRES_TUPLES_OK) {
                    int layerCount = PQntuples(result);
                    g_FigmaProject.layers.clear();

                    for (int i = 0; i < layerCount; i++) {
                        WebLayer layer;
                        layer.id = g_FigmaProject.next_layer_id++;
                        layer.type = (LayerType)atoi(PQgetvalue(result, i, 1));
                        layer.name = PQgetisnull(result, i, 2) ? "" : PQgetvalue(result, i, 2);
                        layer.x = atof(PQgetvalue(result, i, 3));
                        layer.y = atof(PQgetvalue(result, i, 4));
                        layer.width = atof(PQgetvalue(result, i, 5));
                        layer.height = atof(PQgetvalue(result, i, 6));
                        layer.text = PQgetisnull(result, i, 7) ? "" : PQgetvalue(result, i, 7);
                        layer.font_size = PQgetisnull(result, i, 8) ? 16 : atof(PQgetvalue(result, i, 8));
                        layer.opacity = PQgetisnull(result, i, 9) ? 1.0f : atof(PQgetvalue(result, i, 9));
                        layer.image_path = PQgetisnull(result, i, 10) ? "" : PQgetvalue(result, i, 10);

                        // Parse bg_color and text_color from rgba strings
                        std::string bgColorStr = PQgetisnull(result, i, 11) ? "" : PQgetvalue(result, i, 11);
                        std::string textColorStr = PQgetisnull(result, i, 12) ? "" : PQgetvalue(result, i, 12);

                        // Load action data for interactive elements
                        layer.href = PQgetisnull(result, i, 13) ? "" : PQgetvalue(result, i, 13);
                        layer.onclick_action = PQgetisnull(result, i, 14) ? "" : PQgetvalue(result, i, 14);
                        layer.action_type = PQgetisnull(result, i, 15) ? "" : PQgetvalue(result, i, 15);

                        // Parse rgba(r,g,b,a) format
                        auto parseRGBA = [](const std::string& str, bool isBackground = false) -> ImVec4 {
                            if (str.empty()) {
                                // Default: transparent for backgrounds, black for text
                                return isBackground ? ImVec4(0, 0, 0, 0) : ImVec4(0, 0, 0, 1);
                            }
                            if (str.find("rgba(") == 0) {
                                int r = 0, g = 0, b = 0;
                                float a = 1.0f;
                                if (sscanf(str.c_str(), "rgba(%d,%d,%d,%f)", &r, &g, &b, &a) >= 3) {
                                    return ImVec4(r / 255.0f, g / 255.0f, b / 255.0f, a);
                                }
                            }
                            if (str.find("rgb(") == 0) {
                                int r = 0, g = 0, b = 0;
                                if (sscanf(str.c_str(), "rgb(%d,%d,%d)", &r, &g, &b) >= 3) {
                                    return ImVec4(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f);
                                }
                            }
                            // Default: transparent for backgrounds, black for text
                            return isBackground ? ImVec4(0, 0, 0, 0) : ImVec4(0, 0, 0, 1);
                        };

                        layer.bg_color = parseRGBA(bgColorStr, true);  // true = is background
                        layer.text_color = parseRGBA(textColorStr, false);  // false = is text
                        layer.visible = true;
                        layer.locked = false;  // Make sure layers are editable
                        layer.selected = false;

                        // Load z_index, border_color, border_radius, border_width
                        layer.z_index = PQgetisnull(result, i, 16) ? 0 : atoi(PQgetvalue(result, i, 16));
                        std::string borderColorStr = PQgetisnull(result, i, 17) ? "" : PQgetvalue(result, i, 17);
                        layer.border_color = borderColorStr.empty() ? ImVec4(0, 0, 0, 1) : parseRGBA(borderColorStr, false);
                        layer.border_radius = PQgetisnull(result, i, 18) ? 0.0f : atof(PQgetvalue(result, i, 18));
                        layer.border_width = PQgetisnull(result, i, 19) ? 0.0f : atof(PQgetvalue(result, i, 19));

                        // Load image texture if exists
                        if (layer.type == LAYER_IMAGE && !layer.image_path.empty()) {
                            int w, h, n;
                            unsigned char* imgData = stbi_load(layer.image_path.c_str(), &w, &h, &n, 4);
                            if (imgData) {
                                glGenTextures(1, &layer.texture_id);
                                glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData);
                                stbi_image_free(imgData);
                            }
                        }

                        g_FigmaProject.layers.push_back(layer);
                    }

                    printf("[LoadTemplate] Loaded %d Figma layers\n", layerCount);
                }
                PQclear(result);

                // Check if this is a Normal mode template
                if (isNormalModeTemplate) {
                    // Check if sections exist in the sections table
                    std::string checkQuery = "SELECT COUNT(*) FROM sections WHERE template_id=" + std::to_string(template_id);
                    PGresult* checkResult = PQexec(g_DBConnection, checkQuery.c_str());
                    int sectionCount = 0;
                    if (PQresultStatus(checkResult) == PGRES_TUPLES_OK && PQntuples(checkResult) > 0) {
                        sectionCount = atoi(PQgetvalue(checkResult, 0, 0));
                    }
                    PQclear(checkResult);

                    if (sectionCount > 0) {
                        // Has sections - load from sections table
                        printf("[LoadTemplate] Normal mode template with %d sections, loading from sections table...\n", sectionCount);
                        // Don't return - fall through to sections loading below
                    } else if (!g_FigmaProject.layers.empty()) {
                        // No sections but has layers - convert layers to sections
                        printf("[LoadTemplate] Normal mode template with no sections but %zu layers, converting...\n", g_FigmaProject.layers.size());
                        ConvertLayersToSections();
                        g_FigmaMode = false;
                        g_SelectedLayerId = -1;

                        printf("\n========================================\n");
                        printf("[LoadTemplate] SUCCESS: Normal mode template '%s' loaded!\n", template_name.c_str());
                        printf("[LoadTemplate] Converted %zu layers to %zu sections\n", g_FigmaProject.layers.size(), g_Sections.size());
                        printf("========================================\n\n");
                        return true;
                    } else {
                        printf("[LoadTemplate] Normal mode template with no data!\n");
                        return false;
                    }
                } else {
                    // Switch to Figma mode
                    g_FigmaMode = true;
                    g_SelectedLayerId = -1;

                    printf("\n========================================\n");
                    printf("[LoadTemplate] SUCCESS: Figma template '%s' loaded!\n", template_name.c_str());
                    printf("[LoadTemplate] Canvas: %.0fx%.0f, Layers: %zu\n", g_FigmaProject.canvas_width, g_FigmaProject.canvas_height, g_FigmaProject.layers.size());
                    printf("========================================\n\n");

                    // Ensure imported buttons point to internal anchors
                    RewriteFigmaActionsToInternal();
                    return true;  // Return only for Figma templates
                }
            }
        }
        // Note: result was already cleared at line 3443 for figma_layers query

        // Load sections - MUST match column order in code below (for non-Figma templates)
        query = "SELECT "
                "id, template_id, section_order, type, name, section_id, height, y_position, "
                "title, subtitle, content, button_text, button_link, "
                "title_font_size, title_font_weight, subtitle_font_size, subtitle_font_weight, "
                "content_font_size, content_font_weight, button_font_size, button_font_weight, "
                "nav_font_size, nav_font_weight, "
                "title_color, subtitle_color, content_color, bg_color, text_color, "
                "accent_color, button_bg_color, button_text_color, "
                "nav_bg_color, nav_text_color, "
                "padding, text_align, card_width, card_height, card_spacing, card_padding, cards_per_row, heading_to_cards_spacing, "
                "background_image, background_image_data, section_image, section_image_data, "
                "use_bg_image, bg_overlay_opacity, "
                "section_width_percent, horizontal_align, use_manual_position, "
                "hero_animation_images, hero_animation_images_data, enable_hero_animation, hero_animation_speed, "
                "gallery_images, gallery_images_data, gallery_columns, gallery_spacing, "
                "logo_path, logo_data, logo_size, brand_text_position, "
                "animation_type, animation_duration, animation_delay, card_stagger_delay, "
                "interactive_data, layout_data, css_data, "
                // CONNECTOR COLUMNS (starting at column 69)
                "text_blocks_json, text_content_width, text_padding, "
                "bar_items_json, "
                "footer_columns_json, footer_heading_color, footer_subheading_color, "
                "footer_heading_size, footer_subheading_size, footer_heading_boldness, footer_subheading_boldness, "
                "footer_column_width, footer_item_spacing, "
                "connector_cards_json, connector_cards_per_row, connector_card_spacing, "
                "vertical_blocks_json, vertical_heading_color, vertical_desc_color, "
                "vertical_heading_size, vertical_desc_size, vertical_heading_boldness, vertical_desc_boldness, "
                "vertical_content_width, vertical_spacing, "
                // NAVBAR CONNECTOR COLUMNS (starting at column 94)
                "navbar_items_json, navbar_bg_color, navbar_hover_color, navbar_dropdown_color, navbar_text_color, "
                "navbar_height, navbar_padding_x, navbar_padding_y, navbar_spacing, navbar_rounding, "
                "navbar_font_scale, navbar_rounded, "
                // POSITION/SIZE COLUMNS (starting at column 106)
                "x_position, width, z_index, "
                // COPYRIGHT BAR CONNECTOR COLUMNS (starting at column 109)
                "copyright_text, copyright_subtext, copyright_links_json, "
                "copyright_bg_color, copyright_text_color, copyright_link_color, "
                "copyright_font_size, copyright_subtext_size, copyright_padding, copyright_bg_opacity, "
                // ARTICLE CARDS CONNECTOR COLUMNS (starting at column 119)
                "article_cards_json, article_cards_per_row, article_card_spacing, "
                // CONTACT FORM CONNECTOR COLUMNS (starting at column 122)
                "contact_form_fields_json, contact_form_title, contact_form_submit_text, "
                "contact_form_title_color, contact_form_input_bg, contact_form_input_text, "
                "contact_form_button_bg, contact_form_button_text, contact_form_button_border, "
                "contact_form_title_size, contact_form_input_height, contact_form_textarea_height, "
                "contact_form_button_width, contact_form_button_height, contact_form_spacing, "
                "contact_form_submit_action, contact_form_submit_target, "
                // SEARCH BAR CONNECTOR COLUMNS (starting at column 139)
                "search_placeholder, search_button_text, search_input_bg, search_input_border, "
                "search_input_text, search_button_bg, search_button_text_color, "
                "search_input_width, search_input_height, search_button_width, search_border_radius, "
                // MARGIN COLUMNS (starting at column 150)
                "margin_top, margin_right, margin_bottom, margin_left, "
                // ICON COLUMNS (starting at column 154)
                "icon_type, icon_size, icon_color, icon_stroke_width, "
                // SERVICE CARD COLUMNS (starting at column 158)
                "service_cards_json, service_cards_per_row, service_card_spacing, "
                // GLASS BAR COLUMNS (starting at column 161)
                "glass_bar_text, glass_bar_highlight, glass_bar_text_color, glass_bar_highlight_color, "
                "glass_bar_bg_color, glass_bar_opacity, glass_bar_border_radius, glass_bar_padding, "
                // HERO SECTION COLUMNS (starting at column 169)
                "hero_badge_text, hero_badge_icon_left, hero_badge_icon_right, "
                "hero_heading, hero_heading_accent, hero_description, "
                "hero_btn_primary_text, hero_btn_secondary_text, "
                "hero_btn_primary_action, hero_btn_primary_target, "
                "hero_btn_secondary_action, hero_btn_secondary_target, "
                "hero_feature_badges_json, hero_stats_json, "
                "hero_bg_color, hero_badge_bg, hero_badge_text_color, hero_badge_icon_color, "
                "hero_heading_color, hero_accent_color, hero_description_color, "
                "hero_btn_primary_bg, hero_btn_primary_text_color, "
                "hero_btn_secondary_bg, hero_btn_secondary_text_color, hero_btn_secondary_border, "
                "hero_btn_border_radius, hero_badge_border_radius, "
                // PAGE COLUMNS (starting at column 197)
                "page_index, page_name "
                "FROM sections WHERE template_id=" + std::to_string(template_id) + " ORDER BY page_index, section_order";
        result = PQexec(g_DBConnection, query.c_str());
        if (PQresultStatus(result) != PGRES_TUPLES_OK) {
            printf("Error loading sections: %s\n", PQerrorMessage(g_DBConnection));
            PQclear(result);
            return false;
        }

        int section_count = PQntuples(result);
        printf("[LoadTemplate] Loading %d sections\n", section_count);
        for (int row_num = 0; row_num < section_count; row_num++) {
            int type = atoi(PQgetvalue(result, row_num, 3));  // type column
            WebSection sec(g_NextSectionId++, (SectionType)type);

            sec.name = PQgetisnull(result, row_num, 4) ? "" : PQgetvalue(result, row_num, 4);
            sec.section_id = PQgetisnull(result, row_num, 5) ? "" : PQgetvalue(result, row_num, 5);
            sec.height = PQgetisnull(result, row_num, 6) ? 400 : atoi(PQgetvalue(result, row_num, 6));
            sec.y_position = PQgetisnull(result, row_num, 7) ? 0 : atof(PQgetvalue(result, row_num, 7));  // NEW
            sec.title = PQgetisnull(result, row_num, 8) ? "" : PQgetvalue(result, row_num, 8);
            sec.subtitle = PQgetisnull(result, row_num, 9) ? "" : PQgetvalue(result, row_num, 9);
            sec.content = PQgetisnull(result, row_num, 10) ? "" : PQgetvalue(result, row_num, 10);
            sec.button_text = PQgetisnull(result, row_num, 11) ? "" : PQgetvalue(result, row_num, 11);
            sec.button_link = PQgetisnull(result, row_num, 12) ? "" : PQgetvalue(result, row_num, 12);

            sec.title_font_size = PQgetisnull(result, row_num, 13) ? 42 : atoi(PQgetvalue(result, row_num, 13));
            sec.title_font_weight = PQgetisnull(result, row_num, 14) ? 700 : atoi(PQgetvalue(result, row_num, 14));
            sec.subtitle_font_size = PQgetisnull(result, row_num, 15) ? 20 : atoi(PQgetvalue(result, row_num, 15));
            sec.subtitle_font_weight = PQgetisnull(result, row_num, 16) ? 400 : atoi(PQgetvalue(result, row_num, 16));
            sec.content_font_size = PQgetisnull(result, row_num, 17) ? 16 : atoi(PQgetvalue(result, row_num, 17));
            sec.content_font_weight = PQgetisnull(result, row_num, 18) ? 400 : atoi(PQgetvalue(result, row_num, 18));
            sec.button_font_size = PQgetisnull(result, row_num, 19) ? 16 : atoi(PQgetvalue(result, row_num, 19));
            sec.button_font_weight = PQgetisnull(result, row_num, 20) ? 600 : atoi(PQgetvalue(result, row_num, 20));
            sec.nav_font_size = PQgetisnull(result, row_num, 21) ? 15 : atoi(PQgetvalue(result, row_num, 21));
            sec.nav_font_weight = PQgetisnull(result, row_num, 22) ? 500 : atoi(PQgetvalue(result, row_num, 22));

            sec.title_color = PQgetisnull(result, row_num, 23) ? ImVec4(0.1f, 0.1f, 0.1f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 23));
            sec.subtitle_color = PQgetisnull(result, row_num, 24) ? ImVec4(0.3f, 0.3f, 0.3f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 24));
            sec.content_color = PQgetisnull(result, row_num, 25) ? ImVec4(0.2f, 0.2f, 0.2f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 25));
            sec.bg_color = PQgetisnull(result, row_num, 26) ? ImVec4(1.0f, 1.0f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 26));
            sec.text_color = PQgetisnull(result, row_num, 27) ? ImVec4(0.1f, 0.1f, 0.1f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 27));
            sec.accent_color = PQgetisnull(result, row_num, 28) ? ImVec4(0.2f, 0.5f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 28));
            sec.button_bg_color = PQgetisnull(result, row_num, 29) ? ImVec4(0.2f, 0.5f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 29));
            sec.button_text_color = PQgetisnull(result, row_num, 30) ? ImVec4(1.0f, 1.0f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 30));
            sec.nav_bg_color = PQgetisnull(result, row_num, 31) ? ImVec4(1.0f, 1.0f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 31));
            sec.nav_text_color = PQgetisnull(result, row_num, 32) ? ImVec4(0.2f, 0.2f, 0.2f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 32));

            sec.padding = PQgetisnull(result, row_num, 33) ? 60 : atoi(PQgetvalue(result, row_num, 33));
            sec.text_align = PQgetisnull(result, row_num, 34) ? 1 : atoi(PQgetvalue(result, row_num, 34));

            // Apply modern card sizes for sections with card layouts
            // Type 3 (Services), 4 (Cards), 5 (Team), 6 (Pricing) typically have cards
            // Type 0 (Hero), 1 (Navbar), 10 (Footer) don't have cards
            if (type == SEC_SERVICES || type == SEC_CARDS || type == SEC_TEAM || type == SEC_PRICING) {
                sec.card_width = PQgetisnull(result, row_num, 35) ? 800 : atoi(PQgetvalue(result, row_num, 35));
                sec.card_height = PQgetisnull(result, row_num, 36) ? 1000 : atoi(PQgetvalue(result, row_num, 36));
                sec.card_spacing = PQgetisnull(result, row_num, 37) ? 40 : atoi(PQgetvalue(result, row_num, 37));
            } else {
                sec.card_width = PQgetisnull(result, row_num, 35) ? 300 : atoi(PQgetvalue(result, row_num, 35));
                sec.card_height = PQgetisnull(result, row_num, 36) ? 250 : atoi(PQgetvalue(result, row_num, 36));
                sec.card_spacing = PQgetisnull(result, row_num, 37) ? 20 : atoi(PQgetvalue(result, row_num, 37));
            }

            sec.card_padding = PQgetisnull(result, row_num, 38) ? 25 : atoi(PQgetvalue(result, row_num, 38));  // NEW
            sec.cards_per_row = PQgetisnull(result, row_num, 39) ? 3 : atoi(PQgetvalue(result, row_num, 39));
            sec.heading_to_cards_spacing = PQgetisnull(result, row_num, 40) ? 40 : atof(PQgetvalue(result, row_num, 40));  // NEW

            sec.background_image = PQgetisnull(result, row_num, 41) ? "" : PQgetvalue(result, row_num, 41);
            // column 42 = background_image_data (BYTEA)
            sec.section_image = PQgetisnull(result, row_num, 43) ? "" : PQgetvalue(result, row_num, 43);
            // column 44 = section_image_data (BYTEA)
            sec.use_bg_image = PQgetisnull(result, row_num, 45) ? false : (PQgetvalue(result, row_num, 45)[0] == 't');
            sec.bg_overlay_opacity = PQgetisnull(result, row_num, 46) ? 0.0f : atof(PQgetvalue(result, row_num, 46));

            // NEW WIDTH & POSITION FIELDS
            sec.section_width_percent = PQgetisnull(result, row_num, 47) ? 100.0f : atof(PQgetvalue(result, row_num, 47));
            sec.horizontal_align = PQgetisnull(result, row_num, 48) ? 0 : atoi(PQgetvalue(result, row_num, 48));
            sec.use_manual_position = PQgetisnull(result, row_num, 49) ? false : (PQgetvalue(result, row_num, 49)[0] == 't');

            // Load multi-image arrays (columns 50-59)
            // Hero Animation Images
            if (!PQgetisnull(result, row_num, 50)) {
                sec.hero_animation_images = ParsePostgresArray(PQgetvalue(result, row_num, 50));
                printf("Loaded %d hero animation image paths\n", (int)sec.hero_animation_images.size());
            }
            sec.enable_hero_animation = PQgetisnull(result, row_num, 52) ? false : (PQgetvalue(result, row_num, 52)[0] == 't');
            sec.hero_animation_speed = PQgetisnull(result, row_num, 53) ? 3.0f : atof(PQgetvalue(result, row_num, 53));

            // Gallery Images
            if (!PQgetisnull(result, row_num, 54)) {
                sec.gallery_images = ParsePostgresArray(PQgetvalue(result, row_num, 54));
                printf("Loaded %d gallery image paths\n", (int)sec.gallery_images.size());
            }
            sec.gallery_columns = PQgetisnull(result, row_num, 56) ? 3 : atoi(PQgetvalue(result, row_num, 56));
            sec.gallery_spacing = PQgetisnull(result, row_num, 57) ? 20.0f : atof(PQgetvalue(result, row_num, 57));

            // Logo
            sec.logo_path = PQgetisnull(result, row_num, 58) ? "" : PQgetvalue(result, row_num, 58);
            // column 59 = logo_data (BYTEA)
            sec.logo_size = PQgetisnull(result, row_num, 60) ? 50.0f : atof(PQgetvalue(result, row_num, 60));
            sec.brand_text_position = PQgetisnull(result, row_num, 61) ? 0 : atoi(PQgetvalue(result, row_num, 61));

            // FAST LOADING: Load from file paths instead of slow database BYTEA
            // Skip database image loading for performance - file loading is 10x faster
            if (!sec.background_image.empty()) {
                ImageTexture bgTex = LoadTexture(sec.background_image);
                sec.bg_texture_id = bgTex.id;
            }

            // FAST LOADING: Load from file paths instead of slow database BYTEA
            // Skip database image loading for performance - file loading is 10x faster
            if (!sec.section_image.empty()) {
                ImageTexture imgTex = LoadTexture(sec.section_image);
                sec.img_texture_id = imgTex.id;
            }

            // Load Hero Animation texture IDs from saved paths
            for (const auto& img_path : sec.hero_animation_images) {
                ImageTexture tex = LoadTexture(img_path);
                sec.hero_animation_texture_ids.push_back(tex.id);
            }

            // Load Gallery texture IDs from saved paths
            for (const auto& img_path : sec.gallery_images) {
                ImageTexture tex = LoadTexture(img_path);
                sec.gallery_texture_ids.push_back(tex.id);
            }

            // Load Logo texture
            if (!sec.logo_path.empty()) {
                ImageTexture tex = LoadTexture(sec.logo_path);
                sec.logo_texture_id = tex.id;
            }

            // Animation settings
            sec.animation_type = PQgetisnull(result, row_num, 62) ? ANIM_NONE : (AnimationType)atoi(PQgetvalue(result, row_num, 62));
            sec.animation_duration = PQgetisnull(result, row_num, 63) ? 1.0f : atof(PQgetvalue(result, row_num, 63));
            sec.animation_delay = PQgetisnull(result, row_num, 64) ? 0.0f : atof(PQgetvalue(result, row_num, 64));
            sec.card_stagger_delay = PQgetisnull(result, row_num, 65) ? 0.3f : atof(PQgetvalue(result, row_num, 65));

            // Parse CSS data from column 68 (css_data) - 0-based indexing
            if (!PQgetisnull(result, row_num, 68)) {
                std::string css_json = PQgetvalue(result, row_num, 68);
                if (!css_json.empty()) {
                    ParseCSSData(sec, css_json);
                }
            }

            // Parse interactive_data (card items) from column 66
            if (!PQgetisnull(result, row_num, 66)) {
                std::string interactive_json = PQgetvalue(result, row_num, 66);
                if (!interactive_json.empty() && interactive_json != "null") {
                    ParseInteractiveData(sec, interactive_json);
                }
            }

            // Parse layout_data (padding, flexbox, grid, positioning) from column 67
            if (!PQgetisnull(result, row_num, 67)) {
                std::string layout_json = PQgetvalue(result, row_num, 67);
                if (!layout_json.empty() && layout_json != "null") {
                    ParseLayoutData(sec, layout_json);
                }
            }

            // ==================== LOAD CONNECTOR DATA (columns 69+) ====================

            // TEXT CONNECTOR: columns 69, 70, 71
            if (!PQgetisnull(result, row_num, 69)) {
                std::string json = PQgetvalue(result, row_num, 69);
                if (!json.empty()) {
                    JsonToTextBlocks(json, sec.text_blocks);
                }
            }
            sec.text_content_width = PQgetisnull(result, row_num, 70) ? 700.0f : atof(PQgetvalue(result, row_num, 70));
            sec.text_padding = PQgetisnull(result, row_num, 71) ? 30.0f : atof(PQgetvalue(result, row_num, 71));

            // BAR CONNECTOR: column 72
            if (!PQgetisnull(result, row_num, 72)) {
                std::string json = PQgetvalue(result, row_num, 72);
                if (!json.empty()) {
                    JsonToBarItems(json, sec.bar_items);
                }
            }

            // FOOTER CONNECTOR: columns 73-80
            if (!PQgetisnull(result, row_num, 73)) {
                std::string json = PQgetvalue(result, row_num, 73);
                if (!json.empty()) {
                    JsonToFooterColumns(json, sec.footer_columns);
                }
            }
            sec.footer_heading_color = PQgetisnull(result, row_num, 74) ? ImVec4(1,1,1,1) : SQLToColor(PQgetvalue(result, row_num, 74));
            sec.footer_subheading_color = PQgetisnull(result, row_num, 75) ? ImVec4(1,1,1,0.9f) : SQLToColor(PQgetvalue(result, row_num, 75));
            sec.footer_heading_size = PQgetisnull(result, row_num, 76) ? 1.3f : atof(PQgetvalue(result, row_num, 76));
            sec.footer_subheading_size = PQgetisnull(result, row_num, 77) ? 1.0f : atof(PQgetvalue(result, row_num, 77));
            sec.footer_heading_boldness = PQgetisnull(result, row_num, 78) ? 1.5f : atof(PQgetvalue(result, row_num, 78));
            sec.footer_subheading_boldness = PQgetisnull(result, row_num, 79) ? 0.0f : atof(PQgetvalue(result, row_num, 79));
            sec.footer_column_width = PQgetisnull(result, row_num, 80) ? 280.0f : atof(PQgetvalue(result, row_num, 80));
            sec.footer_item_spacing = PQgetisnull(result, row_num, 81) ? 8.0f : atof(PQgetvalue(result, row_num, 81));

            // CARD CONNECTOR: columns 82-84
            if (!PQgetisnull(result, row_num, 82)) {
                std::string json = PQgetvalue(result, row_num, 82);
                if (!json.empty()) {
                    JsonToConnectorCards(json, sec.connector_cards);
                    // Load textures for cards
                    for (auto& card : sec.connector_cards) {
                        if (!card.imagePath.empty()) {
                            ImageTexture tex = LoadTexture(card.imagePath);
                            card.textureID = tex.id;
                        }
                    }
                }
            }
            sec.connector_cards_per_row = PQgetisnull(result, row_num, 83) ? 3 : atoi(PQgetvalue(result, row_num, 83));
            sec.connector_card_spacing = PQgetisnull(result, row_num, 84) ? 20.0f : atof(PQgetvalue(result, row_num, 84));

            // VERTICAL CONNECTOR: columns 85-93
            if (!PQgetisnull(result, row_num, 85)) {
                std::string json = PQgetvalue(result, row_num, 85);
                if (!json.empty()) {
                    JsonToVerticalBlocks(json, sec.vertical_blocks);
                    // Load textures for image blocks
                    for (auto& block : sec.vertical_blocks) {
                        if (block.type == 2 && !block.imagePath.empty()) {
                            ImageTexture tex = LoadTexture(block.imagePath);
                            block.textureID = tex.id;
                        }
                    }
                }
            }
            sec.vertical_heading_color = PQgetisnull(result, row_num, 86) ? ImVec4(0.1f,0.1f,0.1f,1) : SQLToColor(PQgetvalue(result, row_num, 86));
            sec.vertical_desc_color = PQgetisnull(result, row_num, 87) ? ImVec4(0.3f,0.3f,0.3f,1) : SQLToColor(PQgetvalue(result, row_num, 87));
            sec.vertical_heading_size = PQgetisnull(result, row_num, 88) ? 1.2f : atof(PQgetvalue(result, row_num, 88));
            sec.vertical_desc_size = PQgetisnull(result, row_num, 89) ? 1.0f : atof(PQgetvalue(result, row_num, 89));
            sec.vertical_heading_boldness = PQgetisnull(result, row_num, 90) ? 1.5f : atof(PQgetvalue(result, row_num, 90));
            sec.vertical_desc_boldness = PQgetisnull(result, row_num, 91) ? 0.0f : atof(PQgetvalue(result, row_num, 91));
            sec.vertical_content_width = PQgetisnull(result, row_num, 92) ? 500.0f : atof(PQgetvalue(result, row_num, 92));
            sec.vertical_spacing = PQgetisnull(result, row_num, 93) ? 15.0f : atof(PQgetvalue(result, row_num, 93));

            // NAVBAR CONNECTOR: columns 94-105
            if (!PQgetisnull(result, row_num, 94)) {
                std::string json = PQgetvalue(result, row_num, 94);
                if (!json.empty()) {
                    JsonToNavbarItems(json, sec.navbar_items);
                }
            }
            sec.navbar_bg_color = PQgetisnull(result, row_num, 95) ? ImVec4(0.12f,0.12f,0.12f,1) : SQLToColor(PQgetvalue(result, row_num, 95));
            sec.navbar_hover_color = PQgetisnull(result, row_num, 96) ? ImVec4(0.26f,0.26f,0.26f,1) : SQLToColor(PQgetvalue(result, row_num, 96));
            sec.navbar_dropdown_color = PQgetisnull(result, row_num, 97) ? ImVec4(0.18f,0.18f,0.18f,1) : SQLToColor(PQgetvalue(result, row_num, 97));
            sec.navbar_text_color = PQgetisnull(result, row_num, 98) ? ImVec4(1,1,1,1) : SQLToColor(PQgetvalue(result, row_num, 98));
            sec.navbar_height = PQgetisnull(result, row_num, 99) ? 42.0f : atof(PQgetvalue(result, row_num, 99));
            sec.navbar_padding_x = PQgetisnull(result, row_num, 100) ? 10.0f : atof(PQgetvalue(result, row_num, 100));
            sec.navbar_padding_y = PQgetisnull(result, row_num, 101) ? 8.0f : atof(PQgetvalue(result, row_num, 101));
            sec.navbar_spacing = PQgetisnull(result, row_num, 102) ? 18.0f : atof(PQgetvalue(result, row_num, 102));
            sec.navbar_rounding = PQgetisnull(result, row_num, 103) ? 4.0f : atof(PQgetvalue(result, row_num, 103));
            sec.navbar_font_scale = PQgetisnull(result, row_num, 104) ? 1.0f : atof(PQgetvalue(result, row_num, 104));
            sec.navbar_rounded = PQgetisnull(result, row_num, 105) ? true : (PQgetvalue(result, row_num, 105)[0] == 't');

            // POSITION/SIZE COLUMNS (columns 106-108)
            sec.x_position = PQgetisnull(result, row_num, 106) ? 0.0f : atof(PQgetvalue(result, row_num, 106));
            sec.width = PQgetisnull(result, row_num, 107) ? 800.0f : atof(PQgetvalue(result, row_num, 107));
            sec.z_index = PQgetisnull(result, row_num, 108) ? 0 : atoi(PQgetvalue(result, row_num, 108));

            // COPYRIGHT BAR CONNECTOR: columns 109-118
            if (!PQgetisnull(result, row_num, 109)) {
                strncpy(sec.copyright_text, PQgetvalue(result, row_num, 109), sizeof(sec.copyright_text)-1);
            }
            if (!PQgetisnull(result, row_num, 110)) {
                strncpy(sec.copyright_subtext, PQgetvalue(result, row_num, 110), sizeof(sec.copyright_subtext)-1);
            }
            if (!PQgetisnull(result, row_num, 111)) {
                std::string json = PQgetvalue(result, row_num, 111);
                if (!json.empty()) {
                    JsonToCopyrightLinks(json, sec.copyright_links);
                }
            }
            sec.copyright_bg_color = PQgetisnull(result, row_num, 112) ? ImVec4(0.18f,0.18f,0.18f,1) : SQLToColor(PQgetvalue(result, row_num, 112));
            sec.copyright_text_color = PQgetisnull(result, row_num, 113) ? ImVec4(0.7f,0.7f,0.7f,1) : SQLToColor(PQgetvalue(result, row_num, 113));
            sec.copyright_link_color = PQgetisnull(result, row_num, 114) ? ImVec4(0.9f,0.9f,0.9f,1) : SQLToColor(PQgetvalue(result, row_num, 114));
            sec.copyright_font_size = PQgetisnull(result, row_num, 115) ? 11.0f : atof(PQgetvalue(result, row_num, 115));
            sec.copyright_subtext_size = PQgetisnull(result, row_num, 116) ? 10.0f : atof(PQgetvalue(result, row_num, 116));
            sec.copyright_padding = PQgetisnull(result, row_num, 117) ? 15.0f : atof(PQgetvalue(result, row_num, 117));
            sec.copyright_bg_opacity = PQgetisnull(result, row_num, 118) ? 1.0f : atof(PQgetvalue(result, row_num, 118));

            // ARTICLE CARDS CONNECTOR: columns 119-121
            if (!PQgetisnull(result, row_num, 119)) {
                std::string json = PQgetvalue(result, row_num, 119);
                if (!json.empty()) {
                    JsonToArticleCards(json, sec.article_cards);
                }
            }
            sec.article_cards_per_row = PQgetisnull(result, row_num, 120) ? 2 : atoi(PQgetvalue(result, row_num, 120));
            sec.article_card_spacing = PQgetisnull(result, row_num, 121) ? 20.0f : atof(PQgetvalue(result, row_num, 121));

            // CONTACT FORM CONNECTOR: columns 122-138
            if (!PQgetisnull(result, row_num, 122)) {
                std::string json = PQgetvalue(result, row_num, 122);
                if (!json.empty()) {
                    JsonToContactFormFields(json, sec.contact_form_fields);
                }
            }
            if (!PQgetisnull(result, row_num, 123)) {
                strncpy(sec.contact_form_title, PQgetvalue(result, row_num, 123), sizeof(sec.contact_form_title)-1);
            }
            if (!PQgetisnull(result, row_num, 124)) {
                strncpy(sec.contact_form_submit_text, PQgetvalue(result, row_num, 124), sizeof(sec.contact_form_submit_text)-1);
            }
            sec.contact_form_title_color = PQgetisnull(result, row_num, 125) ? ImVec4(0.1f,0.1f,0.1f,1) : SQLToColor(PQgetvalue(result, row_num, 125));
            sec.contact_form_input_bg = PQgetisnull(result, row_num, 126) ? ImVec4(0.95f,0.95f,0.95f,1) : SQLToColor(PQgetvalue(result, row_num, 126));
            sec.contact_form_input_text = PQgetisnull(result, row_num, 127) ? ImVec4(0.4f,0.4f,0.4f,1) : SQLToColor(PQgetvalue(result, row_num, 127));
            sec.contact_form_button_bg = PQgetisnull(result, row_num, 128) ? ImVec4(1,1,1,1) : SQLToColor(PQgetvalue(result, row_num, 128));
            sec.contact_form_button_text = PQgetisnull(result, row_num, 129) ? ImVec4(0.2f,0.6f,0.9f,1) : SQLToColor(PQgetvalue(result, row_num, 129));
            sec.contact_form_button_border = PQgetisnull(result, row_num, 130) ? ImVec4(0.2f,0.6f,0.9f,1) : SQLToColor(PQgetvalue(result, row_num, 130));
            sec.contact_form_title_size = PQgetisnull(result, row_num, 131) ? 1.3f : atof(PQgetvalue(result, row_num, 131));
            sec.contact_form_input_height = PQgetisnull(result, row_num, 132) ? 45.0f : atof(PQgetvalue(result, row_num, 132));
            sec.contact_form_textarea_height = PQgetisnull(result, row_num, 133) ? 150.0f : atof(PQgetvalue(result, row_num, 133));
            sec.contact_form_button_width = PQgetisnull(result, row_num, 134) ? 100.0f : atof(PQgetvalue(result, row_num, 134));
            sec.contact_form_button_height = PQgetisnull(result, row_num, 135) ? 40.0f : atof(PQgetvalue(result, row_num, 135));
            sec.contact_form_spacing = PQgetisnull(result, row_num, 136) ? 20.0f : atof(PQgetvalue(result, row_num, 136));
            sec.contact_form_submit_action = PQgetisnull(result, row_num, 137) ? 0 : atoi(PQgetvalue(result, row_num, 137));
            if (!PQgetisnull(result, row_num, 138)) {
                strncpy(sec.contact_form_submit_target, PQgetvalue(result, row_num, 138), sizeof(sec.contact_form_submit_target)-1);
            }

            // SEARCH BAR CONNECTOR: columns 139-149
            if (!PQgetisnull(result, row_num, 139)) {
                strncpy(sec.search_placeholder, PQgetvalue(result, row_num, 139), sizeof(sec.search_placeholder)-1);
            }
            if (!PQgetisnull(result, row_num, 140)) {
                strncpy(sec.search_button_text, PQgetvalue(result, row_num, 140), sizeof(sec.search_button_text)-1);
            }
            sec.search_input_bg = PQgetisnull(result, row_num, 141) ? ImVec4(1,1,1,1) : SQLToColor(PQgetvalue(result, row_num, 141));
            sec.search_input_border = PQgetisnull(result, row_num, 142) ? ImVec4(0.8f,0.8f,0.8f,1) : SQLToColor(PQgetvalue(result, row_num, 142));
            sec.search_input_text = PQgetisnull(result, row_num, 143) ? ImVec4(0.3f,0.3f,0.3f,1) : SQLToColor(PQgetvalue(result, row_num, 143));
            sec.search_button_bg = PQgetisnull(result, row_num, 144) ? ImVec4(0.91f,0.4f,0.1f,1) : SQLToColor(PQgetvalue(result, row_num, 144));
            sec.search_button_text_color = PQgetisnull(result, row_num, 145) ? ImVec4(1,1,1,1) : SQLToColor(PQgetvalue(result, row_num, 145));
            sec.search_input_width = PQgetisnull(result, row_num, 146) ? 400.0f : atof(PQgetvalue(result, row_num, 146));
            sec.search_input_height = PQgetisnull(result, row_num, 147) ? 42.0f : atof(PQgetvalue(result, row_num, 147));
            sec.search_button_width = PQgetisnull(result, row_num, 148) ? 90.0f : atof(PQgetvalue(result, row_num, 148));
            sec.search_border_radius = PQgetisnull(result, row_num, 149) ? 0.0f : atof(PQgetvalue(result, row_num, 149));

            // MARGIN COLUMNS (columns 150-153)
            sec.margin_top = PQgetisnull(result, row_num, 150) ? 10.0f : atof(PQgetvalue(result, row_num, 150));
            sec.margin_right = PQgetisnull(result, row_num, 151) ? 10.0f : atof(PQgetvalue(result, row_num, 151));
            sec.margin_bottom = PQgetisnull(result, row_num, 152) ? 10.0f : atof(PQgetvalue(result, row_num, 152));
            sec.margin_left = PQgetisnull(result, row_num, 153) ? 10.0f : atof(PQgetvalue(result, row_num, 153));

            // ICON COLUMNS (columns 154-157)
            sec.icon_type = PQgetisnull(result, row_num, 154) ? ICON_STAR : atoi(PQgetvalue(result, row_num, 154));
            sec.icon_size = PQgetisnull(result, row_num, 155) ? 48.0f : atof(PQgetvalue(result, row_num, 155));
            sec.icon_color = PQgetisnull(result, row_num, 156) ? ImVec4(0.2f, 0.2f, 0.4f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 156));
            sec.icon_stroke_width = PQgetisnull(result, row_num, 157) ? 2.0f : atof(PQgetvalue(result, row_num, 157));

            // SERVICE CARD COLUMNS (columns 158-160)
            if (!PQgetisnull(result, row_num, 158)) {
                sec.service_cards = ServiceCardsFromJson(PQgetvalue(result, row_num, 158));
            }
            sec.service_cards_per_row = PQgetisnull(result, row_num, 159) ? 3 : atoi(PQgetvalue(result, row_num, 159));
            sec.service_card_spacing = PQgetisnull(result, row_num, 160) ? 20.0f : atof(PQgetvalue(result, row_num, 160));

            // GLASS BAR COLUMNS (columns 161-168)
            if (!PQgetisnull(result, row_num, 161)) {
                strncpy(sec.glass_bar_text, PQgetvalue(result, row_num, 161), sizeof(sec.glass_bar_text) - 1);
            }
            if (!PQgetisnull(result, row_num, 162)) {
                strncpy(sec.glass_bar_highlight, PQgetvalue(result, row_num, 162), sizeof(sec.glass_bar_highlight) - 1);
            }
            sec.glass_bar_text_color = PQgetisnull(result, row_num, 163) ? ImVec4(0.2f, 0.2f, 0.25f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 163));
            sec.glass_bar_highlight_color = PQgetisnull(result, row_num, 164) ? ImVec4(0.3f, 0.5f, 0.9f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 164));
            sec.glass_bar_bg_color = PQgetisnull(result, row_num, 165) ? ImVec4(0.95f, 0.95f, 0.98f, 0.9f) : SQLToColor(PQgetvalue(result, row_num, 165));
            sec.glass_bar_opacity = PQgetisnull(result, row_num, 166) ? 0.9f : atof(PQgetvalue(result, row_num, 166));
            sec.glass_bar_border_radius = PQgetisnull(result, row_num, 167) ? 30.0f : atof(PQgetvalue(result, row_num, 167));
            sec.glass_bar_padding = PQgetisnull(result, row_num, 168) ? 20.0f : atof(PQgetvalue(result, row_num, 168));

            // HERO SECTION COLUMNS (columns 169-196)
            if (!PQgetisnull(result, row_num, 169)) {
                strncpy(sec.hero_badge_text, PQgetvalue(result, row_num, 169), sizeof(sec.hero_badge_text) - 1);
            }
            sec.hero_badge_icon_left = PQgetisnull(result, row_num, 170) ? ICON_STAR : atoi(PQgetvalue(result, row_num, 170));
            sec.hero_badge_icon_right = PQgetisnull(result, row_num, 171) ? ICON_STAR : atoi(PQgetvalue(result, row_num, 171));
            if (!PQgetisnull(result, row_num, 172)) {
                strncpy(sec.hero_heading, PQgetvalue(result, row_num, 172), sizeof(sec.hero_heading) - 1);
            }
            if (!PQgetisnull(result, row_num, 173)) {
                strncpy(sec.hero_heading_accent, PQgetvalue(result, row_num, 173), sizeof(sec.hero_heading_accent) - 1);
            }
            if (!PQgetisnull(result, row_num, 174)) {
                strncpy(sec.hero_description, PQgetvalue(result, row_num, 174), sizeof(sec.hero_description) - 1);
            }
            if (!PQgetisnull(result, row_num, 175)) {
                strncpy(sec.hero_btn_primary_text, PQgetvalue(result, row_num, 175), sizeof(sec.hero_btn_primary_text) - 1);
            }
            if (!PQgetisnull(result, row_num, 176)) {
                strncpy(sec.hero_btn_secondary_text, PQgetvalue(result, row_num, 176), sizeof(sec.hero_btn_secondary_text) - 1);
            }
            sec.hero_btn_primary_action = PQgetisnull(result, row_num, 177) ? 0 : atoi(PQgetvalue(result, row_num, 177));
            if (!PQgetisnull(result, row_num, 178)) {
                strncpy(sec.hero_btn_primary_target, PQgetvalue(result, row_num, 178), sizeof(sec.hero_btn_primary_target) - 1);
            }
            sec.hero_btn_secondary_action = PQgetisnull(result, row_num, 179) ? 0 : atoi(PQgetvalue(result, row_num, 179));
            if (!PQgetisnull(result, row_num, 180)) {
                strncpy(sec.hero_btn_secondary_target, PQgetvalue(result, row_num, 180), sizeof(sec.hero_btn_secondary_target) - 1);
            }
            if (!PQgetisnull(result, row_num, 181)) {
                sec.hero_feature_badges = HeroFeatureBadgesFromJson(PQgetvalue(result, row_num, 181));
            }
            if (!PQgetisnull(result, row_num, 182)) {
                sec.hero_stats = HeroStatsFromJson(PQgetvalue(result, row_num, 182));
            }
            sec.hero_bg_color = PQgetisnull(result, row_num, 183) ? ImVec4(0.98f, 0.98f, 0.99f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 183));
            sec.hero_badge_bg = PQgetisnull(result, row_num, 184) ? ImVec4(1.0f, 1.0f, 1.0f, 0.95f) : SQLToColor(PQgetvalue(result, row_num, 184));
            sec.hero_badge_text_color = PQgetisnull(result, row_num, 185) ? ImVec4(0.2f, 0.2f, 0.25f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 185));
            sec.hero_badge_icon_color = PQgetisnull(result, row_num, 186) ? ImVec4(0.95f, 0.5f, 0.2f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 186));
            sec.hero_heading_color = PQgetisnull(result, row_num, 187) ? ImVec4(0.1f, 0.1f, 0.15f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 187));
            sec.hero_accent_color = PQgetisnull(result, row_num, 188) ? ImVec4(0.95f, 0.5f, 0.2f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 188));
            sec.hero_description_color = PQgetisnull(result, row_num, 189) ? ImVec4(0.4f, 0.4f, 0.45f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 189));
            sec.hero_btn_primary_bg = PQgetisnull(result, row_num, 190) ? ImVec4(0.95f, 0.5f, 0.2f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 190));
            sec.hero_btn_primary_text_color = PQgetisnull(result, row_num, 191) ? ImVec4(1.0f, 1.0f, 1.0f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 191));
            sec.hero_btn_secondary_bg = PQgetisnull(result, row_num, 192) ? ImVec4(1.0f, 1.0f, 1.0f, 0.0f) : SQLToColor(PQgetvalue(result, row_num, 192));
            sec.hero_btn_secondary_text_color = PQgetisnull(result, row_num, 193) ? ImVec4(0.1f, 0.1f, 0.15f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 193));
            sec.hero_btn_secondary_border = PQgetisnull(result, row_num, 194) ? ImVec4(0.8f, 0.8f, 0.85f, 1.0f) : SQLToColor(PQgetvalue(result, row_num, 194));
            sec.hero_btn_border_radius = PQgetisnull(result, row_num, 195) ? 30.0f : atof(PQgetvalue(result, row_num, 195));
            sec.hero_badge_border_radius = PQgetisnull(result, row_num, 196) ? 25.0f : atof(PQgetvalue(result, row_num, 196));

            // PAGE COLUMNS (columns 197-198)
            int pageIdx = PQgetisnull(result, row_num, 197) ? 0 : atoi(PQgetvalue(result, row_num, 197));
            std::string pageName = PQgetisnull(result, row_num, 198) ? "Home" : PQgetvalue(result, row_num, 198);

            // Ensure g_NormalPages has enough pages
            while ((int)g_NormalPages.size() <= pageIdx) {
                g_NormalPages.push_back(NormalModePage("Page " + std::to_string(g_NormalPages.size() + 1)));
            }
            // Set the correct page name
            g_NormalPages[pageIdx].name = pageName;
            // Add section to the correct page
            g_NormalPages[pageIdx].sections.push_back(sec);
        }
        PQclear(result);

        // Set g_Sections to the first page's sections
        if (!g_NormalPages.empty()) {
            g_Sections = g_NormalPages[0].sections;
            g_CurrentPageIndex = 0;
        }

        // Select first section if any
        if (!g_Sections.empty()) {
            g_SelectedSectionIndex = 0;
            g_Sections[0].selected = true;
        }

        // Ensure we're in Normal mode (not Figma mode) for section-based templates
        g_FigmaMode = false;

        printf("\n========================================\n");
        printf("[LoadTemplate] SUCCESS: Template '%s' loaded from database\n", template_name.c_str());
        printf("[LoadTemplate] Loaded %zu pages:\n", g_NormalPages.size());
        for (size_t p = 0; p < g_NormalPages.size(); p++) {
            printf("  Page %zu: %s (%zu sections)\n", p+1, g_NormalPages[p].name.c_str(), g_NormalPages[p].sections.size());
        }
        printf("========================================\n\n");
        return true;
    }

    // Otherwise, load from JSON file
    std::ifstream file(filepath);
    if (!file.is_open()) return false;

    std::string line;
    WebSection* currentSection = nullptr;
    bool inSectionsArray = false;
    bool inSection = false;

    while (std::getline(file, line)) {
        // Check if we're in the sections array
        if (line.find("\"sections\"") != std::string::npos) {
            inSectionsArray = true;
            continue;
        }

        // Start of a new section object
        if (inSectionsArray && line.find("{") != std::string::npos && !inSection) {
            inSection = true;
            continue;
        }

        // End of a section object
        if (inSection && line.find("}") != std::string::npos) {
            if (currentSection) {
                g_Sections.push_back(*currentSection);
                delete currentSection;
                currentSection = nullptr;
            }
            inSection = false;
            continue;
        }

        // Parse section properties
        if (inSection) {
            if (line.find("\"type\":") != std::string::npos) {
                int type = (int)ExtractJsonNumber(line);
                currentSection = new WebSection(g_NextSectionId++, (SectionType)type);
            }
            else if (currentSection) {
                if (line.find("\"name\":") != std::string::npos) {
                    currentSection->name = ExtractJsonString(line);
                }
                else if (line.find("\"section_id\":") != std::string::npos) {
                    currentSection->section_id = ExtractJsonString(line);
                }
                else if (line.find("\"height\":") != std::string::npos) {
                    currentSection->height = ExtractJsonNumber(line);
                }
                else if (line.find("\"title\":") != std::string::npos) {
                    currentSection->title = ExtractJsonString(line);
                }
                else if (line.find("\"subtitle\":") != std::string::npos) {
                    currentSection->subtitle = ExtractJsonString(line);
                }
                else if (line.find("\"content\":") != std::string::npos) {
                    currentSection->content = ExtractJsonString(line);
                }
                else if (line.find("\"button_text\":") != std::string::npos) {
                    currentSection->button_text = ExtractJsonString(line);
                }
                else if (line.find("\"button_link\":") != std::string::npos) {
                    currentSection->button_link = ExtractJsonString(line);
                }
                else if (line.find("\"title_font_size\":") != std::string::npos) {
                    currentSection->title_font_size = ExtractJsonNumber(line);
                }
                else if (line.find("\"subtitle_font_size\":") != std::string::npos) {
                    currentSection->subtitle_font_size = ExtractJsonNumber(line);
                }
                else if (line.find("\"content_font_size\":") != std::string::npos) {
                    currentSection->content_font_size = ExtractJsonNumber(line);
                }
                else if (line.find("\"title_font_weight\":") != std::string::npos) {
                    currentSection->title_font_weight = ExtractJsonNumber(line);
                }
                else if (line.find("\"subtitle_font_weight\":") != std::string::npos) {
                    currentSection->subtitle_font_weight = ExtractJsonNumber(line);
                }
                else if (line.find("\"content_font_weight\":") != std::string::npos) {
                    currentSection->content_font_weight = ExtractJsonNumber(line);
                }
                else if (line.find("\"title_color\":") != std::string::npos) {
                    currentSection->title_color = ExtractJsonColor(line);
                }
                else if (line.find("\"subtitle_color\":") != std::string::npos) {
                    currentSection->subtitle_color = ExtractJsonColor(line);
                }
                else if (line.find("\"content_color\":") != std::string::npos) {
                    currentSection->content_color = ExtractJsonColor(line);
                }
                else if (line.find("\"bg_color\":") != std::string::npos) {
                    currentSection->bg_color = ExtractJsonColor(line);
                }
                else if (line.find("\"text_color\":") != std::string::npos) {
                    currentSection->text_color = ExtractJsonColor(line);
                }
                else if (line.find("\"accent_color\":") != std::string::npos) {
                    currentSection->accent_color = ExtractJsonColor(line);
                }
                else if (line.find("\"button_bg_color\":") != std::string::npos) {
                    currentSection->button_bg_color = ExtractJsonColor(line);
                }
                else if (line.find("\"button_text_color\":") != std::string::npos) {
                    currentSection->button_text_color = ExtractJsonColor(line);
                }
                else if (line.find("\"button_font_size\":") != std::string::npos) {
                    currentSection->button_font_size = ExtractJsonNumber(line);
                }
                else if (line.find("\"button_font_weight\":") != std::string::npos) {
                    currentSection->button_font_weight = ExtractJsonNumber(line);
                }
                else if (line.find("\"padding\":") != std::string::npos) {
                    currentSection->padding = ExtractJsonNumber(line);
                }
                else if (line.find("\"text_align\":") != std::string::npos) {
                    currentSection->text_align = (int)ExtractJsonNumber(line);
                }
                else if (line.find("\"nav_font_size\":") != std::string::npos) {
                    currentSection->nav_font_size = ExtractJsonNumber(line);
                }
                else if (line.find("\"nav_font_weight\":") != std::string::npos) {
                    currentSection->nav_font_weight = ExtractJsonNumber(line);
                }
                else if (line.find("\"card_width\":") != std::string::npos) {
                    currentSection->card_width = ExtractJsonNumber(line);
                }
                else if (line.find("\"card_height\":") != std::string::npos) {
                    currentSection->card_height = ExtractJsonNumber(line);
                }
                else if (line.find("\"card_spacing\":") != std::string::npos) {
                    currentSection->card_spacing = ExtractJsonNumber(line);
                }
                else if (line.find("\"cards_per_row\":") != std::string::npos) {
                    currentSection->cards_per_row = (int)ExtractJsonNumber(line);
                }
                else if (line.find("\"background_image\":") != std::string::npos) {
                    currentSection->background_image = ExtractJsonString(line);
                }
                else if (line.find("\"section_image\":") != std::string::npos) {
                    currentSection->section_image = ExtractJsonString(line);
                }
                else if (line.find("\"use_bg_image\":") != std::string::npos) {
                    currentSection->use_bg_image = (line.find("true") != std::string::npos);
                }
                else if (line.find("\"bg_overlay_opacity\":") != std::string::npos) {
                    currentSection->bg_overlay_opacity = ExtractJsonNumber(line);
                }
            }
        }

        // Check for project name
        if (line.find("\"project_name\":") != std::string::npos && !inSection) {
            g_ProjectName = ExtractJsonString(line);
        }
    }

    file.close();

    // Load textures for all sections with images
    for (auto& sec : g_Sections) {
        if (!sec.background_image.empty()) {
            ImageTexture bgTex = LoadTexture(sec.background_image);
            sec.bg_texture_id = bgTex.id;
        }
        if (!sec.section_image.empty()) {
            ImageTexture imgTex = LoadTexture(sec.section_image);
            sec.img_texture_id = imgTex.id;
        }
    }

    // Select first section if any
    if (!g_Sections.empty()) {
        g_SelectedSectionIndex = 0;
        g_Sections[0].selected = true;
    }

    return !g_Sections.empty();
}

// ============================================================================
// URL IMPORT FUNCTIONS
// ============================================================================
bool ValidateURL(const std::string& url);
std::string FetchHTML(const std::string& url);
std::string CaptureScreenshot(const std::string& url);
ColorPalette ExtractColors(const std::string& screenshot_path);
std::vector<DetectedSection> ParseAndIdentifySections(const std::string& html, const ColorPalette& colors);
SectionType MapToSectionType(const std::string& detected_type);
std::string DownloadImage(const std::string& image_url, const std::string& base_url);
WebSection CreateWebSection(const DetectedSection& detected, int section_id);
bool ImportFromURL(const std::string& url, int timeout_seconds = 300);

// Local Download Import Functions
bool DownloadWebsiteLocally(const std::string& url, const std::string& output_dir);
bool ParseLocalHTMLFile(const std::string& html_path, std::vector<WebSection>& sections);
std::map<std::string, std::string> ParseLocalCSSFile(const std::string& css_path);
bool ImportFromLocalDownload(const std::string& url);

// Figma-style Import Functions
bool ImportFigmaLayers(const std::string& url);
void RenderFigmaCanvas();
void RenderFigmaLayersPanel();
void RenderFigmaPropertiesPanel();
bool SaveAsImGuiTemplate(const std::string& templateName);  // Forward declaration
void ConvertLayersToSections();  // Forward declaration
WebLayer* GetLayerById(int id);
void SelectLayer(int id);
void DeselectAllLayers();

// ============================================================================
// FILE DIALOGS
// ============================================================================
std::string OpenFileDialog(const char* title) {
    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
        "osascript -e 'try' -e 'POSIX path of (choose file with prompt \"%s\")' -e 'end try' 2>/dev/null", title);
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "";
    char buffer[1024];
    std::string result;
    if (fgets(buffer, sizeof(buffer), pipe)) {
        result = buffer;
        if (!result.empty() && result.back() == '\n') result.pop_back();
    }
    pclose(pipe);
    return result;
}

std::string ChooseFolderDialog(const char* title) {
    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
        "osascript -e 'try' -e 'POSIX path of (choose folder with prompt \"%s\")' -e 'end try' 2>/dev/null", title);
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "";
    char buffer[1024];
    std::string result;
    if (fgets(buffer, sizeof(buffer), pipe)) {
        result = buffer;
        if (!result.empty() && result.back() == '\n') result.pop_back();
    }
    pclose(pipe);
    return result;
}

// Open multiple file dialog (macOS)
std::vector<std::string> OpenMultipleFilesDialog() {
    std::vector<std::string> files;
    char buffer[8192] = {0};

    // AppleScript to select multiple files and return paths separated by newlines
    const char* script =
        "osascript -e '"
        "set theFiles to choose file with prompt \"Select image files\" with multiple selections allowed' "
        "-e 'set output to \"\"' "
        "-e 'repeat with aFile in theFiles' "
        "-e 'set output to output & POSIX path of aFile & linefeed' "
        "-e 'end repeat' "
        "-e 'return output' "
        "2>/dev/null";

    FILE* fp = popen(script, "r");
    if (fp) {
        // Read all output
        std::string allPaths;
        while (fgets(buffer, sizeof(buffer), fp) != nullptr) {
            allPaths += buffer;
        }
        pclose(fp);

        // Split by newline
        std::istringstream stream(allPaths);
        std::string line;
        while (std::getline(stream, line)) {
            // Remove any trailing whitespace or carriage returns
            while (!line.empty() && (line.back() == '\n' || line.back() == '\r' || line.back() == ' ')) {
                line.pop_back();
            }
            if (!line.empty()) {
                files.push_back(line);
            }
        }
    }
    return files;
}

// ============================================================================
// URL IMPORT IMPLEMENTATION
// ============================================================================

// Validate URL format (very lenient)
bool ValidateURL(const std::string& url) {
    if (url.empty()) return false;

    // Remove leading/trailing whitespace for checking
    std::string cleaned = url;
    size_t start = cleaned.find_first_not_of(" \t\n\r");
    size_t end = cleaned.find_last_not_of(" \t\n\r");
    if (start == std::string::npos) return false;
    cleaned = cleaned.substr(start, end - start + 1);

    // Must be at least 10 characters (http://a.b is minimum)
    if (cleaned.length() < 10) return false;

    // Must contain http:// or https:// somewhere near the beginning
    bool has_http = (cleaned.find("http://") != std::string::npos);
    bool has_https = (cleaned.find("https://") != std::string::npos);
    if (!has_http && !has_https) return false;

    // Must contain at least one dot (for domain)
    if (cleaned.find('.') == std::string::npos) return false;

    // Passed all checks
    return true;
}

// Fetch HTML content from URL
std::string FetchHTML(const std::string& url) {
    std::string temp_file = "/tmp/imgui_import_" + std::to_string(time(nullptr)) + ".html";
    std::string cmd = "curl -L -s --max-time 30 \"" + url + "\" -o \"" + temp_file + "\" 2>/dev/null";

    if (system(cmd.c_str()) != 0) return "";

    std::ifstream file(temp_file);
    if (!file.is_open()) return "";

    std::string html((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();
    unlink(temp_file.c_str());

    return html;
}

// Capture screenshot of website (optional - requires Selenium)
std::string CaptureScreenshot(const std::string& url) {
    std::string output_path = "/tmp/imgui_screenshot_" + std::to_string(time(nullptr)) + ".png";

    // Create Python script for headless browser screenshot
    std::string python_script = "/tmp/capture_screenshot.py";
    std::ofstream script(python_script);
    script << "#!/usr/bin/env python3\n"
           << "import sys\n"
           << "try:\n"
           << "    from selenium import webdriver\n"
           << "    from selenium.webdriver.chrome.options import Options\n"
           << "    chrome_options = Options()\n"
           << "    chrome_options.add_argument('--headless')\n"
           << "    chrome_options.add_argument('--window-size=1920,1080')\n"
           << "    driver = webdriver.Chrome(options=chrome_options)\n"
           << "    driver.get(sys.argv[1])\n"
           << "    driver.save_screenshot(sys.argv[2])\n"
           << "    driver.quit()\n"
           << "except: sys.exit(1)\n";
    script.close();
    chmod(python_script.c_str(), 0755);

    std::string cmd = "python3 \"" + python_script + "\" \"" + url + "\" \"" + output_path + "\" 2>/dev/null";
    int result = system(cmd.c_str());
    unlink(python_script.c_str());

    return (result == 0 && access(output_path.c_str(), F_OK) == 0) ? output_path : "";
}

// Extract dominant colors from screenshot
ColorPalette ExtractColors(const std::string& screenshot_path) {
    ColorPalette palette;

    // Default palette
    palette.primary = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
    palette.secondary = ImVec4(0.56f, 0.27f, 0.68f, 1.0f);
    palette.accent = ImVec4(0.06f, 0.71f, 0.60f, 1.0f);
    palette.background = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    palette.text = ImVec4(0.12f, 0.15f, 0.22f, 1.0f);

    if (screenshot_path.empty()) return palette;

    // Create Python script for color extraction
    std::string python_script = "/tmp/extract_colors.py";
    std::ofstream script(python_script);
    script << "#!/usr/bin/env python3\n"
           << "from PIL import Image\n"
           << "import sys\n"
           << "from collections import Counter\n"
           << "img = Image.open(sys.argv[1]).convert('RGB')\n"
           << "img = img.resize((100, 100))\n"
           << "pixels = list(img.getdata())\n"
           << "counter = Counter(pixels)\n"
           << "colors = [c for c, cnt in counter.most_common(10) if 30 < sum(c)/3 < 225]\n"
           << "for r, g, b in colors[:5]: print(f'{r} {g} {b}')\n";
    script.close();
    chmod(python_script.c_str(), 0755);

    std::string cmd = "python3 \"" + python_script + "\" \"" + screenshot_path + "\" 2>/dev/null";
    FILE* pipe = popen(cmd.c_str(), "r");
    if (pipe) {
        std::vector<ImVec4> extracted;
        char buffer[256];
        while (fgets(buffer, sizeof(buffer), pipe)) {
            int r, g, b;
            if (sscanf(buffer, "%d %d %d", &r, &g, &b) == 3) {
                extracted.push_back(ImVec4(r/255.0f, g/255.0f, b/255.0f, 1.0f));
            }
        }
        pclose(pipe);

        if (extracted.size() >= 1) palette.primary = extracted[0];
        if (extracted.size() >= 2) palette.secondary = extracted[1];
        if (extracted.size() >= 3) palette.accent = extracted[2];
        if (extracted.size() >= 4) palette.background = extracted[3];
        if (extracted.size() >= 5) palette.text = extracted[4];
    }

    unlink(python_script.c_str());
    return palette;
}

// Parse HTML and identify website sections
std::vector<DetectedSection> ParseAndIdentifySections(const std::string& html, const ColorPalette& colors) {
    std::vector<DetectedSection> sections;

    // Simple pattern matching for common sections
    std::string html_lower = html;
    std::transform(html_lower.begin(), html_lower.end(), html_lower.begin(), ::tolower);

    // Detect Navbar
    if (html_lower.find("<nav") != std::string::npos || html_lower.find("class=\"nav") != std::string::npos) {
        DetectedSection nav;
        nav.type = "navbar";
        nav.colors = colors;
        nav.estimated_height = 70;
        sections.push_back(nav);
    }

    // Detect Hero
    if (html_lower.find("hero") != std::string::npos || html_lower.find("jumbotron") != std::string::npos) {
        DetectedSection hero;
        hero.type = "hero";
        hero.colors = colors;
        hero.estimated_height = 600;

        // Extract title from first h1
        size_t h1_start = html.find("<h1");
        if (h1_start != std::string::npos) {
            size_t content_start = html.find(">", h1_start) + 1;
            size_t content_end = html.find("</h1>", content_start);
            if (content_end != std::string::npos && content_end > content_start) {
                hero.title = html.substr(content_start, content_end - content_start);
                // Remove HTML tags from title
                size_t tag_pos;
                while ((tag_pos = hero.title.find("<")) != std::string::npos) {
                    size_t end_pos = hero.title.find(">", tag_pos);
                    if (end_pos != std::string::npos) {
                        hero.title.erase(tag_pos, end_pos - tag_pos + 1);
                    } else break;
                }
            }
        }

        sections.push_back(hero);
    }

    // Detect Cards/Services
    size_t card_count = 0;
    size_t pos = 0;
    while ((pos = html_lower.find("class=\"card", pos)) != std::string::npos) {
        card_count++;
        pos++;
    }
    if (card_count > 2) {
        DetectedSection cards;
        cards.type = "cards";
        cards.colors = colors;
        cards.estimated_height = 500;
        sections.push_back(cards);
    }

    // Detect Footer
    if (html_lower.find("<footer") != std::string::npos) {
        DetectedSection footer;
        footer.type = "footer";
        footer.colors = colors;
        footer.estimated_height = 200;
        sections.push_back(footer);
    }

    // If no sections detected, create defaults
    if (sections.empty()) {
        DetectedSection hero;
        hero.type = "hero";
        hero.title = "Imported Website";
        hero.subtitle = "Design imported from URL";
        hero.colors = colors;
        hero.estimated_height = 600;
        sections.push_back(hero);

        DetectedSection about;
        about.type = "about";
        about.colors = colors;
        about.estimated_height = 400;
        sections.push_back(about);
    }

    return sections;
}

// Map detected type to SectionType enum
SectionType MapToSectionType(const std::string& detected_type) {
    if (detected_type == "navbar") return SEC_NAVBAR;
    if (detected_type == "hero") return SEC_HERO;
    if (detected_type == "about") return SEC_ABOUT;
    if (detected_type == "services") return SEC_SERVICES;
    if (detected_type == "cards") return SEC_CARDS;
    if (detected_type == "features") return SEC_FEATURES;
    if (detected_type == "footer") return SEC_FOOTER;
    if (detected_type == "contact") return SEC_CONTACT;
    if (detected_type == "pricing") return SEC_PRICING;
    return SEC_ABOUT;
}

// Download image from URL
std::string DownloadImage(const std::string& image_url, const std::string& base_url) {
    if (image_url.empty()) return "";

    // Make absolute URL if relative
    std::string full_url = image_url;
    if (image_url[0] == '/') {
        size_t protocol_end = base_url.find("://");
        if (protocol_end != std::string::npos) {
            size_t domain_end = base_url.find('/', protocol_end + 3);
            full_url = base_url.substr(0, domain_end) + image_url;
        }
    }

    std::string ext = ".jpg";
    if (full_url.find(".png") != std::string::npos) ext = ".png";

    std::string output_path = "/tmp/imgui_img_" + std::to_string(time(nullptr)) + ext;
    std::string cmd = "curl -L -s --max-time 10 \"" + full_url + "\" -o \"" + output_path + "\" 2>/dev/null";

    if (system(cmd.c_str()) != 0) return "";
    if (access(output_path.c_str(), F_OK) != 0) return "";

    return output_path;
}

// Create WebSection from detected section
WebSection CreateWebSection(const DetectedSection& detected, int section_id) {
    SectionType type = MapToSectionType(detected.type);
    WebSection sec(section_id, type);

    if (!detected.title.empty()) sec.title = detected.title;
    if (!detected.subtitle.empty()) sec.subtitle = detected.subtitle;
    if (!detected.content.empty()) sec.content = detected.content;

    sec.bg_color = detected.colors.background;
    sec.title_color = detected.colors.text;
    sec.subtitle_color = detected.colors.text;
    sec.accent_color = detected.colors.primary;
    sec.button_bg_color = detected.colors.accent;
    sec.height = detected.estimated_height;

    return sec;
}

// Main import function
bool ImportFromURL(const std::string& url, int timeout_seconds, bool use_stealth = false) {
    g_URLImportStatus = "Validating URL...";
    g_URLImportProgress = 0.1f;

    // Clean the URL (remove whitespace)
    std::string cleaned_url = url;
    size_t start = cleaned_url.find_first_not_of(" \t\n\r");
    size_t end = cleaned_url.find_last_not_of(" \t\n\r");
    if (start != std::string::npos) {
        cleaned_url = cleaned_url.substr(start, end - start + 1);
    }

    if (!ValidateURL(cleaned_url)) {
        g_URLImportStatus = "Error: Invalid URL format (must be http:// or https://)";
        return false;
    }

    // Use cleaned URL for all operations
    std::string final_url = cleaned_url;

    // Generate unique template name from URL
    std::string template_name = "imported_";
    size_t url_start = final_url.find("://");
    if (url_start != std::string::npos) {
        url_start += 3;
        size_t url_end = final_url.find("/", url_start);
        std::string domain = (url_end != std::string::npos) ? final_url.substr(url_start, url_end - url_start) : final_url.substr(url_start);
        // Remove www. and dots
        size_t www_pos = domain.find("www.");
        if (www_pos == 0) domain = domain.substr(4);
        for (char& c : domain) {
            if (c == '.') c = '_';
        }
        template_name += domain;
    } else {
        template_name += "website";
    }

    // Add timestamp to make unique
    time_t now = time(nullptr);
    template_name += "_" + std::to_string(now);

    if (use_stealth) {
        g_URLImportStatus = "Launching Stealth Browser MCP scraper (anti-bot bypass)...";
    } else {
        g_URLImportStatus = "Launching advanced scraper with Playwright...";
    }
    g_URLImportProgress = 0.2f;

    // Call Python scraper with virtual environment activated and custom timeout
    // Add --stealth flag for stealth browser MCP mode
    std::string stealth_flag = use_stealth ? " --stealth" : "";
    std::string command = "/bin/bash -c 'cd /Users/imaging/Desktop/Website-Builder-v2.0 && source playwright_env/bin/activate && source ~/stealth_env.sh && python3 import_website.py \"" + final_url + "\" \"" + template_name + "\" " + std::to_string(timeout_seconds) + stealth_flag + "' 2>&1";

    printf("[URL Import] Starting scraper for: %s\n", final_url.c_str());
    printf("[URL Import] Mode: %s\n", use_stealth ? "Stealth Browser MCP" : "Local Playwright");
    printf("[URL Import] Timeout: %d seconds (%d min %d sec)\n", timeout_seconds, timeout_seconds / 60, timeout_seconds % 60);
    printf("[URL Import] Command: %s\n", command.c_str());

    FILE* pipe = popen(command.c_str(), "r");
    if (!pipe) {
        g_URLImportStatus = "Error: Failed to launch scraper (Python not found?)";
        printf("[URL Import] ERROR: popen failed\n");
        return false;
    }

    if (use_stealth) {
        g_URLImportStatus = "Scraping via Stealth Browser (may take 1-2 minutes)...";
    } else {
        g_URLImportStatus = "Scraping website (this may take 30-60 seconds)...";
    }
    g_URLImportProgress = 0.5f;

    // Read output with detailed logging
    char buffer[256];
    std::string result = "";
    int lineCount = 0;
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        result += buffer;
        lineCount++;
        if (lineCount % 10 == 0) {
            printf("[URL Import] Reading output... (%d lines)\n", lineCount);
        }
    }
    int status = pclose(pipe);

    printf("[URL Import] Scraper finished with exit code: %d\n", status);
    printf("[URL Import] Output length: %zu bytes\n", result.length());

    if (status != 0) {
        std::string error_msg = result.substr(0, std::min(size_t(200), result.length()));
        g_URLImportStatus = "Error: Scraping failed - " + error_msg;
        printf("[URL Import] ERROR OUTPUT:\n%s\n", result.c_str());
        return false;
    }

    g_URLImportStatus = "Importing to database...";
    g_URLImportProgress = 0.8f;

    // Import SQL to database
    std::string sql_file = "import_" + template_name + ".sql";
    std::string import_cmd = "cd /Users/imaging/Desktop/Website-Builder-v2.0 && psql -d website_builder < " + sql_file + " 2>&1";

    printf("[URL Import] Importing SQL file: %s\n", sql_file.c_str());

    pipe = popen(import_cmd.c_str(), "r");
    if (!pipe) {
        g_URLImportStatus = "Error: Failed to import to database (psql not found?)";
        printf("[URL Import] ERROR: Database import popen failed\n");
        return false;
    }

    result = "";
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        result += buffer;
    }
    status = pclose(pipe);

    printf("[URL Import] Database import exit code: %d\n", status);
    printf("[URL Import] Database import output:\n%s\n", result.c_str());

    // Check for ROLLBACK or ERROR in output (even if exit code is 0)
    if (result.find("ROLLBACK") != std::string::npos ||
        result.find("ERROR") != std::string::npos) {
        std::string error_msg = result.substr(0, std::min(size_t(300), result.length()));
        g_URLImportStatus = "Error: Database import failed (transaction rolled back)";
        printf("[URL Import] Database ERROR detected in output:\n%s\n", result.c_str());
        return false;
    }

    if (status != 0) {
        std::string error_msg = result.substr(0, std::min(size_t(200), result.length()));
        g_URLImportStatus = "Error: Database import failed - " + error_msg;
        return false;
    }

    g_URLImportStatus = "Loading template from database...";
    g_URLImportProgress = 0.9f;

    // Refresh available templates list
    LoadAvailableTemplates();

    // Load the template from database
    bool loaded = LoadTemplate(template_name);

    if (!loaded) {
        g_URLImportStatus = "Error: Failed to load imported template";
        return false;
    }

    // Check if any sections were actually imported
    if (g_Sections.size() == 0) {
        g_URLImportStatus = "Warning: Import completed but found 0 sections. Site may have anti-bot protection or incompatible structure. Try increasing timeout or use a different site.";
        g_URLImportProgress = 1.0f;
        return false;  // Treat as failure
    } else if (g_Sections.size() < 3) {
        // Very few sections - might be partial failure
        g_URLImportStatus = "Warning: Only imported " + std::to_string(g_Sections.size()) + " section(s). Site might have limited content or detection issues.";
        g_URLImportProgress = 1.0f;
        return true;  // Still allow use
    }

    g_URLImportStatus = "Success! Imported " + std::to_string(g_Sections.size()) + " sections with images";
    g_URLImportProgress = 1.0f;

    return true;
}

// ============================================================================
// LOCAL DOWNLOAD IMPORT IMPLEMENTATION
// ============================================================================

// Helper: Parse RGB color string to ImVec4
ImVec4 ParseCSSColor(const std::string& color) {
    ImVec4 result(0.1f, 0.1f, 0.1f, 1.0f);

    // Handle rgb(r, g, b) format
    if (color.find("rgb") != std::string::npos) {
        int r, g, b;
        if (sscanf(color.c_str(), "rgb(%d,%d,%d)", &r, &g, &b) == 3 ||
            sscanf(color.c_str(), "rgb( %d , %d , %d )", &r, &g, &b) == 3) {
            result = ImVec4(r/255.0f, g/255.0f, b/255.0f, 1.0f);
        }
    }
    // Handle #RRGGBB format
    else if (color[0] == '#' && color.length() >= 7) {
        int r, g, b;
        sscanf(color.c_str() + 1, "%02x%02x%02x", &r, &g, &b);
        result = ImVec4(r/255.0f, g/255.0f, b/255.0f, 1.0f);
    }
    // Handle #RGB format
    else if (color[0] == '#' && color.length() >= 4) {
        int r, g, b;
        sscanf(color.c_str() + 1, "%1x%1x%1x", &r, &g, &b);
        result = ImVec4(r/15.0f, g/15.0f, b/15.0f, 1.0f);
    }

    return result;
}

// Helper: Find all files matching pattern in directory
std::vector<std::string> FindFiles(const std::string& dir, const std::string& extension) {
    std::vector<std::string> files;
    std::string cmd = "find \"" + dir + "\" -name \"*" + extension + "\" -type f 2>/dev/null";

    FILE* pipe = popen(cmd.c_str(), "r");
    if (pipe) {
        char buffer[512];
        while (fgets(buffer, sizeof(buffer), pipe)) {
            std::string file = buffer;
            file.erase(file.find_last_not_of(" \n\r\t") + 1);
            if (!file.empty()) files.push_back(file);
        }
        pclose(pipe);
    }
    return files;
}

// Helper: Read file contents
std::string ReadFileContents(const std::string& path) {
    std::ifstream file(path);
    if (!file.is_open()) return "";
    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

// Download website using Python script (more reliable than wget)
bool DownloadWebsiteLocally(const std::string& url, const std::string& output_dir) {
    g_URLImportStatus = "Creating download directory...";
    g_URLImportProgress = 0.1f;

    // Create output directory
    std::string mkdir_cmd = "mkdir -p \"" + output_dir + "\"";
    system(mkdir_cmd.c_str());

    g_URLImportStatus = "Downloading website with Python...";
    g_URLImportProgress = 0.2f;

    // Create a Python script to download the website
    std::string python_script = R"(
import sys
import os
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
import re

url = sys.argv[1]
output_dir = sys.argv[2]

headers = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
}

print(f"Downloading: {url}")

try:
    # Download main page
    response = requests.get(url, headers=headers, timeout=30)
    response.raise_for_status()
    html = response.text

    # Parse domain for folder
    domain = urlparse(url).netloc
    site_dir = os.path.join(output_dir, domain)
    os.makedirs(site_dir, exist_ok=True)

    # Save main HTML
    html_path = os.path.join(site_dir, 'index.html')
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html)
    print(f"Saved: {html_path}")

    # Parse HTML for resources
    soup = BeautifulSoup(html, 'html.parser')

    # Create subdirectories
    css_dir = os.path.join(site_dir, 'css')
    img_dir = os.path.join(site_dir, 'images')
    os.makedirs(css_dir, exist_ok=True)
    os.makedirs(img_dir, exist_ok=True)

    # Download CSS files
    for link in soup.find_all('link', rel='stylesheet'):
        href = link.get('href')
        if href:
            css_url = urljoin(url, href)
            try:
                css_resp = requests.get(css_url, headers=headers, timeout=10)
                filename = os.path.basename(urlparse(css_url).path) or 'style.css'
                css_path = os.path.join(css_dir, filename)
                with open(css_path, 'w', encoding='utf-8') as f:
                    f.write(css_resp.text)
                print(f"CSS: {filename}")
            except Exception as e:
                print(f"CSS error: {e}")

    # Download images
    img_count = 0
    for img in soup.find_all('img'):
        src = img.get('src') or img.get('data-src')
        if src and img_count < 50:  # Limit to 50 images
            img_url = urljoin(url, src)
            try:
                img_resp = requests.get(img_url, headers=headers, timeout=10)
                filename = os.path.basename(urlparse(img_url).path)
                if not filename or '.' not in filename:
                    filename = f'image_{img_count}.jpg'
                img_path = os.path.join(img_dir, filename)
                with open(img_path, 'wb') as f:
                    f.write(img_resp.content)
                print(f"Image: {filename}")
                img_count += 1
            except Exception as e:
                print(f"Image error: {e}")

    # Also get background images from style tags
    for style in soup.find_all('style'):
        if style.string:
            urls = re.findall(r'url\(["\']?([^"\')\s]+)["\']?\)', style.string)
            for bg_url in urls[:10]:
                if bg_url.startswith('data:'):
                    continue
                full_url = urljoin(url, bg_url)
                try:
                    bg_resp = requests.get(full_url, headers=headers, timeout=10)
                    filename = os.path.basename(urlparse(full_url).path)
                    if filename and '.' in filename:
                        bg_path = os.path.join(img_dir, filename)
                        with open(bg_path, 'wb') as f:
                            f.write(bg_resp.content)
                        print(f"BG Image: {filename}")
                except:
                    pass

    print("Download complete!")

except Exception as e:
    print(f"Error: {e}")
    sys.exit(1)
)";

    // Write Python script to temp file
    std::string script_path = "/tmp/download_site.py";
    FILE* script_file = fopen(script_path.c_str(), "w");
    if (script_file) {
        fprintf(script_file, "%s", python_script.c_str());
        fclose(script_file);
    }

    // Run Python script
    std::string python_cmd = "python3 \"" + script_path + "\" \"" + url + "\" \"" + output_dir + "\" 2>&1";

    printf("[LocalDownload] Running Python downloader...\n");

    FILE* pipe = popen(python_cmd.c_str(), "r");
    if (!pipe) {
        g_URLImportStatus = "Error: Failed to run Python";
        return false;
    }

    char buffer[256];
    int lineCount = 0;
    while (fgets(buffer, sizeof(buffer), pipe)) {
        lineCount++;
        printf("%s", buffer);
        if (lineCount % 5 == 0) {
            g_URLImportProgress = 0.2f + (lineCount / 100.0f) * 0.4f;
            if (g_URLImportProgress > 0.6f) g_URLImportProgress = 0.6f;
        }
    }

    int status = pclose(pipe);
    printf("[LocalDownload] Python finished with status: %d\n", status);

    if (status != 0) {
        g_URLImportStatus = "Error: Download failed";
        return false;
    }

    g_URLImportProgress = 0.6f;
    g_DownloadComplete = true;
    g_DownloadedSitePath = output_dir + "/" + ExtractDomain(url);

    return true;
}

// Parse CSS file and extract styles
std::map<std::string, std::string> ParseLocalCSSFile(const std::string& css_path) {
    std::map<std::string, std::string> styles;
    std::string css = ReadFileContents(css_path);

    // Simple CSS parsing - extract color, background, font properties
    // This is a basic parser, production would need a full CSS parser

    // Find body styles
    size_t bodyPos = css.find("body");
    if (bodyPos != std::string::npos) {
        size_t braceStart = css.find("{", bodyPos);
        size_t braceEnd = css.find("}", braceStart);
        if (braceStart != std::string::npos && braceEnd != std::string::npos) {
            std::string bodyCSS = css.substr(braceStart + 1, braceEnd - braceStart - 1);
            styles["body"] = bodyCSS;
        }
    }

    return styles;
}

// Parse local HTML and create sections
bool ParseLocalHTMLFile(const std::string& html_path, std::vector<WebSection>& sections) {
    try {
        std::string html = ReadFileContents(html_path);
        if (html.empty()) {
            printf("[LocalParse] Failed to read HTML file: %s\n", html_path.c_str());
            return false;
        }

        printf("[LocalParse] HTML file size: %zu bytes\n", html.length());

    // Extract title
    std::string pageTitle = "Imported Site";
    size_t titleStart = html.find("<title>");
    size_t titleEnd = html.find("</title>");
    if (titleStart != std::string::npos && titleEnd != std::string::npos) {
        titleStart += 7;
        pageTitle = html.substr(titleStart, titleEnd - titleStart);
    }

    // Find sections by common HTML5 semantic tags AND generic patterns
    std::vector<std::pair<std::string, SectionType>> sectionTags = {
        // Semantic tags
        {"<header", SEC_NAVBAR},
        {"<nav", SEC_NAVBAR},
        {"<footer", SEC_FOOTER},
        {"<main", SEC_HERO},
        // Hero patterns
        {"<section class=\"hero", SEC_HERO},
        {"<section id=\"hero", SEC_HERO},
        {"<div class=\"hero", SEC_HERO},
        {"class=\"hero-", SEC_HERO},
        {"class=\"banner", SEC_HERO},
        {"class=\"jumbotron", SEC_HERO},
        {"class=\"splash", SEC_HERO},
        // Services/Features patterns
        {"<section class=\"services", SEC_SERVICES},
        {"<section class=\"features", SEC_SERVICES},
        {"<section id=\"services", SEC_SERVICES},
        {"<section class=\"about", SEC_SERVICES},
        {"class=\"features", SEC_SERVICES},
        {"class=\"services", SEC_SERVICES},
        {"class=\"benefits", SEC_SERVICES},
        {"class=\"products", SEC_SERVICES},
        // Gallery patterns
        {"<section class=\"gallery", SEC_GALLERY},
        {"<section id=\"gallery", SEC_GALLERY},
        {"<section class=\"portfolio", SEC_GALLERY},
        {"class=\"gallery", SEC_GALLERY},
        {"class=\"portfolio", SEC_GALLERY},
        {"class=\"grid", SEC_GALLERY},
        // Contact patterns
        {"<section class=\"contact", SEC_CONTACT},
        {"<section id=\"contact", SEC_CONTACT},
        {"class=\"contact", SEC_CONTACT},
        {"class=\"form", SEC_CONTACT},
        // CTA patterns
        {"<section class=\"cta", SEC_CTA},
        {"class=\"cta", SEC_CTA},
        {"class=\"call-to-action", SEC_CTA},
        {"class=\"promo", SEC_CTA}
    };

    int sectionId = 1;
    std::string lowerHTML = html;
    std::transform(lowerHTML.begin(), lowerHTML.end(), lowerHTML.begin(), ::tolower);

    for (const auto& tag : sectionTags) {
        size_t pos = lowerHTML.find(tag.first);
        if (pos != std::string::npos && pos < html.length()) {
            // Find the closing tag
            std::string tagName = tag.first.substr(1);
            size_t spacePos = tagName.find(" ");
            if (spacePos != std::string::npos) tagName = tagName.substr(0, spacePos);

            size_t endPos = lowerHTML.find("</" + tagName + ">", pos);
            if (endPos == std::string::npos) endPos = pos + 2000; // Limit section size

            // Clamp endPos to html length
            if (endPos > html.length()) endPos = html.length();
            if (endPos <= pos) continue; // Skip invalid ranges

            std::string sectionHTML = html.substr(pos, endPos - pos);
            if (sectionHTML.empty()) continue;

            // Create section
            int secTypeIdx = (int)tag.second;
            if (secTypeIdx < 0 || secTypeIdx >= (int)g_SectionTypeNames.size()) continue;

            WebSection sec(g_NextSectionId++, tag.second);
            sec.name = g_SectionTypeNames[secTypeIdx];

            // Extract text content (strip HTML tags)
            std::string text = sectionHTML;
            // Simple tag removal
            std::string cleanText;
            bool inTag = false;
            for (char c : text) {
                if (c == '<') inTag = true;
                else if (c == '>') inTag = false;
                else if (!inTag && c != '\n' && c != '\r' && c != '\t') cleanText += c;
            }

            // Find headings (with bounds checking)
            size_t h1Start = sectionHTML.find("<h1");
            size_t h1End = sectionHTML.find("</h1>");
            if (h1Start != std::string::npos && h1End != std::string::npos && h1End > h1Start) {
                size_t textStart = sectionHTML.find(">", h1Start);
                if (textStart != std::string::npos && textStart + 1 < h1End) {
                    textStart += 1;
                    std::string h1Text = sectionHTML.substr(textStart, h1End - textStart);
                    // Strip inner tags
                    std::string clean;
                    bool inT = false;
                    for (char c : h1Text) {
                        if (c == '<') inT = true;
                        else if (c == '>') inT = false;
                        else if (!inT) clean += c;
                    }
                    sec.title = clean;
                }
            }

            size_t h2Start = sectionHTML.find("<h2");
            size_t h2End = sectionHTML.find("</h2>");
            if (h2Start != std::string::npos && h2End != std::string::npos && h2End > h2Start) {
                size_t textStart = sectionHTML.find(">", h2Start);
                if (textStart != std::string::npos && textStart + 1 < h2End) {
                    textStart += 1;
                    std::string h2Text = sectionHTML.substr(textStart, h2End - textStart);
                    std::string clean;
                    bool inT = false;
                    for (char c : h2Text) {
                        if (c == '<') inT = true;
                        else if (c == '>') inT = false;
                        else if (!inT) clean += c;
                    }
                    if (sec.title.empty()) sec.title = clean;
                    else sec.subtitle = clean;
                }
            }

            // Find paragraph content (with bounds checking)
            size_t pStart = sectionHTML.find("<p");
            size_t pEnd = sectionHTML.find("</p>");
            if (pStart != std::string::npos && pEnd != std::string::npos && pEnd > pStart) {
                size_t textStart = sectionHTML.find(">", pStart);
                if (textStart != std::string::npos && textStart + 1 < pEnd) {
                    textStart += 1;
                    std::string pText = sectionHTML.substr(textStart, pEnd - textStart);
                    std::string clean;
                    bool inT = false;
                    for (char c : pText) {
                        if (c == '<') inT = true;
                        else if (c == '>') inT = false;
                        else if (!inT) clean += c;
                    }
                    sec.content = clean;
                }
            }

            // Find images in this section (with bounds checking)
            size_t imgPos = 0;
            while ((imgPos = sectionHTML.find("<img", imgPos)) != std::string::npos) {
                size_t srcPos = sectionHTML.find("src=", imgPos);
                if (srcPos != std::string::npos && srcPos < imgPos + 200 && srcPos + 5 < sectionHTML.length()) {
                    char quote = sectionHTML[srcPos + 4];
                    if (quote == '"' || quote == '\'') {
                        size_t srcStart = srcPos + 5;
                        size_t srcEnd = sectionHTML.find(quote, srcStart);
                        if (srcEnd != std::string::npos && srcEnd > srcStart) {
                            std::string imgSrc = sectionHTML.substr(srcStart, srcEnd - srcStart);
                            if (sec.section_image.empty() && !imgSrc.empty()) {
                                sec.section_image = imgSrc;
                            }
                        }
                    }
                }
                imgPos++;
            }

            // Find buttons (with bounds checking)
            size_t btnPos = sectionHTML.find("<button");
            if (btnPos == std::string::npos) btnPos = sectionHTML.find("<a class=\"btn");
            if (btnPos == std::string::npos) btnPos = sectionHTML.find("<a class=\"button");
            if (btnPos != std::string::npos) {
                size_t btnEnd = sectionHTML.find(">", btnPos);
                if (btnEnd != std::string::npos && btnEnd + 1 < sectionHTML.length()) {
                    size_t btnTextEnd = sectionHTML.find("<", btnEnd + 1);
                    if (btnTextEnd != std::string::npos && btnTextEnd > btnEnd + 1) {
                        sec.button_text = sectionHTML.substr(btnEnd + 1, btnTextEnd - btnEnd - 1);
                        // Trim whitespace
                        size_t start = sec.button_text.find_first_not_of(" \t\n\r");
                        size_t end = sec.button_text.find_last_not_of(" \t\n\r");
                        if (start != std::string::npos && end != std::string::npos && end >= start) {
                            sec.button_text = sec.button_text.substr(start, end - start + 1);
                        }
                    }
                }
            }

            // Set default height based on section type
            if (tag.second == SEC_NAVBAR) sec.height = 80;
            else if (tag.second == SEC_HERO) sec.height = 600;
            else if (tag.second == SEC_FOOTER) sec.height = 200;
            else sec.height = 400;

            sections.push_back(sec);
            printf("[LocalParse] Found section: %s (type: %d)\n", sec.name.c_str(), (int)tag.second);
        }
    }

        // If too few sections found, create automatic sections by splitting content
        if (sections.size() < 3) {
            printf("[LocalParse] Only found %zu sections, creating automatic sections...\n", sections.size());
            sections.clear(); // Start fresh with auto-detection

            // Create Hero from page title
            WebSection hero(g_NextSectionId++, SEC_HERO);
            hero.title = pageTitle;
            hero.subtitle = "Welcome to our website";
            hero.height = 600;
            sections.push_back(hero);

            // Find all major content divs and create sections
            std::vector<std::string> majorDivs;
            size_t searchPos = 0;
            int divCount = 0;

            // Look for divs with substantial content
            while ((searchPos = html.find("<div", searchPos)) != std::string::npos && divCount < 10) {
                // Find the closing of this div's opening tag
                size_t tagEnd = html.find(">", searchPos);
                if (tagEnd == std::string::npos) break;

                // Check if this div has a class (likely important)
                std::string tagContent = html.substr(searchPos, tagEnd - searchPos);
                if (tagContent.find("class=") != std::string::npos) {
                    // Find a reasonable end point (next major div or limit)
                    size_t contentEnd = html.find("</div>", tagEnd);
                    if (contentEnd != std::string::npos) {
                        size_t contentLen = contentEnd - tagEnd;
                        // Only consider substantial divs (>500 chars of content)
                        if (contentLen > 500 && contentLen < 10000) {
                            std::string divContent = html.substr(tagEnd + 1, contentLen);

                            // Extract text from this div
                            std::string cleanText;
                            bool inT = false;
                            for (char c : divContent) {
                                if (c == '<') inT = true;
                                else if (c == '>') inT = false;
                                else if (!inT && c != '\n' && c != '\r' && c != '\t') cleanText += c;
                            }

                            // Only use if has meaningful text
                            if (cleanText.length() > 50) {
                                // Determine section type based on content or position
                                SectionType secType = SEC_SERVICES;
                                if (divCount == 0) secType = SEC_SERVICES;
                                else if (divCount == 1) secType = SEC_SERVICES;
                                else if (divCount == 2) secType = SEC_CTA;
                                else secType = SEC_SERVICES;

                                WebSection sec(g_NextSectionId++, secType);
                                sec.name = "Section " + std::to_string(divCount + 1);

                                // Extract first heading as title
                                size_t hStart = divContent.find("<h");
                                if (hStart != std::string::npos) {
                                    size_t hTagEnd = divContent.find(">", hStart);
                                    size_t hEnd = divContent.find("</h", hTagEnd);
                                    if (hTagEnd != std::string::npos && hEnd != std::string::npos) {
                                        std::string heading = divContent.substr(hTagEnd + 1, hEnd - hTagEnd - 1);
                                        // Strip tags from heading
                                        std::string cleanH;
                                        bool inHT = false;
                                        for (char c : heading) {
                                            if (c == '<') inHT = true;
                                            else if (c == '>') inHT = false;
                                            else if (!inHT) cleanH += c;
                                        }
                                        sec.title = cleanH.substr(0, 100); // Limit length
                                    }
                                }

                                if (sec.title.empty()) {
                                    sec.title = "Section " + std::to_string(divCount + 1);
                                }

                                sec.height = 400;
                                sections.push_back(sec);
                                divCount++;
                                printf("[LocalParse] Auto-created section: %s\n", sec.title.c_str());
                            }
                        }
                    }
                }
                searchPos = tagEnd + 1;
            }

            // Add a footer section
            WebSection footer(g_NextSectionId++, SEC_FOOTER);
            footer.title = pageTitle;
            footer.content = "Contact us for more information";
            footer.height = 200;
            sections.push_back(footer);
        }

        return true;
    } catch (const std::exception& e) {
        printf("[LocalParse] Exception: %s\n", e.what());
        return false;
    } catch (...) {
        printf("[LocalParse] Unknown exception\n");
        return false;
    }
}

// Main import from local download function
bool ImportFromLocalDownload(const std::string& url) {
    g_URLImportStatus = "Starting local download import...";
    g_URLImportProgress = 0.0f;

    // Validate URL
    if (!ValidateURL(url)) {
        g_URLImportStatus = "Error: Invalid URL format";
        return false;
    }

    // Create download directory
    std::string domain = ExtractDomain(url);
    std::string timestamp = std::to_string(time(nullptr));
    std::string download_dir = "/Users/imaging/Desktop/Website-Builder-v2.0/downloaded_sites/" + domain + "_" + timestamp;

    // Step 1: Download website
    if (!DownloadWebsiteLocally(url, download_dir)) {
        return false;
    }

    g_URLImportStatus = "Parsing downloaded files...";
    g_URLImportProgress = 0.7f;

    // Step 2: Find HTML files
    std::vector<std::string> htmlFiles = FindFiles(download_dir, ".html");
    if (htmlFiles.empty()) {
        // Try without extension (some servers serve without .html)
        htmlFiles = FindFiles(download_dir, "index.html");
    }

    // Also check for index.htm
    if (htmlFiles.empty()) {
        htmlFiles = FindFiles(download_dir, ".htm");
    }

    printf("[LocalDownload] Found %zu HTML files\n", htmlFiles.size());

    if (htmlFiles.empty()) {
        g_URLImportStatus = "Error: No HTML files found in download";
        return false;
    }

    // Step 3: Parse HTML and create sections
    std::vector<WebSection> newSections;

    // Parse main index.html first
    std::string mainHTML;
    for (const auto& file : htmlFiles) {
        if (file.find("index") != std::string::npos) {
            mainHTML = file;
            break;
        }
    }
    if (mainHTML.empty()) mainHTML = htmlFiles[0];

    printf("[LocalDownload] Parsing main HTML: %s\n", mainHTML.c_str());

    if (!ParseLocalHTMLFile(mainHTML, newSections)) {
        g_URLImportStatus = "Error: Failed to parse HTML file";
        return false;
    }

    g_URLImportStatus = "Extracting CSS styles...";
    g_URLImportProgress = 0.8f;

    // Step 4: Parse CSS files for styling
    std::vector<std::string> cssFiles = FindFiles(download_dir, ".css");
    printf("[LocalDownload] Found %zu CSS files\n", cssFiles.size());

    std::map<std::string, std::string> allStyles;
    for (const auto& cssFile : cssFiles) {
        auto styles = ParseLocalCSSFile(cssFile);
        allStyles.insert(styles.begin(), styles.end());
    }

    // Step 5: Copy images to app directory
    g_URLImportStatus = "Processing images...";
    g_URLImportProgress = 0.85f;

    std::string imagesDir = "/Users/imaging/Desktop/Website-Builder-v2.0/scraped_images/" + domain;
    std::string mkdirCmd = "mkdir -p \"" + imagesDir + "\"";
    system(mkdirCmd.c_str());

    // Find and copy images
    std::vector<std::string> imageExts = {".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"};
    for (const auto& ext : imageExts) {
        std::vector<std::string> images = FindFiles(download_dir, ext);
        for (const auto& img : images) {
            std::string filename = img.substr(img.find_last_of("/") + 1);
            std::string destPath = imagesDir + "/" + filename;
            std::string cpCmd = "cp \"" + img + "\" \"" + destPath + "\" 2>/dev/null";
            system(cpCmd.c_str());
        }
    }

    // Step 6: Update sections with local image paths
    std::vector<std::string> localImages = FindFiles(imagesDir, "");
    for (auto& sec : newSections) {
        if (!sec.section_image.empty()) {
            // Try to find matching image
            std::string imgName = sec.section_image;
            if (imgName.find("/") != std::string::npos) {
                imgName = imgName.substr(imgName.find_last_of("/") + 1);
            }

            for (const auto& localImg : localImages) {
                if (localImg.find(imgName) != std::string::npos) {
                    sec.section_image = localImg;
                    // Load texture
                    ImageTexture tex = LoadTexture(localImg);
                    sec.img_texture_id = tex.id;
                    break;
                }
            }
        }
    }

    g_URLImportStatus = "Creating template...";
    g_URLImportProgress = 0.9f;

    // Step 7: Save to database and load
    g_Sections.clear();
    g_Sections = newSections;

    // Generate template name
    std::string template_name = "local_" + domain + "_" + timestamp.substr(timestamp.length() - 6);

    // Save template
    g_ProjectName = template_name;
    SaveTemplate(template_name, "Imported from local download");

    // Reload to ensure proper state
    LoadTemplate(template_name);
    LoadAvailableTemplates();

    if (g_Sections.empty()) {
        g_URLImportStatus = "Error: No sections created";
        return false;
    }

    g_URLImportStatus = "Success! Imported " + std::to_string(g_Sections.size()) + " sections from local download";
    g_URLImportProgress = 1.0f;

    printf("[LocalDownload] Import complete: %zu sections\n", g_Sections.size());

    return true;
}

// ============================================================================
// FIGMA-STYLE LAYER IMPORT AND RENDERING
// ============================================================================

// Helper function to parse color string (rgb/rgba) to ImVec4
ImVec4 ParseColorString(const std::string& colorStr) {
    ImVec4 color(0, 0, 0, 1);
    if (colorStr.empty()) return color;

    // Try to parse rgba(r, g, b, a) or rgb(r, g, b)
    if (colorStr.find("rgba") != std::string::npos) {
        float r, g, b, a;
        if (sscanf(colorStr.c_str(), "rgba(%f, %f, %f, %f)", &r, &g, &b, &a) == 4 ||
            sscanf(colorStr.c_str(), "rgba(%f,%f,%f,%f)", &r, &g, &b, &a) == 4) {
            color = ImVec4(r/255.0f, g/255.0f, b/255.0f, a);
        }
    } else if (colorStr.find("rgb") != std::string::npos) {
        float r, g, b;
        if (sscanf(colorStr.c_str(), "rgb(%f, %f, %f)", &r, &g, &b) == 3 ||
            sscanf(colorStr.c_str(), "rgb(%f,%f,%f)", &r, &g, &b) == 3) {
            color = ImVec4(r/255.0f, g/255.0f, b/255.0f, 1.0f);
        }
    }
    return color;
}

WebLayer* GetLayerById(int id) {
    for (auto& layer : g_FigmaProject.layers) {
        if (layer.id == id) return &layer;
    }
    return nullptr;
}

void SelectLayer(int id) {
    DeselectAllLayers();
    if (WebLayer* layer = GetLayerById(id)) {
        layer->selected = true;
        g_SelectedLayerId = id;
    }
}

void DeselectAllLayers() {
    for (auto& layer : g_FigmaProject.layers) {
        layer.selected = false;
    }
    g_SelectedLayerId = -1;
}

// ============================================================================
// UNDO/REDO SYSTEM
// ============================================================================
void SaveUndoState(const std::string& description) {
    UndoState state;
    state.layers = g_FigmaProject.layers;  // Deep copy
    state.description = description;

    g_UndoStack.push_back(state);
    if ((int)g_UndoStack.size() > MAX_UNDO_LEVELS) {
        g_UndoStack.erase(g_UndoStack.begin());
    }

    // Clear redo stack when new action is performed
    g_RedoStack.clear();
}

void Undo() {
    if (g_UndoStack.empty()) return;

    // Save current state to redo stack
    UndoState redoState;
    redoState.layers = g_FigmaProject.layers;
    redoState.description = "Redo";
    g_RedoStack.push_back(redoState);

    // Restore previous state
    UndoState& undoState = g_UndoStack.back();
    g_FigmaProject.layers = undoState.layers;
    g_UndoStack.pop_back();

    // Update next_layer_id to avoid conflicts
    int maxId = 0;
    for (const auto& layer : g_FigmaProject.layers) {
        if (layer.id > maxId) maxId = layer.id;
    }
    g_FigmaProject.next_layer_id = maxId + 1;

    g_SelectedLayerId = -1;
}

void Redo() {
    if (g_RedoStack.empty()) return;

    // Save current state to undo stack
    UndoState undoState;
    undoState.layers = g_FigmaProject.layers;
    undoState.description = "Undo";
    g_UndoStack.push_back(undoState);

    // Restore redo state
    UndoState& redoState = g_RedoStack.back();
    g_FigmaProject.layers = redoState.layers;
    g_RedoStack.pop_back();

    // Update next_layer_id
    int maxId = 0;
    for (const auto& layer : g_FigmaProject.layers) {
        if (layer.id > maxId) maxId = layer.id;
    }
    g_FigmaProject.next_layer_id = maxId + 1;

    g_SelectedLayerId = -1;
}

// ============================================================================
// CLIPBOARD - COPY/PASTE/DELETE
// ============================================================================
std::vector<WebLayer*> GetSelectedLayers() {
    std::vector<WebLayer*> selected;
    for (auto& layer : g_FigmaProject.layers) {
        if (layer.selected) {
            selected.push_back(&layer);
        }
    }
    return selected;
}

void CopySelectedLayers() {
    g_Clipboard.clear();
    for (auto& layer : g_FigmaProject.layers) {
        if (layer.selected) {
            g_Clipboard.push_back(layer);
        }
    }
}

void PasteClipboard() {
    if (g_Clipboard.empty()) return;

    SaveUndoState("Paste");
    DeselectAllLayers();

    for (auto& layer : g_Clipboard) {
        WebLayer newLayer = layer;
        newLayer.id = g_FigmaProject.next_layer_id++;
        newLayer.x += 20;  // Offset pasted elements
        newLayer.y += 20;
        newLayer.selected = true;
        g_FigmaProject.layers.push_back(newLayer);
        g_SelectedLayerId = newLayer.id;
    }
}

void DeleteSelectedLayers() {
    bool anyDeleted = false;
    for (auto& layer : g_FigmaProject.layers) {
        if (layer.selected) {
            anyDeleted = true;
            break;
        }
    }

    if (!anyDeleted) return;

    SaveUndoState("Delete");

    g_FigmaProject.layers.erase(
        std::remove_if(g_FigmaProject.layers.begin(), g_FigmaProject.layers.end(),
            [](const WebLayer& l) { return l.selected; }),
        g_FigmaProject.layers.end());

    g_SelectedLayerId = -1;
}

// ============================================================================
// ALIGNMENT TOOLS
// ============================================================================
void AlignSelectedLayers(AlignType align) {
    auto selected = GetSelectedLayers();
    if (selected.empty()) return;

    // For single selection, align to canvas
    // For multiple selection, align to selection bounds
    float minX = FLT_MAX, minY = FLT_MAX;
    float maxX = -FLT_MAX, maxY = -FLT_MAX;

    if (selected.size() == 1) {
        // Align to canvas
        minX = 0; minY = 0;
        maxX = g_FigmaProject.canvas_width;
        maxY = g_FigmaProject.canvas_height;
    } else {
        // Calculate bounds of selection
        for (auto* layer : selected) {
            minX = std::min(minX, layer->x);
            minY = std::min(minY, layer->y);
            maxX = std::max(maxX, layer->x + layer->width);
            maxY = std::max(maxY, layer->y + layer->height);
        }
    }

    SaveUndoState("Align");

    for (auto* layer : selected) {
        switch (align) {
            case ALIGN_LEFT:
                layer->x = minX;
                break;
            case ALIGN_CENTER_H:
                layer->x = minX + (maxX - minX - layer->width) / 2;
                break;
            case ALIGN_RIGHT:
                layer->x = maxX - layer->width;
                break;
            case ALIGN_TOP:
                layer->y = minY;
                break;
            case ALIGN_CENTER_V:
                layer->y = minY + (maxY - minY - layer->height) / 2;
                break;
            case ALIGN_BOTTOM:
                layer->y = maxY - layer->height;
                break;
        }
    }
}

// ============================================================================
// Z-ORDER CONTROLS
// ============================================================================
void BringToFront(int layerId) {
    WebLayer* layer = GetLayerById(layerId);
    if (!layer) return;

    SaveUndoState("Bring to Front");

    // Find max z_index
    int maxZ = 0;
    for (const auto& l : g_FigmaProject.layers) {
        if (l.z_index > maxZ) maxZ = l.z_index;
    }
    layer->z_index = maxZ + 1;
}

void SendToBack(int layerId) {
    WebLayer* layer = GetLayerById(layerId);
    if (!layer) return;

    SaveUndoState("Send to Back");

    // Find min z_index
    int minZ = 0;
    for (const auto& l : g_FigmaProject.layers) {
        if (l.z_index < minZ) minZ = l.z_index;
    }
    layer->z_index = minZ - 1;
}

void MoveLayerUp(int layerId) {
    WebLayer* layer = GetLayerById(layerId);
    if (!layer) return;

    SaveUndoState("Move Up");
    layer->z_index += 1;
}

void MoveLayerDown(int layerId) {
    WebLayer* layer = GetLayerById(layerId);
    if (!layer) return;

    SaveUndoState("Move Down");
    layer->z_index -= 1;
}

// ============================================================================
// TOOL - CREATE ELEMENT FROM DRAWING
// ============================================================================
void CreateElementFromTool(ToolType tool, float x1, float y1, float x2, float y2) {
    WebLayer layer;
    layer.id = g_FigmaProject.next_layer_id++;
    layer.x = std::min(x1, x2);
    layer.y = std::min(y1, y2);
    layer.width = std::max(50.0f, std::abs(x2 - x1));
    layer.height = std::max(30.0f, std::abs(y2 - y1));
    layer.visible = true;
    layer.opacity = 1.0f;

    switch (tool) {
        case TOOL_RECTANGLE:
            layer.type = LAYER_DIV;
            layer.name = "Rectangle";
            layer.bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
            layer.border_radius = 0;
            break;

        case TOOL_TEXT:
            layer.type = LAYER_TEXT;
            layer.name = "Text";
            layer.text = "Text";
            layer.font_size = 18;
            layer.text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            layer.bg_color = ImVec4(0, 0, 0, 0);  // Transparent
            layer.width = std::max(100.0f, layer.width);
            layer.height = std::max(30.0f, layer.height);
            break;

        case TOOL_BUTTON:
            layer.type = LAYER_BUTTON;
            layer.name = "Button";
            layer.text = "Button";
            layer.font_size = 16;
            layer.bg_color = ImVec4(0.2f, 0.5f, 0.8f, 1.0f);
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.border_radius = 6;
            layer.width = std::max(100.0f, layer.width);
            layer.height = std::max(40.0f, layer.height);
            break;

        case TOOL_IMAGE:
            layer.type = LAYER_IMAGE;
            layer.name = "Image";
            layer.bg_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            layer.width = std::max(100.0f, layer.width);
            layer.height = std::max(100.0f, layer.height);
            break;

        case TOOL_LINE:
            layer.type = LAYER_SHAPE;
            layer.name = "Line";
            layer.bg_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
            layer.height = 2;  // Thin line
            layer.border_radius = 0;
            break;

        case TOOL_CIRCLE:
            layer.type = LAYER_SHAPE;
            layer.name = "Circle";
            layer.bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
            // Make it a perfect circle if dragged roughly square
            if (std::abs(layer.width - layer.height) < 50) {
                float size = std::max(layer.width, layer.height);
                layer.width = size;
                layer.height = size;
            }
            layer.border_radius = 9999;  // Full round
            break;

        case TOOL_FRAME:
            layer.type = LAYER_DIV;
            layer.name = "Frame";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.border_width = 1;
            layer.border_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
            layer.border_radius = 0;
            break;

        // ==================== TYPOGRAPHY TOOLS ====================
        case TOOL_HEADING:
            layer.type = LAYER_TEXT;
            layer.name = "Heading";
            layer.text = "Heading";
            layer.font_size = 48;
            layer.font_weight = 700;
            layer.text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            layer.bg_color = ImVec4(0, 0, 0, 0);
            layer.width = std::max(300.0f, layer.width);
            layer.height = std::max(60.0f, layer.height);
            break;

        case TOOL_SUBHEADING:
            layer.type = LAYER_TEXT;
            layer.name = "Subheading";
            layer.text = "Subheading";
            layer.font_size = 24;
            layer.font_weight = 500;
            layer.text_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
            layer.bg_color = ImVec4(0, 0, 0, 0);
            layer.width = std::max(250.0f, layer.width);
            layer.height = std::max(36.0f, layer.height);
            break;

        case TOOL_PARAGRAPH:
            layer.type = LAYER_TEXT;
            layer.name = "Paragraph";
            layer.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
            layer.font_size = 16;
            layer.font_weight = 400;
            layer.text_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
            layer.bg_color = ImVec4(0, 0, 0, 0);
            layer.width = std::max(400.0f, layer.width);
            layer.height = std::max(80.0f, layer.height);
            break;

        // ==================== BASIC ELEMENTS ====================
        case TOOL_LOGO:
            layer.type = LAYER_IMAGE;
            layer.name = "Logo";
            layer.text = "LOGO";  // Placeholder text
            layer.bg_color = ImVec4(0.2f, 0.5f, 0.8f, 1.0f);
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.font_size = 24;
            layer.font_weight = 700;
            layer.width = std::max(120.0f, layer.width);
            layer.height = std::max(50.0f, layer.height);
            layer.border_radius = 4;
            break;

        case TOOL_INPUT:
            layer.type = LAYER_INPUT;
            layer.name = "Input";
            layer.text = "Enter text...";
            layer.font_size = 16;
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.text_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);  // Placeholder color
            layer.border_width = 1;
            layer.border_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
            layer.border_radius = 6;
            layer.width = std::max(250.0f, layer.width);
            layer.height = std::max(44.0f, layer.height);
            break;

        case TOOL_ICON:
            layer.type = LAYER_ICON;
            layer.name = "Icon";
            layer.text = "‚òÖ";  // Default star icon
            layer.font_size = 32;
            layer.text_color = ImVec4(0.3f, 0.5f, 0.8f, 1.0f);
            layer.bg_color = ImVec4(0, 0, 0, 0);
            layer.width = std::max(48.0f, layer.width);
            layer.height = std::max(48.0f, layer.height);
            break;

        case TOOL_DIVIDER:
            layer.type = LAYER_SHAPE;
            layer.name = "Divider";
            layer.bg_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
            layer.width = std::max(g_FigmaProject.canvas_width * 0.8f, layer.width);
            layer.height = 1;
            break;

        // ==================== WEBSITE SECTIONS ====================
        case TOOL_SEC_HERO:
            layer.type = LAYER_DIV;
            layer.name = "Hero Section";
            layer.bg_color = ImVec4(0.08f, 0.08f, 0.12f, 1.0f);  // Dark blue-black
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(600.0f, layer.height);
            layer.x = 0;
            layer.text = "Hero Title|Subtitle text goes here|Get Started";  // Title|Subtitle|Button
            layer.font_size = 56;
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            break;

        case TOOL_SEC_NAVBAR:
            layer.type = LAYER_DIV;
            layer.name = "Navbar";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = 70;
            layer.x = 0;
            layer.y = 0;
            layer.text = "LOGO|Home|About|Services|Contact";  // Brand + nav items
            layer.border_width = 1;
            layer.border_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
            break;

        case TOOL_SEC_ABOUT:
            layer.type = LAYER_DIV;
            layer.name = "About Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "About Us|We are a team of professionals dedicated to excellence.";
            layer.font_size = 42;
            layer.text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            break;

        case TOOL_SEC_SERVICES:
            layer.type = LAYER_DIV;
            layer.name = "Services Section";
            layer.bg_color = ImVec4(0.97f, 0.97f, 0.98f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Our Services|Web Design|App Development|SEO Optimization";
            layer.font_size = 42;
            layer.text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            break;

        case TOOL_SEC_CARDS:
            layer.type = LAYER_DIV;
            layer.name = "Cards Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(450.0f, layer.height);
            layer.x = 0;
            layer.text = "Featured|Card 1|Card 2|Card 3";
            layer.font_size = 42;
            break;

        case TOOL_SEC_TEAM:
            layer.type = LAYER_DIV;
            layer.name = "Team Section";
            layer.bg_color = ImVec4(0.97f, 0.97f, 0.98f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(550.0f, layer.height);
            layer.x = 0;
            layer.text = "Meet Our Team|John Doe - CEO|Jane Smith - CTO|Mike Johnson - Designer";
            layer.font_size = 42;
            layer.text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
            break;

        case TOOL_SEC_PRICING:
            layer.type = LAYER_DIV;
            layer.name = "Pricing Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(600.0f, layer.height);
            layer.x = 0;
            layer.text = "Pricing Plans|Basic $9/mo|Pro $29/mo|Enterprise $99/mo";
            layer.font_size = 42;
            break;

        case TOOL_SEC_TESTIMONIALS:
            layer.type = LAYER_DIV;
            layer.name = "Testimonials Section";
            layer.bg_color = ImVec4(0.95f, 0.97f, 1.0f, 1.0f);  // Light blue tint
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(450.0f, layer.height);
            layer.x = 0;
            layer.text = "What Our Clients Say|\"Amazing service!\" - Client 1|\"Highly recommend!\" - Client 2";
            layer.font_size = 42;
            break;

        case TOOL_SEC_GALLERY:
            layer.type = LAYER_DIV;
            layer.name = "Gallery Section";
            layer.bg_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);  // Dark
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Our Gallery|Image 1|Image 2|Image 3|Image 4";
            layer.font_size = 42;
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            break;

        case TOOL_SEC_BLOG:
            layer.type = LAYER_DIV;
            layer.name = "Blog Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Latest Blog Posts|Post Title 1|Post Title 2|Post Title 3";
            layer.font_size = 42;
            break;

        case TOOL_SEC_CONTACT:
            layer.type = LAYER_DIV;
            layer.name = "Contact Section";
            layer.bg_color = ImVec4(0.97f, 0.97f, 0.98f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Contact Us|Email: info@example.com|Phone: +1 234 567 890|Address: 123 Main St";
            layer.font_size = 42;
            break;

        case TOOL_SEC_FOOTER:
            layer.type = LAYER_DIV;
            layer.name = "Footer Section";
            layer.bg_color = ImVec4(0.12f, 0.12f, 0.15f, 1.0f);  // Dark
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(250.0f, layer.height);
            layer.x = 0;
            layer.text = "Company Name|About|Services|Contact|¬© 2024 All Rights Reserved";
            layer.font_size = 16;
            layer.text_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
            break;

        case TOOL_SEC_FAQ:
            layer.type = LAYER_DIV;
            layer.name = "FAQ Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Frequently Asked Questions|Q: How does it work?|A: Simple and easy!|Q: What's the price?|A: Check our pricing page.";
            layer.font_size = 42;
            break;

        case TOOL_SEC_CTA:
            layer.type = LAYER_DIV;
            layer.name = "CTA Section";
            layer.bg_color = ImVec4(0.2f, 0.4f, 0.8f, 1.0f);  // Blue
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(300.0f, layer.height);
            layer.x = 0;
            layer.text = "Ready to Get Started?|Join thousands of satisfied customers|Sign Up Now";
            layer.font_size = 48;
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            break;

        case TOOL_SEC_FEATURES:
            layer.type = LAYER_DIV;
            layer.name = "Features Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(500.0f, layer.height);
            layer.x = 0;
            layer.text = "Why Choose Us|Feature 1 - Fast|Feature 2 - Reliable|Feature 3 - Secure";
            layer.font_size = 42;
            break;

        case TOOL_SEC_STATS:
            layer.type = LAYER_DIV;
            layer.name = "Stats Section";
            layer.bg_color = ImVec4(0.08f, 0.08f, 0.12f, 1.0f);  // Dark
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(250.0f, layer.height);
            layer.x = 0;
            layer.text = "1000+|Clients|500+|Projects|50+|Awards|24/7|Support";
            layer.font_size = 48;
            layer.text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            break;

        case TOOL_SEC_LOGIN:
            layer.type = LAYER_DIV;
            layer.name = "Login Section";
            layer.bg_color = ImVec4(0.97f, 0.97f, 0.98f, 1.0f);
            layer.width = std::max(400.0f, layer.width);
            layer.height = std::max(450.0f, layer.height);
            layer.text = "Sign In|Email|Password|Login|Forgot Password?";
            layer.font_size = 32;
            layer.border_radius = 12;
            break;

        case TOOL_SEC_IMAGE:
            layer.type = LAYER_IMAGE;
            layer.name = "Image Section";
            layer.bg_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(400.0f, layer.height);
            layer.x = 0;
            layer.text = "Full Width Image";
            break;

        case TOOL_SEC_TEXTBOX:
            layer.type = LAYER_DIV;
            layer.name = "Text Box Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(300.0f, layer.height);
            layer.x = 0;
            layer.text = "Your content goes here. This is a text box section where you can add any content you want.";
            layer.font_size = 18;
            layer.text_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
            break;

        case TOOL_SEC_CUSTOM:
            layer.type = LAYER_DIV;
            layer.name = "Custom Section";
            layer.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
            layer.width = g_FigmaProject.canvas_width;
            layer.height = std::max(400.0f, layer.height);
            layer.x = 0;
            layer.text = "Custom Section";
            layer.font_size = 42;
            break;

        default:
            return;  // TOOL_SELECT shouldn't create anything
    }

    // Set z_index to be on top of all existing layers (Figma-like stacking)
    int maxZ = 0;
    for (const auto& l : g_FigmaProject.layers) {
        if (l.z_index > maxZ) maxZ = l.z_index;
    }
    layer.z_index = maxZ + 1;

    SaveUndoState("Create " + layer.name);
    g_FigmaProject.layers.push_back(layer);
    SelectLayer(layer.id);

    // Return to select tool after creating
    g_CurrentTool = TOOL_SELECT;
}

// Get tool name for display
const char* GetToolName(ToolType tool) {
    switch (tool) {
        // Basic Tools
        case TOOL_SELECT: return "Select (V)";
        case TOOL_RECTANGLE: return "Rectangle (R)";
        case TOOL_TEXT: return "Text (T)";
        case TOOL_IMAGE: return "Image (I)";
        case TOOL_BUTTON: return "Button (B)";
        case TOOL_LINE: return "Line (L)";
        case TOOL_CIRCLE: return "Circle (O)";
        case TOOL_FRAME: return "Frame (F)";
        // Typography
        case TOOL_HEADING: return "Heading (H)";
        case TOOL_SUBHEADING: return "Subheading";
        case TOOL_PARAGRAPH: return "Paragraph (P)";
        // Elements
        case TOOL_LOGO: return "Logo";
        case TOOL_INPUT: return "Input (U)";
        case TOOL_ICON: return "Icon";
        case TOOL_DIVIDER: return "Divider";
        // Website Sections
        case TOOL_SEC_HERO: return "Hero Section";
        case TOOL_SEC_NAVBAR: return "Navbar";
        case TOOL_SEC_ABOUT: return "About Section";
        case TOOL_SEC_SERVICES: return "Services Section";
        case TOOL_SEC_CARDS: return "Cards Section";
        case TOOL_SEC_TEAM: return "Team Section";
        case TOOL_SEC_PRICING: return "Pricing Section";
        case TOOL_SEC_TESTIMONIALS: return "Testimonials";
        case TOOL_SEC_GALLERY: return "Gallery Section";
        case TOOL_SEC_BLOG: return "Blog Section";
        case TOOL_SEC_CONTACT: return "Contact Section";
        case TOOL_SEC_FOOTER: return "Footer Section";
        case TOOL_SEC_FAQ: return "FAQ Section";
        case TOOL_SEC_CTA: return "CTA Section";
        case TOOL_SEC_FEATURES: return "Features Section";
        case TOOL_SEC_STATS: return "Stats Section";
        case TOOL_SEC_LOGIN: return "Login Section";
        case TOOL_SEC_IMAGE: return "Image Section";
        case TOOL_SEC_TEXTBOX: return "TextBox Section";
        case TOOL_SEC_CUSTOM: return "Custom Section";
        default: return "Unknown";
    }
}

bool ImportFigmaLayers(const std::string& url) {
    printf("[FigmaImport] Starting Figma-style import from: %s\n", url.c_str());
    g_FigmaImportInProgress = true;
    g_FigmaImportStatus = "Running layer extractor...";

    // Create output directory
    std::string outputDir = "/tmp/figma_import";
    std::string cmd = "mkdir -p " + outputDir;
    system(cmd.c_str());

    // Run Python scraper using playwright_env virtual environment
    std::string pythonCmd = "cd /Users/imaging/Desktop/Website-Builder-v2.0 && "
                           "source playwright_env/bin/activate && "
                           "python3 figma_layer_scraper.py \"" + url + "\" \"" + outputDir + "\" 2>&1";

    printf("[FigmaImport] Running: %s\n", pythonCmd.c_str());

    FILE* pipe = popen(pythonCmd.c_str(), "r");
    if (!pipe) {
        g_FigmaImportStatus = "Error: Failed to run scraper";
        g_FigmaImportInProgress = false;
        return false;
    }

    // Read output
    char buffer[256];
    std::string output;
    while (fgets(buffer, sizeof(buffer), pipe)) {
        output += buffer;
        printf("%s", buffer);
    }
    int result = pclose(pipe);

    if (result != 0) {
        g_FigmaImportStatus = "Error: Scraper failed";
        g_FigmaImportInProgress = false;
        return false;
    }

    // Parse JSON output
    std::string jsonPath = outputDir + "/layers.json";
    FILE* jsonFile = fopen(jsonPath.c_str(), "r");
    if (!jsonFile) {
        g_FigmaImportStatus = "Error: Could not open layers.json";
        g_FigmaImportInProgress = false;
        return false;
    }

    // Read JSON file
    fseek(jsonFile, 0, SEEK_END);
    long fileSize = ftell(jsonFile);
    fseek(jsonFile, 0, SEEK_SET);
    std::string jsonContent(fileSize, '\0');
    fread(&jsonContent[0], 1, fileSize, jsonFile);
    fclose(jsonFile);

    // Simple JSON parsing (for our specific format)
    g_FigmaProject = FigmaProject();
    g_FigmaProject.layers.clear();

    // Parse canvas dimensions
    size_t widthPos = jsonContent.find("\"canvas_width\":");
    size_t heightPos = jsonContent.find("\"canvas_height\":");
    if (widthPos != std::string::npos) {
        g_FigmaProject.canvas_width = std::stof(jsonContent.substr(widthPos + 15, 10));
    }
    if (heightPos != std::string::npos) {
        g_FigmaProject.canvas_height = std::stof(jsonContent.substr(heightPos + 16, 10));
    }

    // Parse source_url for internal navigation
    size_t srcUrlPos = jsonContent.find("\"source_url\":");
    if (srcUrlPos != std::string::npos) {
        size_t start = jsonContent.find("\"", srcUrlPos + 13) + 1;
        size_t end = jsonContent.find("\"", start);
        g_FigmaProject.source_url = jsonContent.substr(start, end - start);
        printf("[FigmaImport] Source URL: %s\n", g_FigmaProject.source_url.c_str());
    }

    // Parse screenshot path
    size_t ssPos = jsonContent.find("\"screenshot_path\":");
    if (ssPos != std::string::npos) {
        size_t start = jsonContent.find("\"", ssPos + 18) + 1;
        size_t end = jsonContent.find("\"", start);
        g_FigmaProject.screenshot_path = jsonContent.substr(start, end - start);

        // Load screenshot texture
        int w, h, n;
        unsigned char* data = stbi_load(g_FigmaProject.screenshot_path.c_str(), &w, &h, &n, 4);
        if (data) {
            glGenTextures(1, &g_FigmaProject.screenshot_texture_id);
            glBindTexture(GL_TEXTURE_2D, g_FigmaProject.screenshot_texture_id);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
            printf("[FigmaImport] Loaded screenshot: %dx%d\n", w, h);
        }
    }

    // Parse layers array (simplified parsing)
    size_t layersStart = jsonContent.find("\"layers\":");
    if (layersStart == std::string::npos) {
        g_FigmaImportStatus = "Error: No layers found in JSON";
        g_FigmaImportInProgress = false;
        return false;
    }

    // Find each layer object - look for "id": pattern (with possible whitespace)
    size_t pos = layersStart;
    int layerCount = 0;
    // Match both {"id": and {\n  "id": patterns
    while (true) {
        size_t idPos1 = jsonContent.find("\"id\":", pos);
        if (idPos1 == std::string::npos) break;
        pos = idPos1;
        WebLayer layer;

        // Parse id - skip whitespace after "id":
        size_t idStart = pos + 5;  // Skip "id":
        while (idStart < jsonContent.size() && (jsonContent[idStart] == ' ' || jsonContent[idStart] == '\t')) idStart++;
        layer.id = std::stoi(jsonContent.substr(idStart, 10));

        // Parse type
        size_t typePos = jsonContent.find("\"type\":", pos);
        if (typePos != std::string::npos && typePos < pos + 2000) {
            size_t typeStart = jsonContent.find("\"", typePos + 7) + 1;
            size_t typeEnd = jsonContent.find("\"", typeStart);
            std::string typeStr = jsonContent.substr(typeStart, typeEnd - typeStart);
            if (typeStr == "LAYER_TEXT") layer.type = LAYER_TEXT;
            else if (typeStr == "LAYER_IMAGE") layer.type = LAYER_IMAGE;
            else if (typeStr == "LAYER_BUTTON") layer.type = LAYER_BUTTON;
            else if (typeStr == "LAYER_INPUT") layer.type = LAYER_INPUT;
            else layer.type = LAYER_DIV;
        }

        // Parse position and size
        auto parseFloat = [&](const char* key) -> float {
            size_t keyPos = jsonContent.find(key, pos);
            if (keyPos != std::string::npos && keyPos < pos + 2000) {
                size_t valStart = keyPos + strlen(key);
                try {
                    std::string valStr = jsonContent.substr(valStart, 20);
                    // Skip whitespace and find start of number
                    size_t numStart = valStr.find_first_of("-0123456789.");
                    if (numStart != std::string::npos) {
                        return std::stof(valStr.substr(numStart));
                    }
                } catch (...) {
                    // Invalid float value, return default
                }
            }
            return 0;
        };

        auto parseString = [&](const char* key) -> std::string {
            size_t keyPos = jsonContent.find(key, pos);
            if (keyPos != std::string::npos && keyPos < pos + 3000) {
                size_t start = jsonContent.find("\"", keyPos + strlen(key)) + 1;
                size_t end = jsonContent.find("\"", start);
                if (end > start && end - start < 1000) {
                    return jsonContent.substr(start, end - start);
                }
            }
            return "";
        };

        layer.x = parseFloat("\"x\":");
        layer.y = parseFloat("\"y\":");
        layer.width = parseFloat("\"width\":");
        layer.height = parseFloat("\"height\":");
        layer.z_index = (int)parseFloat("\"z_index\":");
        layer.font_size = parseFloat("\"font_size\":");
        layer.font_weight = parseFloat("\"font_weight\":");
        layer.opacity = parseFloat("\"opacity\":");
        layer.border_width = parseFloat("\"border_width\":");
        layer.border_radius = parseFloat("\"border_radius\":");

        layer.name = parseString("\"name\":");
        layer.text = parseString("\"text\":");
        layer.image_path = parseString("\"image_path\":");
        layer.href = parseString("\"href\":");
        layer.font_family = parseString("\"font_family\":");
        layer.font_style = parseString("\"font_style\":");
        layer.text_decoration = parseString("\"text_decoration\":");
        layer.box_shadow = parseString("\"box_shadow\":");

        // Parse button-specific properties
        layer.element_id = parseString("\"element_id\":");
        layer.button_type = parseString("\"button_type\":");
        if (layer.button_type.empty()) layer.button_type = "button";
        layer.action_type = parseString("\"action_type\":");
        layer.onclick_action = parseString("\"onclick_action\":");
        layer.data_target = parseString("\"data_target\":");
        layer.form_id = parseString("\"form_id\":");

        // Parse disabled (boolean from JSON)
        std::string disabledStr = parseString("\"disabled\":");
        // Handle boolean values - check for "true" or presence in non-string context
        size_t disabledPos = jsonContent.find("\"disabled\":", pos);
        if (disabledPos != std::string::npos && disabledPos < pos + 2000) {
            size_t valStart = disabledPos + 11; // length of "disabled":
            while (valStart < jsonContent.size() && (jsonContent[valStart] == ' ' || jsonContent[valStart] == '\t')) valStart++;
            if (valStart < jsonContent.size()) {
                layer.disabled = (jsonContent[valStart] == 't'); // true starts with 't'
            }
        }

        // Parse text alignment (string to int)
        std::string textAlignStr = parseString("\"text_align\":");
        if (textAlignStr == "center") layer.text_align = 1;
        else if (textAlignStr == "right") layer.text_align = 2;
        else if (textAlignStr == "justify") layer.text_align = 3;
        else layer.text_align = 0;  // left

        // Parse additional numeric properties
        layer.letter_spacing = parseFloat("\"letter_spacing\":");
        layer.line_height = parseFloat("\"line_height\":");
        if (layer.line_height <= 0) layer.line_height = 1.2f;

        // Individual border radii
        layer.border_radius_tl = parseFloat("\"border_radius_tl\":");
        layer.border_radius_tr = parseFloat("\"border_radius_tr\":");
        layer.border_radius_br = parseFloat("\"border_radius_br\":");
        layer.border_radius_bl = parseFloat("\"border_radius_bl\":");

        // Individual border widths
        layer.border_top_width = parseFloat("\"border_top_width\":");
        layer.border_right_width = parseFloat("\"border_right_width\":");
        layer.border_bottom_width = parseFloat("\"border_bottom_width\":");
        layer.border_left_width = parseFloat("\"border_left_width\":");

        // Typography enhancements
        layer.text_transform = parseString("\"text_transform\":");
        if (layer.text_transform.empty()) layer.text_transform = "none";
        layer.text_shadow = parseString("\"text_shadow\":");
        layer.word_spacing = parseString("\"word_spacing\":");

        // Effects
        layer.backdrop_filter = parseString("\"backdrop_filter\":");
        layer.filter = parseString("\"filter\":");
        layer.mix_blend_mode = parseString("\"mix_blend_mode\":");
        if (layer.mix_blend_mode.empty()) layer.mix_blend_mode = "normal";

        // Gradient
        layer.gradient_css = parseString("\"gradient\":");
        layer.has_gradient = !layer.gradient_css.empty();

        // Transform
        layer.transform = parseString("\"transform\":");
        layer.transform_origin = parseString("\"transform_origin\":");

        // Background
        layer.background_size = parseString("\"background_size\":");
        layer.background_position = parseString("\"background_position\":");
        layer.background_repeat = parseString("\"background_repeat\":");

        // Layout
        layer.overflow = parseString("\"overflow\":");
        layer.cursor = parseString("\"cursor\":");
        layer.flex_direction = parseString("\"flex_direction\":");
        layer.justify_content = parseString("\"justify_content\":");
        layer.align_items = parseString("\"align_items\":");
        layer.gap = parseString("\"gap\":");

        // Parse colors
        std::string bgColor = parseString("\"bg_color\":");
        std::string textColor = parseString("\"text_color\":");
        layer.bg_color = ParseColorString(bgColor);
        layer.text_color = ParseColorString(textColor);

        // Parse individual border colors
        std::string borderTopColor = parseString("\"border_top_color\":");
        std::string borderRightColor = parseString("\"border_right_color\":");
        std::string borderBottomColor = parseString("\"border_bottom_color\":");
        std::string borderLeftColor = parseString("\"border_left_color\":");
        layer.border_top_color = ParseColorString(borderTopColor);
        layer.border_right_color = ParseColorString(borderRightColor);
        layer.border_bottom_color = ParseColorString(borderBottomColor);
        layer.border_left_color = ParseColorString(borderLeftColor);

        // Load image texture if needed (for images, buttons with bg, divs with bg)
        if (!layer.image_path.empty()) {
            int w, h, n;
            unsigned char* data = stbi_load(layer.image_path.c_str(), &w, &h, &n, 4);
            if (data) {
                glGenTextures(1, &layer.texture_id);
                glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                stbi_image_free(data);
                printf("[FigmaImport] Loaded texture: %s (%dx%d)\n", layer.image_path.c_str(), w, h);
            } else {
                printf("[FigmaImport] Failed to load: %s\n", layer.image_path.c_str());
            }
        }

        g_FigmaProject.layers.push_back(layer);
        layerCount++;

        // Move pos forward to find the next layer (skip past current "id":)
        pos += 10;

        if (layerCount > 500) break;  // Safety limit
    }

    printf("[FigmaImport] Parsed %d layers\n", layerCount);

    // Parse multi-page data (if available)
    size_t pagesPos = jsonContent.find("\"pages\":");
    if (pagesPos != std::string::npos) {
        printf("[FigmaImport] Found multi-page data, parsing pages...\n");

        // Store home page layers in pages map
        std::string homePath = "/";
        g_FigmaProject.pages[homePath] = WebPage();
        g_FigmaProject.pages[homePath].url = g_FigmaProject.source_url;
        g_FigmaProject.pages[homePath].layers = g_FigmaProject.layers;
        g_FigmaProject.pages[homePath].canvas_height = g_FigmaProject.canvas_height;
        g_FigmaProject.pages[homePath].screenshot_path = g_FigmaProject.screenshot_path;
        g_FigmaProject.pages[homePath].screenshot_texture_id = g_FigmaProject.screenshot_texture_id;
        g_FigmaProject.page_order.push_back(homePath);
        g_FigmaProject.current_page = homePath;

        // Find page paths by looking for pattern: "/<path>": { or "/": {
        size_t pageSearchPos = pagesPos;
        while (true) {
            // Look for page path pattern (starts with "/" in quotes followed by colon and brace)
            size_t pathQuoteStart = jsonContent.find("\"/", pageSearchPos);
            if (pathQuoteStart == std::string::npos || pathQuoteStart > jsonContent.find("]", pagesPos)) break;

            size_t pathQuoteEnd = jsonContent.find("\":", pathQuoteStart + 1);
            if (pathQuoteEnd == std::string::npos) break;

            std::string pagePath = jsonContent.substr(pathQuoteStart + 1, pathQuoteEnd - pathQuoteStart - 1);
            if (pagePath.empty() || pagePath[0] != '/') {
                pageSearchPos = pathQuoteEnd + 1;
                continue;
            }

            // Skip home page (already added)
            if (pagePath == "/") {
                pageSearchPos = pathQuoteEnd + 1;
                continue;
            }

            // Find the page object boundaries
            size_t pageObjStart = jsonContent.find("{", pathQuoteEnd);
            if (pageObjStart == std::string::npos) break;

            // Look for "layers": within this page object
            size_t pageLayersPos = jsonContent.find("\"layers\":", pageObjStart);
            if (pageLayersPos == std::string::npos) {
                pageSearchPos = pageObjStart + 1;
                continue;
            }

            // Parse this page's URL
            std::string pageUrl = "";
            size_t urlPos = jsonContent.find("\"url\":", pageObjStart);
            if (urlPos != std::string::npos && urlPos < pageLayersPos) {
                size_t urlStart = jsonContent.find("\"", urlPos + 6) + 1;
                size_t urlEnd = jsonContent.find("\"", urlStart);
                pageUrl = jsonContent.substr(urlStart, urlEnd - urlStart);
            }

            // Parse canvas_height for this page
            float pageHeight = g_FigmaProject.canvas_height;
            size_t chPos = jsonContent.find("\"canvas_height\":", pageObjStart);
            if (chPos != std::string::npos && chPos < pageLayersPos) {
                pageHeight = std::stof(jsonContent.substr(chPos + 16, 10));
            }

            // Parse screenshot_path for this page
            std::string pageScreenshot = "";
            size_t pssPos = jsonContent.find("\"screenshot_path\":", pageObjStart);
            if (pssPos != std::string::npos && pssPos < pageLayersPos) {
                size_t ssStart = jsonContent.find("\"", pssPos + 18) + 1;
                size_t ssEnd = jsonContent.find("\"", ssStart);
                pageScreenshot = jsonContent.substr(ssStart, ssEnd - ssStart);
            }

            // Create page entry
            WebPage newPage;
            newPage.url = pageUrl;
            newPage.canvas_height = pageHeight;
            newPage.screenshot_path = pageScreenshot;

            // Load screenshot texture for this page
            if (!pageScreenshot.empty()) {
                int w, h, n;
                unsigned char* data = stbi_load(pageScreenshot.c_str(), &w, &h, &n, 4);
                if (data) {
                    glGenTextures(1, &newPage.screenshot_texture_id);
                    glBindTexture(GL_TEXTURE_2D, newPage.screenshot_texture_id);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                    stbi_image_free(data);
                }
            }

            // Parse layers for this page (using similar logic as main layers)
            size_t pageLayerPos = pageLayersPos;
            while (true) {
                size_t idPos = jsonContent.find("\"id\":", pageLayerPos);
                // Check if we've gone past this page's layers array
                size_t nextPageStart = jsonContent.find("\"/", pageLayersPos + 10);
                if (idPos == std::string::npos || (nextPageStart != std::string::npos && idPos > nextPageStart)) break;

                // Check if this id is inside another "layers" array (next page)
                size_t nextLayersArray = jsonContent.find("\"layers\":", pageLayerPos + 10);
                if (nextLayersArray != std::string::npos && idPos > nextLayersArray) break;

                WebLayer layer;
                size_t idStart = idPos + 5;
                while (idStart < jsonContent.size() && (jsonContent[idStart] == ' ' || jsonContent[idStart] == '\t')) idStart++;

                try {
                    layer.id = std::stoi(jsonContent.substr(idStart, 10));
                } catch (...) {
                    pageLayerPos = idPos + 5;
                    continue;
                }

                // Parse type
                size_t typePos = jsonContent.find("\"type\":", idPos);
                if (typePos != std::string::npos && typePos < idPos + 2000) {
                    size_t typeStart = jsonContent.find("\"", typePos + 7) + 1;
                    size_t typeEnd = jsonContent.find("\"", typeStart);
                    std::string typeStr = jsonContent.substr(typeStart, typeEnd - typeStart);
                    if (typeStr == "LAYER_TEXT") layer.type = LAYER_TEXT;
                    else if (typeStr == "LAYER_IMAGE") layer.type = LAYER_IMAGE;
                    else if (typeStr == "LAYER_BUTTON") layer.type = LAYER_BUTTON;
                    else if (typeStr == "LAYER_INPUT") layer.type = LAYER_INPUT;
                    else layer.type = LAYER_DIV;
                }

                // Parse basic properties
                auto parseFloatPage = [&](const char* key) -> float {
                    size_t keyPos = jsonContent.find(key, idPos);
                    if (keyPos != std::string::npos && keyPos < idPos + 2000) {
                        size_t valStart = keyPos + strlen(key);
                        try {
                            std::string valStr = jsonContent.substr(valStart, 20);
                            size_t numStart = valStr.find_first_of("-0123456789.");
                            if (numStart != std::string::npos) {
                                return std::stof(valStr.substr(numStart));
                            }
                        } catch (...) {}
                    }
                    return 0;
                };

                auto parseStringPage = [&](const char* key) -> std::string {
                    size_t keyPos = jsonContent.find(key, idPos);
                    if (keyPos != std::string::npos && keyPos < idPos + 3000) {
                        size_t start = jsonContent.find("\"", keyPos + strlen(key)) + 1;
                        size_t end = jsonContent.find("\"", start);
                        if (end > start && end - start < 1000) {
                            return jsonContent.substr(start, end - start);
                        }
                    }
                    return "";
                };

                layer.x = parseFloatPage("\"x\":");
                layer.y = parseFloatPage("\"y\":");
                layer.width = parseFloatPage("\"width\":");
                layer.height = parseFloatPage("\"height\":");
                layer.name = parseStringPage("\"name\":");
                layer.text = parseStringPage("\"text\":");
                layer.href = parseStringPage("\"href\":");
                layer.element_id = parseStringPage("\"element_id\":");
                layer.action_type = parseStringPage("\"action_type\":");

                std::string bgColor = parseStringPage("\"bg_color\":");
                std::string textColor = parseStringPage("\"text_color\":");
                layer.bg_color = ParseColorString(bgColor);
                layer.text_color = ParseColorString(textColor);
                layer.font_size = parseFloatPage("\"font_size\":");
                layer.border_radius = parseFloatPage("\"border_radius\":");
                layer.opacity = parseFloatPage("\"opacity\":");

                newPage.layers.push_back(layer);
                pageLayerPos = idPos + 10;

                if (newPage.layers.size() > 500) break;
            }

            g_FigmaProject.pages[pagePath] = newPage;
            g_FigmaProject.page_order.push_back(pagePath);
            printf("[FigmaImport] Loaded page: %s (%zu layers)\n", pagePath.c_str(), newPage.layers.size());

            pageSearchPos = pageLayersPos + 10;
        }

        printf("[FigmaImport] Total pages loaded: %zu\n", g_FigmaProject.pages.size());
    }

    // Parse sections array (if available)
    g_FigmaProject.sections.clear();
    size_t sectionsPos = jsonContent.find("\"sections\":");
    if (sectionsPos != std::string::npos) {
        printf("[FigmaImport] Found sections data, parsing...\n");

        size_t sectionsStart = jsonContent.find("[", sectionsPos);
        size_t sectionsEnd = jsonContent.find("]", sectionsStart);

        if (sectionsStart != std::string::npos && sectionsEnd != std::string::npos) {
            std::string sectionsContent = jsonContent.substr(sectionsStart, sectionsEnd - sectionsStart + 1);

            // Parse each section object
            size_t secPos = 0;
            while (true) {
                size_t secIdPos = sectionsContent.find("\"id\":", secPos);
                if (secIdPos == std::string::npos) break;

                FigmaSection section;

                // Parse section id
                size_t idStart = secIdPos + 5;
                while (idStart < sectionsContent.size() && (sectionsContent[idStart] == ' ' || sectionsContent[idStart] == '\t')) idStart++;
                section.id = std::stoi(sectionsContent.substr(idStart, 10));

                // Parse section name
                size_t namePos = sectionsContent.find("\"name\":", secIdPos);
                if (namePos != std::string::npos && namePos < secIdPos + 500) {
                    size_t nameStart = sectionsContent.find("\"", namePos + 7) + 1;
                    size_t nameEnd = sectionsContent.find("\"", nameStart);
                    section.name = sectionsContent.substr(nameStart, nameEnd - nameStart);
                }

                // Parse y_start and y_end
                size_t yStartPos = sectionsContent.find("\"y_start\":", secIdPos);
                if (yStartPos != std::string::npos && yStartPos < secIdPos + 500) {
                    size_t valStart = yStartPos + 10;
                    while (valStart < sectionsContent.size() && (sectionsContent[valStart] == ' ' || sectionsContent[valStart] == '\t')) valStart++;
                    section.y_start = std::stof(sectionsContent.substr(valStart, 15));
                }

                size_t yEndPos = sectionsContent.find("\"y_end\":", secIdPos);
                if (yEndPos != std::string::npos && yEndPos < secIdPos + 500) {
                    size_t valStart = yEndPos + 8;
                    while (valStart < sectionsContent.size() && (sectionsContent[valStart] == ' ' || sectionsContent[valStart] == '\t')) valStart++;
                    section.y_end = std::stof(sectionsContent.substr(valStart, 15));
                }

                // Parse layer_ids array
                size_t layerIdsPos = sectionsContent.find("\"layer_ids\":", secIdPos);
                if (layerIdsPos != std::string::npos && layerIdsPos < secIdPos + 1000) {
                    size_t arrStart = sectionsContent.find("[", layerIdsPos);
                    size_t arrEnd = sectionsContent.find("]", arrStart);
                    if (arrStart != std::string::npos && arrEnd != std::string::npos) {
                        std::string idsStr = sectionsContent.substr(arrStart + 1, arrEnd - arrStart - 1);
                        // Parse comma-separated integers
                        size_t idPos = 0;
                        while (idPos < idsStr.size()) {
                            // Skip whitespace and commas
                            while (idPos < idsStr.size() && (idsStr[idPos] == ' ' || idsStr[idPos] == ',' || idsStr[idPos] == '\n' || idsStr[idPos] == '\t')) idPos++;
                            if (idPos >= idsStr.size()) break;

                            // Read integer
                            size_t idEnd = idPos;
                            while (idEnd < idsStr.size() && isdigit(idsStr[idEnd])) idEnd++;
                            if (idEnd > idPos) {
                                int layerId = std::stoi(idsStr.substr(idPos, idEnd - idPos));
                                section.layer_ids.push_back(layerId);
                            }
                            idPos = idEnd;
                        }
                    }
                }

                section.expanded = true;
                g_FigmaProject.sections.push_back(section);
                printf("[FigmaImport] Section: %s (%zu layers, y: %.0f-%.0f)\n",
                       section.name.c_str(), section.layer_ids.size(), section.y_start, section.y_end);

                secPos = secIdPos + 10;
            }
        }
        printf("[FigmaImport] Total sections loaded: %zu\n", g_FigmaProject.sections.size());
    }

    g_FigmaMode = true;
    g_FigmaImportInProgress = false;
    g_FigmaImportStatus = "Success! Imported " + std::to_string(layerCount) + " layers";
    if (!g_FigmaProject.sections.empty()) {
        g_FigmaImportStatus += " (" + std::to_string(g_FigmaProject.sections.size()) + " sections)";
    }

    // Ensure imported buttons point to internal anchors
    RewriteFigmaActionsToInternal();

    // Auto-save to database
    if (g_DBConnection && !g_FigmaProject.layers.empty()) {
        // Generate template name from source URL
        std::string templateName = g_FigmaProject.name;
        if (templateName.empty()) {
            templateName = "Imported_" + std::to_string(time(nullptr));
        }
        // Remove invalid characters
        for (char& c : templateName) {
            if (c == '.' || c == '/' || c == ':' || c == '?') c = '_';
        }

        if (SaveAsImGuiTemplate(templateName)) {
            printf("[FigmaImport] Auto-saved to database as: %s\n", templateName.c_str());
            g_FigmaImportStatus += " (Saved to DB)";
        }
    }

    return true;
}

// Load a saved Figma project from JSON file
bool LoadFigmaProject(const std::string& filepath) {
    FILE* f = fopen(filepath.c_str(), "r");
    if (!f) {
        printf("[Figma] Failed to open project file: %s\n", filepath.c_str());
        return false;
    }

    // Read entire file
    fseek(f, 0, SEEK_END);
    long fileSize = ftell(f);
    fseek(f, 0, SEEK_SET);

    std::string content(fileSize, '\0');
    fread(&content[0], 1, fileSize, f);
    fclose(f);

    printf("[Figma] Loading project from: %s\n", filepath.c_str());

    // Clear current project
    g_FigmaProject = FigmaProject();
    g_FigmaProject.layers.clear();

    // Parse project info
    size_t namePos = content.find("\"name\":");
    if (namePos != std::string::npos) {
        size_t start = content.find("\"", namePos + 7) + 1;
        size_t end = content.find("\"", start);
        g_FigmaProject.name = content.substr(start, end - start);
    }

    size_t cwPos = content.find("\"canvas_width\":");
    if (cwPos != std::string::npos) {
        g_FigmaProject.canvas_width = atof(content.c_str() + cwPos + 15);
    }

    size_t chPos = content.find("\"canvas_height\":");
    if (chPos != std::string::npos) {
        g_FigmaProject.canvas_height = atof(content.c_str() + chPos + 16);
    }

    size_t ssPos = content.find("\"screenshot_path\":");
    if (ssPos != std::string::npos) {
        size_t start = content.find("\"", ssPos + 18) + 1;
        size_t end = content.find("\"", start);
        g_FigmaProject.screenshot_path = content.substr(start, end - start);
    }

    // Load screenshot texture
    if (!g_FigmaProject.screenshot_path.empty()) {
        int w, h, n;
        unsigned char* data = stbi_load(g_FigmaProject.screenshot_path.c_str(), &w, &h, &n, 4);
        if (data) {
            glGenTextures(1, &g_FigmaProject.screenshot_texture_id);
            glBindTexture(GL_TEXTURE_2D, g_FigmaProject.screenshot_texture_id);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
            printf("[Figma] Loaded screenshot: %dx%d\n", w, h);
        }
    }

    // Parse layers
    size_t layersPos = content.find("\"layers\":");
    if (layersPos == std::string::npos) {
        printf("[Figma] No layers found in project\n");
        g_FigmaMode = true;
        return true;
    }

    int layerCount = 0;
    size_t pos = layersPos;
    while ((pos = content.find("\"id\":", pos)) != std::string::npos) {
        WebLayer layer;

        // Parse id
        layer.id = atoi(content.c_str() + pos + 5);

        // Parse type
        size_t typePos = content.find("\"type\":", pos);
        if (typePos != std::string::npos && typePos < pos + 500) {
            size_t start = content.find("\"", typePos + 7) + 1;
            size_t end = content.find("\"", start);
            std::string typeStr = content.substr(start, end - start);
            if (typeStr == "LAYER_TEXT") layer.type = LAYER_TEXT;
            else if (typeStr == "LAYER_IMAGE") layer.type = LAYER_IMAGE;
            else if (typeStr == "LAYER_BUTTON") layer.type = LAYER_BUTTON;
            else layer.type = LAYER_DIV;
        }

        // Parse name
        size_t nameP = content.find("\"name\":", pos);
        if (nameP != std::string::npos && nameP < pos + 500) {
            size_t start = content.find("\"", nameP + 7) + 1;
            size_t end = content.find("\"", start);
            layer.name = content.substr(start, end - start);
        }

        // Parse x, y, width, height
        size_t xPos = content.find("\"x\":", pos);
        if (xPos != std::string::npos && xPos < pos + 500) {
            layer.x = atof(content.c_str() + xPos + 4);
        }
        size_t yPos = content.find("\"y\":", pos);
        if (yPos != std::string::npos && yPos < pos + 500) {
            layer.y = atof(content.c_str() + yPos + 4);
        }
        size_t wPos = content.find("\"width\":", pos);
        if (wPos != std::string::npos && wPos < pos + 500) {
            layer.width = atof(content.c_str() + wPos + 8);
        }
        size_t hPos = content.find("\"height\":", pos);
        if (hPos != std::string::npos && hPos < pos + 500) {
            layer.height = atof(content.c_str() + hPos + 9);
        }

        // Parse text
        size_t textPos = content.find("\"text\":", pos);
        if (textPos != std::string::npos && textPos < pos + 500) {
            size_t start = content.find("\"", textPos + 7) + 1;
            size_t end = content.find("\"", start);
            layer.text = content.substr(start, end - start);
        }

        // Parse font_size
        size_t fsPos = content.find("\"font_size\":", pos);
        if (fsPos != std::string::npos && fsPos < pos + 500) {
            layer.font_size = atof(content.c_str() + fsPos + 12);
        }

        // Parse opacity
        size_t opPos = content.find("\"opacity\":", pos);
        if (opPos != std::string::npos && opPos < pos + 500) {
            layer.opacity = atof(content.c_str() + opPos + 10);
        }

        // Parse colors using the global ParseColorString function
        // Set defaults first (visible colors for old projects without color data)
        layer.bg_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);  // Light gray default
        layer.text_color = ImVec4(0, 0, 0, 1);  // Black text
        layer.border_color = ImVec4(0, 0, 0, 1);  // Black border

        size_t bgColorPos = content.find("\"bg_color\":", pos);
        if (bgColorPos != std::string::npos && bgColorPos < pos + 500) {
            size_t start = content.find("\"", bgColorPos + 11) + 1;
            size_t end = content.find("\"", start);
            std::string colorStr = content.substr(start, end - start);
            ImVec4 parsed = ParseColorString(colorStr);
            // Only use parsed color if it has valid alpha
            if (parsed.w > 0.01f || colorStr.find("rgba") != std::string::npos) {
                layer.bg_color = parsed;
            }
        }

        size_t textColorPos = content.find("\"text_color\":", pos);
        if (textColorPos != std::string::npos && textColorPos < pos + 500) {
            size_t start = content.find("\"", textColorPos + 13) + 1;
            size_t end = content.find("\"", start);
            std::string colorStr = content.substr(start, end - start);
            layer.text_color = ParseColorString(colorStr);
        }

        size_t borderColorPos = content.find("\"border_color\":", pos);
        if (borderColorPos != std::string::npos && borderColorPos < pos + 500) {
            size_t start = content.find("\"", borderColorPos + 15) + 1;
            size_t end = content.find("\"", start);
            std::string colorStr = content.substr(start, end - start);
            layer.border_color = ParseColorString(colorStr);
        }

        // Parse border_width and border_radius
        size_t bwPos = content.find("\"border_width\":", pos);
        if (bwPos != std::string::npos && bwPos < pos + 500) {
            layer.border_width = atof(content.c_str() + bwPos + 15);
        }

        size_t brPos = content.find("\"border_radius\":", pos);
        if (brPos != std::string::npos && brPos < pos + 500) {
            layer.border_radius = atof(content.c_str() + brPos + 16);
        }

        // Parse image_path (if present)
        size_t imgPos = content.find("\"image_path\":", pos);
        if (imgPos != std::string::npos && imgPos < pos + 500) {
            size_t start = content.find("\"", imgPos + 13) + 1;
            size_t end = content.find("\"", start);
            layer.image_path = content.substr(start, end - start);

            // Load texture if image layer
            if (layer.type == LAYER_IMAGE && !layer.image_path.empty()) {
                int w, h, n;
                unsigned char* data = stbi_load(layer.image_path.c_str(), &w, &h, &n, 4);
                if (data) {
                    glGenTextures(1, &layer.texture_id);
                    glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                    stbi_image_free(data);
                }
            }
        }

        // Debug: print parsed colors for first 5 layers
        if (layerCount < 5) {
            printf("[Figma] Layer %d '%s': bg_color=(%.2f,%.2f,%.2f,%.2f) text_color=(%.2f,%.2f,%.2f,%.2f)\n",
                layer.id, layer.name.c_str(),
                layer.bg_color.x, layer.bg_color.y, layer.bg_color.z, layer.bg_color.w,
                layer.text_color.x, layer.text_color.y, layer.text_color.z, layer.text_color.w);
        }

        g_FigmaProject.layers.push_back(layer);
        g_FigmaProject.next_layer_id = std::max(g_FigmaProject.next_layer_id, layer.id + 1);
        layerCount++;
        pos += 10;

        if (layerCount > 500) break;
    }

    printf("[Figma] Loaded %d layers\n", layerCount);
    g_FigmaMode = true;
    return true;
}

// Get list of saved projects
std::vector<std::string> GetSavedFigmaProjects() {
    std::vector<std::string> projects;
    std::string dir = "/Users/imaging/Desktop/Website-Builder-v2.0/figma_projects/";

    DIR* d = opendir(dir.c_str());
    if (d) {
        struct dirent* entry;
        while ((entry = readdir(d)) != NULL) {
            std::string name = entry->d_name;
            if (name.size() > 5 && name.substr(name.size() - 5) == ".json") {
                projects.push_back(dir + name);
            }
        }
        closedir(d);
    }
    return projects;
}

void RenderFigmaCanvas() {
    ImGuiIO& io = ImGui::GetIO();
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    // Reset hovered layer for this frame
    g_HoveredLayerId = -1;

    // Get canvas area
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImGui::GetContentRegionAvail();

    // Background
    drawList->AddRectFilled(canvasPos,
        ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y),
        IM_COL32(40, 40, 45, 255));

    // IMPORTANT: Clip all canvas content to the canvas area
    drawList->PushClipRect(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), true);

    // Calculate visible area based on scroll and zoom
    float zoom = g_FigmaProject.zoom;
    float scrollX = g_FigmaProject.scroll_x;
    float scrollY = g_FigmaProject.scroll_y;

    // Draw reference screenshot if enabled
    if (g_FigmaProject.show_reference && g_FigmaProject.screenshot_texture_id) {
        float imgW = g_FigmaProject.canvas_width * zoom;
        float imgH = g_FigmaProject.canvas_height * zoom;
        ImVec2 imgPos(canvasPos.x - scrollX, canvasPos.y - scrollY);

        // Draw reference screenshot with opacity using drawlist (no SetCursorScreenPos needed)
        ImU32 tintCol = IM_COL32(255, 255, 255, (int)(g_FigmaProject.reference_opacity * 255));
        drawList->AddImage((ImTextureID)(intptr_t)g_FigmaProject.screenshot_texture_id,
            imgPos,
            ImVec2(imgPos.x + imgW, imgPos.y + imgH),
            ImVec2(0, 0), ImVec2(1, 1), tintCol);
    }

    // Draw the design page background (the white page area)
    if (!g_FigmaProject.show_reference || g_FigmaProject.reference_opacity < 0.9f) {
        float pageW = g_FigmaProject.canvas_width * zoom;
        float pageH = g_FigmaProject.canvas_height * zoom;
        ImVec2 pagePos(canvasPos.x - scrollX, canvasPos.y - scrollY);

        // Draw page background with user-selected color
        drawList->AddRectFilled(
            pagePos,
            ImVec2(pagePos.x + pageW, pagePos.y + pageH),
            ImGui::ColorConvertFloat4ToU32(g_FigmaProject.canvas_bg_color));

        // Draw page border/shadow
        drawList->AddRect(pagePos, ImVec2(pagePos.x + pageW, pagePos.y + pageH),
            IM_COL32(0, 0, 0, 50), 0, 0, 2.0f);
    }

    // Draw grid if enabled
    if (g_FigmaProject.show_grid) {
        float gridSize = g_FigmaProject.grid_size * zoom;
        ImU32 gridColor = IM_COL32(60, 60, 65, 100);

        for (float x = fmod(-scrollX, gridSize); x < canvasSize.x; x += gridSize) {
            drawList->AddLine(
                ImVec2(canvasPos.x + x, canvasPos.y),
                ImVec2(canvasPos.x + x, canvasPos.y + canvasSize.y),
                gridColor);
        }
        for (float y = fmod(-scrollY, gridSize); y < canvasSize.y; y += gridSize) {
            drawList->AddLine(
                ImVec2(canvasPos.x, canvasPos.y + y),
                ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + y),
                gridColor);
        }
    }

    // Draw layers - always draw layer content so edits are visible
    // When reference is visible, layers will appear on top of the reference
    bool useOverlayMode = false;  // Always show layer content for editing

    // Sort layers for correct rendering: lower z_index first (background), then by layer ID
    // This ensures parent containers (like body) render behind child elements
    std::vector<WebLayer*> sortedLayers;
    for (auto& layer : g_FigmaProject.layers) {
        sortedLayers.push_back(&layer);
    }
    std::sort(sortedLayers.begin(), sortedLayers.end(), [](WebLayer* a, WebLayer* b) {
        if (a->z_index != b->z_index) return a->z_index < b->z_index;
        // Same z_index: larger layers (containers) render first, smaller layers on top
        float areaA = a->width * a->height;
        float areaB = b->width * b->height;
        return areaA > areaB;  // Larger area first (background)
    });

    for (auto* layerPtr : sortedLayers) {
        WebLayer& layer = *layerPtr;
        if (!layer.visible) continue;

        // Calculate screen position
        float screenX = canvasPos.x + (layer.x * zoom) - scrollX;
        float screenY = canvasPos.y + (layer.y * zoom) - scrollY;
        float screenW = layer.width * zoom;
        float screenH = layer.height * zoom;

        // Skip if outside visible area
        if (screenX + screenW < canvasPos.x || screenX > canvasPos.x + canvasSize.x) continue;
        if (screenY + screenH < canvasPos.y || screenY > canvasPos.y + canvasSize.y) continue;

        ImVec2 p1(screenX, screenY);
        ImVec2 p2(screenX + screenW, screenY + screenH);

        // In overlay mode (reference visible), don't draw layer fills - let screenshot show through
        // Only draw content when reference is hidden or very transparent
        if (!useOverlayMode) {
            // Calculate effective border radius (use individual corners if available)
            float radiusTL = (layer.border_radius_tl > 0 ? layer.border_radius_tl : layer.border_radius) * zoom;
            float radiusTR = (layer.border_radius_tr > 0 ? layer.border_radius_tr : layer.border_radius) * zoom;
            float radiusBR = (layer.border_radius_br > 0 ? layer.border_radius_br : layer.border_radius) * zoom;
            float radiusBL = (layer.border_radius_bl > 0 ? layer.border_radius_bl : layer.border_radius) * zoom;
            float avgRadius = (radiusTL + radiusTR + radiusBR + radiusBL) / 4.0f;

            // Box Shadow - draw before background
            if (!layer.box_shadow.empty() && layer.box_shadow != "none") {
                // Parse simple box shadow (approximate rendering)
                // Format: "Xpx Ypx Rpx COLOR" e.g. "0px 4px 8px rgba(0,0,0,0.2)"
                float shadowOffsetX = 0, shadowOffsetY = 4, shadowBlur = 8;
                ImU32 shadowColor = IM_COL32(0, 0, 0, 50);

                // Simple parsing - extract numbers
                std::string shadow = layer.box_shadow;
                size_t pos = 0;
                int numCount = 0;
                float nums[3] = {0, 0, 0};
                while (pos < shadow.length() && numCount < 3) {
                    if (shadow[pos] == '-' || isdigit(shadow[pos])) {
                        nums[numCount++] = std::stof(shadow.substr(pos));
                        while (pos < shadow.length() && (shadow[pos] == '-' || shadow[pos] == '.' || isdigit(shadow[pos]))) pos++;
                    }
                    pos++;
                }
                if (numCount >= 2) {
                    shadowOffsetX = nums[0] * zoom;
                    shadowOffsetY = nums[1] * zoom;
                    if (numCount >= 3) shadowBlur = nums[2] * zoom;
                }

                // Draw shadow layers (simple blur approximation)
                for (int i = 3; i >= 0; i--) {
                    float expand = (shadowBlur / 4) * i;
                    ImVec2 sp1(p1.x + shadowOffsetX - expand, p1.y + shadowOffsetY - expand);
                    ImVec2 sp2(p2.x + shadowOffsetX + expand, p2.y + shadowOffsetY + expand);
                    ImU32 sc = IM_COL32(0, 0, 0, 15 - i * 3);
                    drawList->AddRectFilled(sp1, sp2, sc, avgRadius + expand);
                }
            }

            // Draw layer based on type
            ImU32 bgCol = ImGui::ColorConvertFloat4ToU32(layer.bg_color);

            // Background - render for ALL layer types if they have visible alpha
            // Skip body/container layers that cover the entire canvas (they're just page background)
            bool isFullPageContainer = (layer.name.find("body") != std::string::npos ||
                                        layer.name == "html" || layer.name == "root") &&
                                       layer.width >= g_FigmaProject.canvas_width * 0.95f &&
                                       layer.height >= g_FigmaProject.canvas_height * 0.5f;

            if (layer.bg_color.w > 0.01f && !isFullPageContainer) {
                drawList->AddRectFilled(p1, p2, bgCol, avgRadius);
            }

            // Gradient overlay (simple visual indicator - ImGui can't do true gradients)
            if (layer.has_gradient && !layer.gradient_css.empty()) {
                // Draw a subtle gradient indicator
                ImU32 gradTop = IM_COL32(255, 255, 255, 30);
                ImU32 gradBot = IM_COL32(0, 0, 0, 30);
                drawList->AddRectFilledMultiColor(p1, p2, gradTop, gradTop, gradBot, gradBot);
            }

            // Image - render for any layer with a texture (images, buttons with bg, etc.)
            // Handle slideshow animation
            if (layer.enable_animation && !layer.animation_texture_ids.empty()) {
                // Update animation timer
                layer.animation_timer += io.DeltaTime;
                if (layer.animation_timer >= layer.animation_speed) {
                    layer.animation_timer = 0.0f;
                    layer.current_frame = (layer.current_frame + 1) % (int)layer.animation_texture_ids.size();
                }
                // Display current animation frame
                GLuint currentTexture = layer.animation_texture_ids[layer.current_frame];
                if (currentTexture) {
                    drawList->AddImage((ImTextureID)(intptr_t)currentTexture,
                        p1, p2, ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255));
                }
            } else if (layer.texture_id) {
                // Static image
                drawList->AddImage((ImTextureID)(intptr_t)layer.texture_id,
                    p1, p2, ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255));
            }

            // Text - with alignment and styling support
            // Show text for TEXT, BUTTON, and DIV layers (sections have titles in text field)
            if (!layer.text.empty() && (layer.type == LAYER_TEXT || layer.type == LAYER_BUTTON || layer.type == LAYER_DIV || layer.type == LAYER_INPUT || layer.type == LAYER_ICON)) {
                ImU32 textCol = ImGui::ColorConvertFloat4ToU32(layer.text_color);
                ImVec2 textSize = ImGui::CalcTextSize(layer.text.c_str());
                ImVec2 textPos = p1;

                if (layer.type == LAYER_BUTTON) {
                    // Buttons are always centered
                    textPos.x = screenX + (screenW - textSize.x) / 2;
                    textPos.y = screenY + (screenH - textSize.y) / 2;
                } else {
                    // Apply text alignment
                    float paddingX = layer.padding_left * zoom;
                    float paddingY = layer.padding_top * zoom;
                    float availWidth = screenW - paddingX - (layer.padding_right * zoom);

                    if (layer.text_align == 1) {
                        // Center alignment
                        textPos.x = screenX + (screenW - textSize.x) / 2;
                    } else if (layer.text_align == 2) {
                        // Right alignment
                        textPos.x = screenX + screenW - textSize.x - (layer.padding_right * zoom);
                    } else {
                        // Left alignment (default)
                        textPos.x = screenX + paddingX;
                    }
                    textPos.y = screenY + paddingY;
                }

                // Draw text (bold simulation for heavy weights by drawing twice with offset)
                drawList->AddText(textPos, textCol, layer.text.c_str());

                // Simulate bold for font_weight >= 600
                if (layer.font_weight >= 600) {
                    drawList->AddText(ImVec2(textPos.x + 0.5f, textPos.y), textCol, layer.text.c_str());
                }
                // Extra bold for font_weight >= 800
                if (layer.font_weight >= 800) {
                    drawList->AddText(ImVec2(textPos.x + 1.0f, textPos.y), textCol, layer.text.c_str());
                }

                // Draw underline if text_decoration is underline
                if (layer.text_decoration == "underline") {
                    float underlineY = textPos.y + textSize.y + 2;
                    drawList->AddLine(ImVec2(textPos.x, underlineY),
                                     ImVec2(textPos.x + textSize.x, underlineY),
                                     textCol, 1.0f);
                }
                // Draw strikethrough if text_decoration is line-through
                else if (layer.text_decoration == "line-through") {
                    float strikeY = textPos.y + textSize.y / 2;
                    drawList->AddLine(ImVec2(textPos.x, strikeY),
                                     ImVec2(textPos.x + textSize.x, strikeY),
                                     textCol, 1.0f);
                }
            }

            // Border - support individual border widths and colors
            bool hasIndividualBorders = (layer.border_top_width > 0 || layer.border_right_width > 0 ||
                                        layer.border_bottom_width > 0 || layer.border_left_width > 0);

            if (layer.border_width > 0 && !hasIndividualBorders) {
                // Uniform border
                ImU32 borderCol = ImGui::ColorConvertFloat4ToU32(layer.border_color);
                drawList->AddRect(p1, p2, borderCol, avgRadius, 0, layer.border_width * zoom);
            } else if (hasIndividualBorders) {
                // Individual borders - draw each side separately
                if (layer.border_top_width > 0) {
                    ImU32 col = ImGui::ColorConvertFloat4ToU32(layer.border_top_color);
                    drawList->AddLine(p1, ImVec2(p2.x, p1.y), col, layer.border_top_width * zoom);
                }
                if (layer.border_right_width > 0) {
                    ImU32 col = ImGui::ColorConvertFloat4ToU32(layer.border_right_color);
                    drawList->AddLine(ImVec2(p2.x, p1.y), p2, col, layer.border_right_width * zoom);
                }
                if (layer.border_bottom_width > 0) {
                    ImU32 col = ImGui::ColorConvertFloat4ToU32(layer.border_bottom_color);
                    drawList->AddLine(p2, ImVec2(p1.x, p2.y), col, layer.border_bottom_width * zoom);
                }
                if (layer.border_left_width > 0) {
                    ImU32 col = ImGui::ColorConvertFloat4ToU32(layer.border_left_color);
                    drawList->AddLine(ImVec2(p1.x, p2.y), p1, col, layer.border_left_width * zoom);
                }
            }
        }

        // Show layer boundaries when Bounds mode is ON or when Ref mode is OFF with transparent layers
        if (g_FigmaProject.show_bounds) {
            // Draw outline for ALL layers when Bounds is enabled
            ImU32 boundaryColor = (layer.type == LAYER_TEXT) ? IM_COL32(100, 200, 100, 120) :
                                  (layer.type == LAYER_IMAGE) ? IM_COL32(200, 100, 100, 120) :
                                  (layer.type == LAYER_BUTTON) ? IM_COL32(100, 100, 200, 120) :
                                  IM_COL32(150, 150, 150, 100);
            drawList->AddRect(p1, p2, boundaryColor, layer.border_radius * zoom, 0, 1.0f);
        } else if (!g_FigmaProject.show_reference && layer.bg_color.w < 0.1f) {
            // Draw subtle outline for transparent layers when Ref is OFF
            ImU32 boundaryColor = IM_COL32(100, 100, 100, 60);
            drawList->AddRect(p1, p2, boundaryColor, layer.border_radius * zoom, 0, 1.0f);
        }

        // Show section/layer name label for DIV sections (helps identify sections)
        if (layer.type == LAYER_DIV && layer.name.find("Section") != std::string::npos) {
            // Draw a small label at top-left showing the section name
            ImVec2 labelPos(p1.x + 5, p1.y + 5);
            drawList->AddRectFilled(
                labelPos,
                ImVec2(labelPos.x + ImGui::CalcTextSize(layer.name.c_str()).x + 10, labelPos.y + 20),
                IM_COL32(0, 0, 0, 180), 4.0f);
            drawList->AddText(ImVec2(labelPos.x + 5, labelPos.y + 3), IM_COL32(255, 255, 255, 255), layer.name.c_str());
        }

        // Selection highlight (always show in edit mode)
        if (layer.selected && !g_FigmaProject.preview_mode) {
            drawList->AddRect(p1, p2, IM_COL32(0, 150, 255, 255), 0, 0, 2.0f);

            // Resize handles
            float handleSize = 8;
            ImU32 handleColor = IM_COL32(255, 255, 255, 255);
            ImU32 handleBorder = IM_COL32(0, 150, 255, 255);

            // Corner handles
            ImVec2 handles[8] = {
                ImVec2(p1.x, p1.y),                      // Top-left
                ImVec2(p1.x + screenW/2, p1.y),         // Top-center
                ImVec2(p2.x, p1.y),                      // Top-right
                ImVec2(p2.x, p1.y + screenH/2),         // Right-center
                ImVec2(p2.x, p2.y),                      // Bottom-right
                ImVec2(p1.x + screenW/2, p2.y),         // Bottom-center
                ImVec2(p1.x, p2.y),                      // Bottom-left
                ImVec2(p1.x, p1.y + screenH/2)          // Left-center
            };

            for (int i = 0; i < 8; i++) {
                drawList->AddRectFilled(
                    ImVec2(handles[i].x - handleSize/2, handles[i].y - handleSize/2),
                    ImVec2(handles[i].x + handleSize/2, handles[i].y + handleSize/2),
                    handleColor);
                drawList->AddRect(
                    ImVec2(handles[i].x - handleSize/2, handles[i].y - handleSize/2),
                    ImVec2(handles[i].x + handleSize/2, handles[i].y + handleSize/2),
                    handleBorder);
            }
        }

        // Check for hover/click (simplified)
        ImVec2 mousePos = io.MousePos;
        bool isHovered = mousePos.x >= p1.x && mousePos.x <= p2.x &&
                        mousePos.y >= p1.y && mousePos.y <= p2.y;

        // Preview mode: show button states (hover, pressed, disabled)
        if (g_FigmaProject.preview_mode) {
            bool hasAction = (layer.type == LAYER_BUTTON || !layer.href.empty() || !layer.onclick_action.empty()) &&
                            !layer.action_type.empty() && layer.action_type != "none";

            // Disabled state - gray overlay
            if (layer.disabled) {
                drawList->AddRectFilled(p1, p2, IM_COL32(128, 128, 128, 100), layer.border_radius * zoom);
            }
            // Interactive states (only for non-disabled elements)
            else if (hasAction && isHovered) {
                // Check if mouse is pressed (pressed state)
                if (ImGui::IsMouseDown(0)) {
                    // Pressed state: darken background
                    ImVec4 pressedBg = layer.bg_color;
                    pressedBg.x = std::max(0.0f, pressedBg.x - 0.15f);
                    pressedBg.y = std::max(0.0f, pressedBg.y - 0.15f);
                    pressedBg.z = std::max(0.0f, pressedBg.z - 0.15f);
                    drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32(pressedBg), layer.border_radius * zoom);

                    // Pressed scale effect (slightly smaller)
                    float pressScale = 0.98f;
                    float scaleOffsetX = screenW * (1.0f - pressScale) / 2;
                    float scaleOffsetY = screenH * (1.0f - pressScale) / 2;
                    ImVec2 scaledP1(p1.x + scaleOffsetX, p1.y + scaleOffsetY);
                    ImVec2 scaledP2(p2.x - scaleOffsetX, p2.y - scaleOffsetY);
                    drawList->AddRect(scaledP1, scaledP2, IM_COL32(0, 150, 80, 255), layer.border_radius * zoom, 0, 2.0f);
                } else {
                    // Hover state: lighten background
                    ImVec4 hoverBg = layer.hover_bg_color.w > 0 ? layer.hover_bg_color : layer.bg_color;
                    if (layer.hover_bg_color.w <= 0) {
                        // Auto-generate hover color by lightening
                        hoverBg.x = std::min(1.0f, hoverBg.x + 0.1f);
                        hoverBg.y = std::min(1.0f, hoverBg.y + 0.1f);
                        hoverBg.z = std::min(1.0f, hoverBg.z + 0.1f);
                    }
                    drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32(hoverBg), layer.border_radius * zoom);

                    // Hover scale effect (subtle enlargement)
                    float hoverScale = layer.hover_scale > 1.0f ? layer.hover_scale : 1.02f;
                    float scaleOffsetX = screenW * (hoverScale - 1.0f) / 2;
                    float scaleOffsetY = screenH * (hoverScale - 1.0f) / 2;
                    ImVec2 scaledP1(p1.x - scaleOffsetX, p1.y - scaleOffsetY);
                    ImVec2 scaledP2(p2.x + scaleOffsetX, p2.y + scaleOffsetY);

                    // Draw clickable highlight border
                    drawList->AddRect(scaledP1, scaledP2, IM_COL32(0, 200, 100, 200), layer.border_radius * zoom, 0, 2.0f);
                }

                // Change cursor to hand pointer for interactive elements
                ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
            }
        }

        // Hover highlight (subtle in overlay mode) - only in edit mode
        if (isHovered && !layer.selected && !g_FigmaProject.preview_mode) {
            if (useOverlayMode) {
                // Subtle highlight in overlay mode
                drawList->AddRect(p1, p2, IM_COL32(0, 150, 255, 100), 0, 0, 1.0f);
            } else {
                drawList->AddRect(p1, p2, IM_COL32(100, 150, 255, 150), 0, 0, 1.0f);
            }
        }

        // Handle click to select (store for later - we want topmost layer)
        // Only process clicks when the canvas window is hovered (not dropdown panels)
        // IMPORTANT: Only select when using SELECT tool - drawing tools should create new elements on top
        if (isHovered && ImGui::IsMouseClicked(0) && !io.KeyCtrl && ImGui::IsWindowHovered()) {
            // In preview mode, execute button actions instead of selecting
            if (g_FigmaProject.preview_mode) {
                // Check if this layer has an action (button, link, etc.) and is not disabled
                if ((layer.type == LAYER_BUTTON || !layer.href.empty() || !layer.onclick_action.empty()) &&
                    !layer.action_type.empty() && layer.action_type != "none" && !layer.disabled) {
                    // Store for action execution (topmost layer wins)
                    g_HoveredLayerId = layer.id;
                }
            } else if (g_CurrentTool == TOOL_SELECT) {
                // Normal edit mode - select this layer (ONLY when SELECT tool is active)
                g_HoveredLayerId = layer.id;
            }
            // When using drawing tools (not SELECT), don't set g_HoveredLayerId -
            // this allows click-to-draw to work on top of existing elements
        }

        // Handle resize and dragging (only in SELECT tool mode)
        if (layer.selected && !layer.locked && g_CurrentTool == TOOL_SELECT && !g_FigmaProject.preview_mode) {
            float handleSize = 8;

            // Calculate handle positions (screen coordinates)
            ImVec2 handles[8] = {
                ImVec2(p1.x, p1.y),                              // 0: Top-left
                ImVec2(p1.x + screenW/2, p1.y),                 // 1: Top-center
                ImVec2(p2.x, p1.y),                              // 2: Top-right
                ImVec2(p2.x, p1.y + screenH/2),                 // 3: Right-center
                ImVec2(p2.x, p2.y),                              // 4: Bottom-right
                ImVec2(p1.x + screenW/2, p2.y),                 // 5: Bottom-center
                ImVec2(p1.x, p2.y),                              // 6: Bottom-left
                ImVec2(p1.x, p1.y + screenH/2)                  // 7: Left-center
            };

            // Check if mouse is over any resize handle
            int hoveredHandle = -1;
            for (int h = 0; h < 8; h++) {
                float hx = handles[h].x;
                float hy = handles[h].y;
                if (mousePos.x >= hx - handleSize && mousePos.x <= hx + handleSize &&
                    mousePos.y >= hy - handleSize && mousePos.y <= hy + handleSize) {
                    hoveredHandle = h;
                    break;
                }
            }

            // Set cursor based on hovered handle
            if (hoveredHandle >= 0) {
                switch (hoveredHandle) {
                    case 0: case 4: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNWSE); break; // TL, BR
                    case 2: case 6: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNESW); break; // TR, BL
                    case 1: case 5: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS); break;   // T, B
                    case 3: case 7: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW); break;   // R, L
                }
            }

            // Start resizing when clicking on a handle
            if (hoveredHandle >= 0 && ImGui::IsMouseClicked(0) && ImGui::IsWindowHovered() && !g_IsResizing) {
                SaveUndoState("Resize layer");
                g_IsResizing = true;
                g_ResizeHandle = hoveredHandle;
                g_ResizeLayerId = layer.id;
                g_ResizeStartX = mousePos.x;
                g_ResizeStartY = mousePos.y;
                g_ResizeOrigX = layer.x;
                g_ResizeOrigY = layer.y;
                g_ResizeOrigW = layer.width;
                g_ResizeOrigH = layer.height;
            }

            // Continue resizing
            if (g_IsResizing && g_ResizeLayerId == layer.id) {
                if (ImGui::IsMouseDown(0)) {
                    float deltaX = (mousePos.x - g_ResizeStartX) / zoom;
                    float deltaY = (mousePos.y - g_ResizeStartY) / zoom;

                    float newX = g_ResizeOrigX;
                    float newY = g_ResizeOrigY;
                    float newW = g_ResizeOrigW;
                    float newH = g_ResizeOrigH;

                    // Apply resize based on handle
                    switch (g_ResizeHandle) {
                        case 0: // Top-left
                            newX = g_ResizeOrigX + deltaX;
                            newY = g_ResizeOrigY + deltaY;
                            newW = g_ResizeOrigW - deltaX;
                            newH = g_ResizeOrigH - deltaY;
                            break;
                        case 1: // Top-center
                            newY = g_ResizeOrigY + deltaY;
                            newH = g_ResizeOrigH - deltaY;
                            break;
                        case 2: // Top-right
                            newY = g_ResizeOrigY + deltaY;
                            newW = g_ResizeOrigW + deltaX;
                            newH = g_ResizeOrigH - deltaY;
                            break;
                        case 3: // Right-center
                            newW = g_ResizeOrigW + deltaX;
                            break;
                        case 4: // Bottom-right
                            newW = g_ResizeOrigW + deltaX;
                            newH = g_ResizeOrigH + deltaY;
                            break;
                        case 5: // Bottom-center
                            newH = g_ResizeOrigH + deltaY;
                            break;
                        case 6: // Bottom-left
                            newX = g_ResizeOrigX + deltaX;
                            newW = g_ResizeOrigW - deltaX;
                            newH = g_ResizeOrigH + deltaY;
                            break;
                        case 7: // Left-center
                            newX = g_ResizeOrigX + deltaX;
                            newW = g_ResizeOrigW - deltaX;
                            break;
                    }

                    // Enforce minimum size
                    if (newW < 20) { newW = 20; newX = g_ResizeOrigX + g_ResizeOrigW - 20; }
                    if (newH < 20) { newH = 20; newY = g_ResizeOrigY + g_ResizeOrigH - 20; }

                    // Snap to grid if enabled
                    if (g_FigmaProject.snap_to_grid) {
                        newX = round(newX / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                        newY = round(newY / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                        newW = round(newW / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                        newH = round(newH / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                    }

                    layer.x = newX;
                    layer.y = newY;
                    layer.width = newW;
                    layer.height = newH;
                } else {
                    // Stop resizing
                    g_IsResizing = false;
                    g_ResizeHandle = -1;
                    g_ResizeLayerId = -1;
                }
            }

            // Handle dragging (only if not resizing and not clicking on a handle)
            if (!g_IsResizing && hoveredHandle < 0) {
                if (isHovered && ImGui::IsMouseClicked(0) && ImGui::IsWindowHovered()) {
                    // Save undo state before starting drag
                    SaveUndoState("Move layer");
                    layer.dragging = true;
                    layer.drag_offset_x = mousePos.x - screenX;
                    layer.drag_offset_y = mousePos.y - screenY;
                }

                if (layer.dragging) {
                    if (ImGui::IsMouseDown(0)) {
                        float newX = (mousePos.x - layer.drag_offset_x - canvasPos.x + scrollX) / zoom;
                        float newY = (mousePos.y - layer.drag_offset_y - canvasPos.y + scrollY) / zoom;

                        // Snap to grid if enabled
                        if (g_FigmaProject.snap_to_grid) {
                            newX = round(newX / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                            newY = round(newY / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                        }

                        layer.x = newX;
                        layer.y = newY;
                    } else {
                        layer.dragging = false;
                    }
                }
            }
        }
    }

    // Select the topmost hovered layer (after iterating all layers)
    // Only when canvas window is hovered (not when clicking dropdown panels)
    // Only in SELECT tool mode (other tools are for drawing)
    if (g_HoveredLayerId >= 0 && ImGui::IsMouseClicked(0) && ImGui::IsWindowHovered() &&
        (g_CurrentTool == TOOL_SELECT || g_FigmaProject.preview_mode)) {
        if (g_FigmaProject.preview_mode) {
            // In preview mode, execute the layer's action
            WebLayer* clickedLayer = GetLayerById(g_HoveredLayerId);
            if (clickedLayer) {
                ExecuteLayerAction(*clickedLayer);
            }
        } else {
            // Normal edit mode - select the layer
            // Shift+Click = add to selection (multi-select)
            if (io.KeyShift) {
                WebLayer* layer = GetLayerById(g_HoveredLayerId);
                if (layer) {
                    layer->selected = !layer->selected;  // Toggle selection
                    if (layer->selected) {
                        g_SelectedLayerId = layer->id;
                    } else if (g_SelectedLayerId == layer->id) {
                        // Find another selected layer
                        g_SelectedLayerId = -1;
                        for (auto& l : g_FigmaProject.layers) {
                            if (l.selected) {
                                g_SelectedLayerId = l.id;
                                break;
                            }
                        }
                    }
                }
            } else {
                // Normal click = single select
                SelectLayer(g_HoveredLayerId);
            }
        }
        g_HoveredLayerId = -1;
    }

    // Handle canvas panning and scrolling
    if (ImGui::IsWindowHovered()) {
        // Middle mouse drag = pan
        if (ImGui::IsMouseDragging(2)) {
            g_FigmaProject.scroll_x -= io.MouseDelta.x;
            g_FigmaProject.scroll_y -= io.MouseDelta.y;
        }

        // Scroll wheel behavior:
        // - Normal scroll = vertical scroll (up/down)
        // - Ctrl + scroll = zoom
        // - Shift + scroll = horizontal scroll (left/right)
        if (io.MouseWheel != 0) {
            if (io.KeyCtrl) {
                // Ctrl + scroll = zoom
                float zoomDelta = io.MouseWheel * 0.1f;
                g_FigmaProject.zoom = std::max(0.1f, std::min(3.0f, g_FigmaProject.zoom + zoomDelta));
            } else if (io.KeyShift) {
                // Shift + scroll = horizontal scroll
                g_FigmaProject.scroll_x -= io.MouseWheel * 50.0f;
            } else {
                // Normal scroll = vertical scroll
                g_FigmaProject.scroll_y -= io.MouseWheel * 50.0f;
            }
        }

        // Also handle horizontal scroll wheel (if available)
        if (io.MouseWheelH != 0) {
            g_FigmaProject.scroll_x -= io.MouseWheelH * 50.0f;
        }

        // Arrow keys for scrolling
        if (ImGui::IsKeyDown(ImGuiKey_UpArrow)) g_FigmaProject.scroll_y -= 10.0f;
        if (ImGui::IsKeyDown(ImGuiKey_DownArrow)) g_FigmaProject.scroll_y += 10.0f;
        if (ImGui::IsKeyDown(ImGuiKey_LeftArrow)) g_FigmaProject.scroll_x -= 10.0f;
        if (ImGui::IsKeyDown(ImGuiKey_RightArrow)) g_FigmaProject.scroll_x += 10.0f;

        // ==================== KEYBOARD SHORTCUTS ====================
        // Only when not typing in a text field
        if (!io.WantTextInput) {
            // Basic Tool shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_V)) g_CurrentTool = TOOL_SELECT;
            if (ImGui::IsKeyPressed(ImGuiKey_R)) g_CurrentTool = TOOL_RECTANGLE;
            if (ImGui::IsKeyPressed(ImGuiKey_F)) g_CurrentTool = TOOL_FRAME;

            // Typography shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_H)) g_CurrentTool = TOOL_HEADING;
            if (ImGui::IsKeyPressed(ImGuiKey_T)) g_CurrentTool = TOOL_TEXT;
            if (ImGui::IsKeyPressed(ImGuiKey_P)) g_CurrentTool = TOOL_PARAGRAPH;

            // Media/Interactive shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_I)) g_CurrentTool = TOOL_IMAGE;
            if (ImGui::IsKeyPressed(ImGuiKey_B)) g_CurrentTool = TOOL_BUTTON;

            // Form & Elements shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_U)) g_CurrentTool = TOOL_INPUT;  // U for input/user input

            // Website Section shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_S)) g_CurrentTool = TOOL_SEC_SERVICES;
            if (ImGui::IsKeyPressed(ImGuiKey_N)) g_CurrentTool = TOOL_SEC_NAVBAR;
            if (ImGui::IsKeyPressed(ImGuiKey_C)) g_CurrentTool = TOOL_SEC_CONTACT;

            // Shape shortcuts
            if (ImGui::IsKeyPressed(ImGuiKey_L)) g_CurrentTool = TOOL_LINE;
            if (ImGui::IsKeyPressed(ImGuiKey_O)) g_CurrentTool = TOOL_CIRCLE;

            // Undo/Redo: Ctrl+Z / Ctrl+Shift+Z
            if (io.KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_Z)) {
                if (io.KeyShift) {
                    Redo();
                } else {
                    Undo();
                }
            }

            // Copy/Paste/Delete: Ctrl+C, Ctrl+V, Delete/Backspace
            if (io.KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_C)) {
                CopySelectedLayers();
            }
            if (io.KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_V)) {
                PasteClipboard();
            }
            if (ImGui::IsKeyPressed(ImGuiKey_Delete) || ImGui::IsKeyPressed(ImGuiKey_Backspace)) {
                DeleteSelectedLayers();
            }

            // Escape to deselect or cancel drawing
            if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
                if (g_IsDrawing) {
                    g_IsDrawing = false;
                } else {
                    DeselectAllLayers();
                    g_CurrentTool = TOOL_SELECT;
                }
            }
        }

        // ==================== CLICK-TO-DRAW ====================
        // Drawing new elements with tools (only when not Select tool)
        if (g_CurrentTool != TOOL_SELECT && !g_FigmaProject.preview_mode) {
            // Start drawing on mouse click
            if (ImGui::IsMouseClicked(0) && !g_IsDrawing) {
                g_IsDrawing = true;
                g_DrawStartX = (io.MousePos.x - canvasPos.x + scrollX) / zoom;
                g_DrawStartY = (io.MousePos.y - canvasPos.y + scrollY) / zoom;
                g_DrawCurrentX = g_DrawStartX;
                g_DrawCurrentY = g_DrawStartY;
            }

            // Update current draw position while dragging
            if (g_IsDrawing && ImGui::IsMouseDown(0)) {
                g_DrawCurrentX = (io.MousePos.x - canvasPos.x + scrollX) / zoom;
                g_DrawCurrentY = (io.MousePos.y - canvasPos.y + scrollY) / zoom;

                // Snap to grid if enabled
                if (g_FigmaProject.snap_to_grid) {
                    g_DrawCurrentX = round(g_DrawCurrentX / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                    g_DrawCurrentY = round(g_DrawCurrentY / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                }
            }

            // Finish drawing on mouse release
            if (g_IsDrawing && ImGui::IsMouseReleased(0)) {
                g_IsDrawing = false;
                float endX = (io.MousePos.x - canvasPos.x + scrollX) / zoom;
                float endY = (io.MousePos.y - canvasPos.y + scrollY) / zoom;

                // Snap to grid if enabled
                if (g_FigmaProject.snap_to_grid) {
                    endX = round(endX / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                    endY = round(endY / g_FigmaProject.grid_size) * g_FigmaProject.grid_size;
                }

                // Create element from tool
                CreateElementFromTool(g_CurrentTool, g_DrawStartX, g_DrawStartY, endX, endY);
            }

            // Draw preview rectangle while drawing
            if (g_IsDrawing) {
                float previewX1 = canvasPos.x + (std::min(g_DrawStartX, g_DrawCurrentX) * zoom) - scrollX;
                float previewY1 = canvasPos.y + (std::min(g_DrawStartY, g_DrawCurrentY) * zoom) - scrollY;
                float previewX2 = canvasPos.x + (std::max(g_DrawStartX, g_DrawCurrentX) * zoom) - scrollX;
                float previewY2 = canvasPos.y + (std::max(g_DrawStartY, g_DrawCurrentY) * zoom) - scrollY;

                // Draw dashed preview rectangle
                ImU32 previewColor = IM_COL32(100, 150, 255, 200);
                if (g_CurrentTool == TOOL_CIRCLE) {
                    // For circle, draw ellipse preview
                    float cx = (previewX1 + previewX2) / 2;
                    float cy = (previewY1 + previewY2) / 2;
                    float rx = (previewX2 - previewX1) / 2;
                    float ry = (previewY2 - previewY1) / 2;
                    drawList->AddEllipse(ImVec2(cx, cy), ImVec2(rx, ry), previewColor, 0.0f, 32, 2.0f);
                } else if (g_CurrentTool == TOOL_LINE) {
                    // For line, draw line preview
                    drawList->AddLine(ImVec2(previewX1, previewY1), ImVec2(previewX2, previewY2), previewColor, 2.0f);
                } else {
                    // For other tools, draw rectangle preview
                    drawList->AddRect(ImVec2(previewX1, previewY1), ImVec2(previewX2, previewY2), previewColor, 0, 0, 2.0f);
                }

                // Show dimensions
                float w = std::abs(g_DrawCurrentX - g_DrawStartX);
                float h = std::abs(g_DrawCurrentY - g_DrawStartY);
                char dimText[64];
                snprintf(dimText, sizeof(dimText), "%.0f x %.0f", w, h);
                drawList->AddText(ImVec2(previewX2 + 5, previewY2 + 5), IM_COL32(255, 255, 255, 200), dimText);
            }

            // Change cursor to crosshair when tool is active
            ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);
        }
    }

    // Click on empty area to deselect (only in Select tool mode)
    if (g_CurrentTool == TOOL_SELECT && ImGui::IsMouseClicked(0) && ImGui::IsWindowHovered()) {
        bool clickedOnLayer = false;
        for (auto& layer : g_FigmaProject.layers) {
            float screenX = canvasPos.x + (layer.x * zoom) - scrollX;
            float screenY = canvasPos.y + (layer.y * zoom) - scrollY;
            float screenW = layer.width * zoom;
            float screenH = layer.height * zoom;

            if (io.MousePos.x >= screenX && io.MousePos.x <= screenX + screenW &&
                io.MousePos.y >= screenY && io.MousePos.y <= screenY + screenH) {
                clickedOnLayer = true;
                break;
            }
        }
        if (!clickedOnLayer) {
            DeselectAllLayers();
        }
    }

    // Pop the clip rect we pushed at the start
    drawList->PopClipRect();
}

void RenderFigmaLayersPanel() {
    ImGui::Begin("Layers", &g_ShowFigmaLayers);

    // Toolbar
    if (ImGui::Button("+ Add Layer")) {
        WebLayer newLayer;
        newLayer.id = g_FigmaProject.next_layer_id++;
        newLayer.name = "New Layer";
        newLayer.x = 100;
        newLayer.y = 100;
        newLayer.width = 200;
        newLayer.height = 100;
        newLayer.bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
        g_FigmaProject.layers.push_back(newLayer);
    }

    ImGui::SameLine();
    if (ImGui::Button("Delete") && g_SelectedLayerId >= 0) {
        g_FigmaProject.layers.erase(
            std::remove_if(g_FigmaProject.layers.begin(), g_FigmaProject.layers.end(),
                [](const WebLayer& l) { return l.id == g_SelectedLayerId; }),
            g_FigmaProject.layers.end());
        g_SelectedLayerId = -1;
    }

    ImGui::Separator();

    // Layer list (reverse order - top layers first)
    for (int i = g_FigmaProject.layers.size() - 1; i >= 0; i--) {
        WebLayer& layer = g_FigmaProject.layers[i];

        ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
        if (layer.selected) flags |= ImGuiTreeNodeFlags_Selected;

        // Type icon
        const char* icon = "[ ]";
        switch (layer.type) {
            case LAYER_TEXT: icon = "[T]"; break;
            case LAYER_IMAGE: icon = "[I]"; break;
            case LAYER_BUTTON: icon = "[B]"; break;
            case LAYER_INPUT: icon = "[F]"; break;
            default: icon = "[D]"; break;
        }

        // Visibility toggle
        ImGui::PushID(layer.id);
        if (ImGui::Checkbox("##vis", &layer.visible)) {}
        ImGui::SameLine();

        // Layer name
        char label[128];
        snprintf(label, sizeof(label), "%s %s", icon, layer.name.c_str());

        if (ImGui::Selectable(label, layer.selected)) {
            SelectLayer(layer.id);
        }

        ImGui::PopID();
    }

    ImGui::End();
}

void RenderFigmaPropertiesPanel() {
    ImGui::Begin("Properties", &g_ShowFigmaProperties);

    WebLayer* layer = GetLayerById(g_SelectedLayerId);
    if (!layer) {
        ImGui::TextDisabled("No layer selected");
        ImGui::End();
        return;
    }

    // Name
    char nameBuffer[256];
    strncpy(nameBuffer, layer->name.c_str(), sizeof(nameBuffer));
    if (ImGui::InputText("Name", nameBuffer, sizeof(nameBuffer))) {
        layer->name = nameBuffer;
    }

    ImGui::Separator();

    // Position & Size
    if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen)) {
        ImGui::DragFloat("X", &layer->x, 1.0f);
        ImGui::DragFloat("Y", &layer->y, 1.0f);
        ImGui::DragFloat("Width", &layer->width, 1.0f, 1.0f, 10000.0f);
        ImGui::DragFloat("Height", &layer->height, 1.0f, 1.0f, 10000.0f);
    }

    // Appearance
    if (ImGui::CollapsingHeader("Appearance", ImGuiTreeNodeFlags_DefaultOpen)) {
        ImGui::ColorEdit4("Background", (float*)&layer->bg_color);
        ImGui::ColorEdit4("Text Color", (float*)&layer->text_color);
        ImGui::DragFloat("Opacity", &layer->opacity, 0.01f, 0.0f, 1.0f);
        ImGui::DragFloat("Border Radius", &layer->border_radius, 1.0f, 0.0f, 100.0f);
        ImGui::DragFloat("Border Width", &layer->border_width, 0.5f, 0.0f, 20.0f);
        if (layer->border_width > 0) {
            ImGui::ColorEdit4("Border Color", (float*)&layer->border_color);
        }
    }

    // Text (if text layer)
    if (layer->type == LAYER_TEXT || layer->type == LAYER_BUTTON) {
        if (ImGui::CollapsingHeader("Text", ImGuiTreeNodeFlags_DefaultOpen)) {
            char textBuffer[1024];
            strncpy(textBuffer, layer->text.c_str(), sizeof(textBuffer));
            if (ImGui::InputTextMultiline("Content", textBuffer, sizeof(textBuffer), ImVec2(-1, 100))) {
                layer->text = textBuffer;
            }
            ImGui::DragFloat("Font Size", &layer->font_size, 1.0f, 8.0f, 200.0f);
            ImGui::DragFloat("Font Weight", &layer->font_weight, 100.0f, 100.0f, 900.0f);
        }
    }

    // Image (if image layer)
    if (layer->type == LAYER_IMAGE) {
        if (ImGui::CollapsingHeader("Image", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::Text("Path: %s", layer->image_path.empty() ? "(none)" : layer->image_path.c_str());
            if (layer->texture_id) {
                ImGui::Text("Texture ID: %d", layer->texture_id);
                // Show small preview
                float previewSize = 100;
                float aspect = layer->width / layer->height;
                ImGui::Image((ImTextureID)(intptr_t)layer->texture_id,
                    ImVec2(previewSize * aspect, previewSize));
            }

            // Image path input for replacement
            static char imgPathBuffer[512] = "";
            ImGui::InputText("New Image Path", imgPathBuffer, sizeof(imgPathBuffer));
            if (ImGui::Button("Load Image") && strlen(imgPathBuffer) > 0) {
                int w, h, n;
                unsigned char* data = stbi_load(imgPathBuffer, &w, &h, &n, 4);
                if (data) {
                    // Delete old texture if exists
                    if (layer->texture_id) {
                        glDeleteTextures(1, &layer->texture_id);
                    }
                    // Create new texture
                    glGenTextures(1, &layer->texture_id);
                    glBindTexture(GL_TEXTURE_2D, layer->texture_id);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                    stbi_image_free(data);
                    layer->image_path = imgPathBuffer;
                    imgPathBuffer[0] = '\0';
                }
            }
        }
    }

    // Lock
    ImGui::Separator();
    ImGui::Checkbox("Locked", &layer->locked);

    ImGui::End();
}

// ============================================================================
// TEMPLATE STYLE PRESET APPLICATION
// ============================================================================

// Apply a specific style preset to a WebSection
void ApplyStylePreset(WebSection& sec, int styleIndex) {
    // Gallery only has 2 styles, others have 5
    int maxStyles = (sec.type == SEC_GALLERY) ? 2 : 5;
    if (styleIndex < 0 || styleIndex >= maxStyles) return;

    // The section already has default values from SetDefaults()
    // Now we modify them based on the selected style

    // IMPORTANT: Set the layout_style so rendering knows which layout to use
    sec.layout_style = styleIndex;

    switch (sec.type) {
        case SEC_HERO:
            if (styleIndex == 0) {
                // "Modern Gradient" (default - already set)
                // No changes needed
            } else if (styleIndex == 1) {
                // "Minimalist Light"
                sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.subtitle_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                sec.content_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                sec.button_bg_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_SLIDE_DOWN;
            } else if (styleIndex == 2) {
                // "Dark Premium"
                sec.bg_color = ImVec4(0.08f, 0.08f, 0.12f, 1.0f);
                sec.title_color = ImVec4(0.85f, 0.75f, 0.45f, 1.0f);  // Gold
                sec.subtitle_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.content_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
                sec.button_bg_color = ImVec4(0.85f, 0.75f, 0.45f, 1.0f);  // Gold
                sec.button_text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_FADE_IN;
            } else if (styleIndex == 3) {
                // "Colorful Creative"
                sec.bg_color = ImVec4(0.95f, 0.35f, 0.45f, 1.0f);  // Vibrant pink
                sec.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.subtitle_color = ImVec4(0.95f, 0.95f, 1.0f, 1.0f);
                sec.content_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.button_bg_color = ImVec4(1.0f, 0.8f, 0.0f, 1.0f);  // Yellow
                sec.button_text_color = ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
                sec.animation_type = ANIM_BOUNCE;
            } else if (styleIndex == 4) {
                // "Corporate Professional"
                sec.bg_color = ImVec4(0.15f, 0.25f, 0.45f, 1.0f);  // Corporate blue
                sec.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.subtitle_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.content_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
                sec.button_bg_color = ImVec4(0.2f, 0.6f, 1.0f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_SLIDE_UP;
            }
            break;

        case SEC_CONTACT:
            if (styleIndex == 0) {
                // "Luxury Glass Form" - Dark with gold labels
                sec.bg_color = ImVec4(0.08f, 0.08f, 0.15f, 1.0f);  // Dark navy
                sec.title_color = ImVec4(0.85f, 0.75f, 0.45f, 1.0f);  // Gold
                sec.subtitle_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.content_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
                sec.button_bg_color = ImVec4(0.85f, 0.75f, 0.45f, 1.0f);  // Gold button
                sec.button_text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.button_glass_effect = false;
                sec.button_glass_opacity = 0.3f;
                sec.animation_type = ANIM_FADE_IN;
            } else if (styleIndex == 1) {
                // "Minimalist White"
                sec.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.subtitle_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                sec.content_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                sec.button_bg_color = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_SLIDE_UP;
            } else if (styleIndex == 2) {
                // "Corporate Professional"
                sec.bg_color = ImVec4(0.96f, 0.97f, 0.99f, 1.0f);
                sec.title_color = ImVec4(0.15f, 0.25f, 0.45f, 1.0f);
                sec.subtitle_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                sec.content_color = ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
                sec.button_bg_color = ImVec4(0.15f, 0.25f, 0.45f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_SLIDE_UP;
            } else if (styleIndex == 3) {
                // "Creative Colorful"
                sec.bg_color = ImVec4(0.5f, 0.3f, 0.8f, 1.0f);  // Purple gradient
                sec.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.subtitle_color = ImVec4(0.95f, 0.95f, 1.0f, 1.0f);
                sec.content_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.button_bg_color = ImVec4(1.0f, 0.6f, 0.0f, 1.0f);  // Orange
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_ZOOM_IN;
            } else if (styleIndex == 4) {
                // "Elegant Dark"
                sec.bg_color = ImVec4(0.1f, 0.1f, 0.15f, 1.0f);
                sec.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.subtitle_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
                sec.content_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
                sec.button_bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.button_text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                sec.button_glass_effect = false;
                sec.animation_type = ANIM_FADE_IN;
            }
            break;

        case SEC_SERVICES:
        case SEC_FEATURES:
            if (styleIndex == 0) {
                // "Glass Morph Cards" (default - already has glass effect)
            } else if (styleIndex == 1) {
                // "Solid Modern Cards"
                for (auto& item : sec.items) {
                    item.glass_effect = false;
                    item.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                    item.glass_border_width = 2.0f;
                    item.glass_border_color = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
                }
                sec.animation_type = ANIM_SLIDE_UP;
            } else if (styleIndex == 2) {
                // "Gradient Cards"
                ImVec4 gradients[] = {
                    ImVec4(0.37f, 0.51f, 0.99f, 1.0f),  // Blue
                    ImVec4(0.56f, 0.27f, 0.68f, 1.0f),  // Purple
                    ImVec4(0.06f, 0.71f, 0.60f, 1.0f)   // Teal
                };
                for (size_t i = 0; i < sec.items.size() && i < 3; i++) {
                    sec.items[i].bg_color = gradients[i];
                    sec.items[i].title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                    sec.items[i].desc_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
                    sec.items[i].glass_effect = false;
                }
                sec.animation_type = ANIM_ZOOM_IN;
            } else if (styleIndex == 3) {
                // "Icon-First Cards"
                for (auto& item : sec.items) {
                    item.title_font_size = 28;
                    item.desc_font_size = 15;
                    item.glass_effect = false;
                }
                sec.animation_type = ANIM_FADE_IN;
            } else if (styleIndex == 4) {
                // "List Style"
                sec.cards_per_row = 1;
                sec.card_width = 700;
                sec.card_height = 120;
                for (auto& item : sec.items) {
                    item.glass_effect = false;
                }
                sec.animation_type = ANIM_SLIDE_LEFT;
            }
            break;

        case SEC_PRICING:
            if (styleIndex == 0) {
                // "3-Tier Glass" (default - already set)
            } else if (styleIndex == 1) {
                // "Minimal Cards"
                for (auto& item : sec.items) {
                    item.bg_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                    item.title_color = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
                    item.desc_color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                    item.glass_effect = false;
                }
                sec.animation_type = ANIM_SLIDE_UP;
            } else if (styleIndex == 2) {
                // "Bold Colored"
                ImVec4 colors[] = {
                    ImVec4(0.2f, 0.6f, 1.0f, 1.0f),   // Blue
                    ImVec4(0.5f, 0.2f, 0.9f, 1.0f),   // Purple
                    ImVec4(0.9f, 0.3f, 0.3f, 1.0f)    // Red
                };
                for (size_t i = 0; i < sec.items.size() && i < 3; i++) {
                    sec.items[i].bg_color = colors[i];
                    sec.items[i].title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                    sec.items[i].desc_color = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
                    sec.items[i].glass_effect = false;
                }
                sec.animation_type = ANIM_BOUNCE;
            } else if (styleIndex == 3) {
                // "Enterprise Dark"
                sec.bg_color = ImVec4(0.1f, 0.1f, 0.15f, 1.0f);
                sec.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.subtitle_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
                for (auto& item : sec.items) {
                    item.bg_color = ImVec4(0.15f, 0.15f, 0.2f, 1.0f);
                    item.title_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                    item.desc_color = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
                    item.glass_effect = false;
                }
                sec.animation_type = ANIM_FADE_IN;
            } else if (styleIndex == 4) {
                // "Comparison Table"
                sec.cards_per_row = 3;
                sec.card_height = 500;
                sec.animation_type = ANIM_SLIDE_DOWN;
            }
            break;

        case SEC_GALLERY:
            if (styleIndex == 0) {
                // "2x2 Grid" - 4 images in square grid (2 rows √ó 2 columns)
                sec.gallery_columns = 2;  // 2 columns
                sec.cards_per_row = 2;    // 2 images per row
                sec.card_width = 1200;    // Standard width
                sec.card_height = 1000;   // Standard height
                sec.card_spacing = 10;    // Standard spacing
                sec.height = 1200;        // Larger section height
                sec.animation_type = ANIM_FADE_IN;
            } else if (styleIndex == 1) {
                // "1x4 Horizontal" - 4 images in horizontal row
                sec.gallery_columns = 4;  // 4 columns
                sec.cards_per_row = 4;    // 4 images in one row
                sec.card_width = 1200;    // Standard width
                sec.card_height = 1000;   // Standard height
                sec.card_spacing = 10;    // Standard spacing
                sec.height = 1200;        // Same height for consistency
                sec.animation_type = ANIM_SLIDE_LEFT;
            }
            break;

        default:
            // For other section types, just modify animations
            if (styleIndex == 1) sec.animation_type = ANIM_SLIDE_UP;
            else if (styleIndex == 2) sec.animation_type = ANIM_FADE_IN;
            else if (styleIndex == 3) sec.animation_type = ANIM_ZOOM_IN;
            else if (styleIndex == 4) sec.animation_type = ANIM_BOUNCE;
            break;
    }
}

// Render the Template Picker Modal
void RenderTemplatePicker() {
    if (!g_ShowTemplatePicker) return;

    ImGui::OpenPopup("Choose Template Style");

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    ImGui::SetNextWindowSize(ImVec2(1320, 700), ImGuiCond_Appearing);

    bool open = true;
    if (ImGui::BeginPopupModal("Choose Template Style", &open, ImGuiWindowFlags_NoResize)) {
        // Header
        const char* section_names[] = {"Hero", "Navigation", "About", "Services", "Cards", "Team",
                                       "Pricing", "Testimonials", "Gallery", "Blog", "Contact",
                                       "Footer", "FAQ", "Call-to-Action", "Features", "Stats", "Login", "Custom"};
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.37f, 0.51f, 0.99f, 1.0f));
        ImGui::Text("Select a style for your %s section", section_names[g_PickerSectionType]);
        ImGui::PopStyleColor();
        ImGui::Separator();
        ImGui::Spacing();

        // Get style presets for this section type
        const auto& styles = g_StylePresets.at(g_PickerSectionType);
        int numStyles = (int)styles.size();

        // Display style options in MUCH LARGER cards with FULL preview
        float cardWidth = 250;
        float cardHeight = 320;
        float spacing = 15;

        for (int i = 0; i < numStyles; i++) {
            if (i > 0) ImGui::SameLine();

            ImGui::BeginGroup();

            // Get style-specific colors based on section type and style index
            ImVec4 cardBg, titleColor, subtitleColor;

            // Different visual appearance for each style
            if (g_PickerSectionType == SEC_HERO) {
                if (i == 0) { // Modern Gradient
                    cardBg = ImVec4(0.09f, 0.13f, 0.25f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.85f, 0.88f, 0.95f, 1.0f);
                } else if (i == 1) { // Minimalist Light
                    cardBg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); titleColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                } else if (i == 2) { // Dark Premium
                    cardBg = ImVec4(0.08f, 0.08f, 0.12f, 1.0f); titleColor = ImVec4(0.85f, 0.75f, 0.45f, 1.0f); subtitleColor = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                } else if (i == 3) { // Colorful Creative
                    cardBg = ImVec4(0.95f, 0.35f, 0.45f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.95f, 0.95f, 1.0f, 1.0f);
                } else { // Corporate Professional
                    cardBg = ImVec4(0.15f, 0.25f, 0.45f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                }
            } else if (g_PickerSectionType == SEC_CONTACT) {
                if (i == 0) { // Luxury Glass Form
                    cardBg = ImVec4(0.08f, 0.08f, 0.15f, 1.0f); titleColor = ImVec4(0.85f, 0.75f, 0.45f, 1.0f); subtitleColor = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                } else if (i == 1) { // Minimalist White
                    cardBg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); titleColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                } else if (i == 2) { // Corporate Professional
                    cardBg = ImVec4(0.96f, 0.97f, 0.99f, 1.0f); titleColor = ImVec4(0.15f, 0.25f, 0.45f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                } else if (i == 3) { // Creative Colorful
                    cardBg = ImVec4(0.5f, 0.3f, 0.8f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.95f, 0.95f, 1.0f, 1.0f);
                } else { // Elegant Dark
                    cardBg = ImVec4(0.1f, 0.1f, 0.15f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);
                }
            } else if (g_PickerSectionType == SEC_SERVICES || g_PickerSectionType == SEC_FEATURES) {
                if (i == 0) { // Glass Morph
                    cardBg = ImVec4(0.97f, 0.97f, 0.99f, 1.0f); titleColor = ImVec4(0.12f, 0.15f, 0.22f, 1.0f); subtitleColor = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                } else if (i == 1) { // Solid Modern
                    cardBg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); titleColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                } else if (i == 2) { // Gradient Cards
                    cardBg = ImVec4(0.37f, 0.51f, 0.99f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
                } else if (i == 3) { // Icon-First
                    cardBg = ImVec4(0.99f, 0.99f, 1.0f, 1.0f); titleColor = ImVec4(0.2f, 0.2f, 0.2f, 1.0f); subtitleColor = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
                } else { // List Style
                    cardBg = ImVec4(0.98f, 0.98f, 0.99f, 1.0f); titleColor = ImVec4(0.15f, 0.15f, 0.15f, 1.0f); subtitleColor = ImVec4(0.45f, 0.45f, 0.45f, 1.0f);
                }
            } else if (g_PickerSectionType == SEC_PRICING) {
                if (i == 0) { // 3-Tier Glass
                    cardBg = ImVec4(0.98f, 0.98f, 0.99f, 1.0f); titleColor = ImVec4(0.12f, 0.15f, 0.22f, 1.0f); subtitleColor = ImVec4(0.37f, 0.51f, 0.99f, 1.0f);
                } else if (i == 1) { // Minimal Cards
                    cardBg = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); titleColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                } else if (i == 2) { // Bold Colored
                    cardBg = ImVec4(0.2f, 0.6f, 1.0f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.95f, 0.95f, 0.95f, 1.0f);
                } else if (i == 3) { // Enterprise Dark
                    cardBg = ImVec4(0.1f, 0.1f, 0.15f, 1.0f); titleColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); subtitleColor = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);
                } else { // Comparison Table
                    cardBg = ImVec4(0.95f, 0.95f, 0.97f, 1.0f); titleColor = ImVec4(0.15f, 0.15f, 0.15f, 1.0f); subtitleColor = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);
                }
            } else if (g_PickerSectionType == SEC_GALLERY) {
                if (i == 0) { // 2x2 Grid
                    cardBg = ImVec4(0.99f, 0.99f, 1.0f, 1.0f); titleColor = ImVec4(0.12f, 0.15f, 0.22f, 1.0f); subtitleColor = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                } else { // 1x4 Horizontal
                    cardBg = ImVec4(0.99f, 0.99f, 1.0f, 1.0f); titleColor = ImVec4(0.12f, 0.15f, 0.22f, 1.0f); subtitleColor = ImVec4(0.45f, 0.50f, 0.60f, 1.0f);
                }
            } else {
                // Default colors for other section types
                ImVec4 baseColors[] = {
                    ImVec4(0.37f, 0.51f, 0.99f, 1.0f),  // Blue
                    ImVec4(1.0f, 1.0f, 1.0f, 1.0f),     // White
                    ImVec4(0.1f, 0.1f, 0.15f, 1.0f),    // Dark
                    ImVec4(0.5f, 0.3f, 0.8f, 1.0f),     // Purple
                    ImVec4(0.98f, 0.98f, 0.99f, 1.0f)   // Light gray
                };
                cardBg = baseColors[i];
                titleColor = (i == 1 || i == 4) ? ImVec4(0.1f, 0.1f, 0.1f, 1.0f) : ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                subtitleColor = (i == 1 || i == 4) ? ImVec4(0.4f, 0.4f, 0.4f, 1.0f) : ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
            }

            // Style card with actual style colors
            bool selected = (g_SelectedStyleIndex == i);
            ImGui::PushStyleColor(ImGuiCol_ChildBg, cardBg);
            ImGui::PushStyleColor(ImGuiCol_Border, selected ?
                ImVec4(0.37f, 0.51f, 0.99f, 1.0f) : ImVec4(0.8f, 0.8f, 0.8f, 1.0f));
            ImGui::PushStyleVar(ImGuiStyleVar_ChildBorderSize, selected ? 4.0f : 2.0f);

            ImGui::BeginChild(i + 1000, ImVec2(cardWidth, cardHeight), true);

            // Draw COMPLETE FULL DESIGN PREVIEW with DIFFERENT LAYOUTS!
            if (g_PickerSectionType == SEC_CONTACT) {
                ImDrawList* draw = ImGui::GetWindowDrawList();
                ImVec2 cardPos = ImGui::GetCursorScreenPos();
                float miniW = cardWidth - 30;
                float startX = 15;
                float startY = 15;

                if (i == 0) { // LAYOUT 1: CENTERED CARD - Form in center with box around it
                    // Draw visual layout representation

                    // Background area
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.08f, 0.08f, 0.15f, 1.0f)));

                    // Centered title
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.85f, 0.75f, 0.45f, 1.0f));
                    float titleW = ImGui::CalcTextSize("CENTERED CARD").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("CENTERED CARD");
                    ImGui::PopStyleColor();

                    // Draw centered card/box
                    float boxW = 180;
                    float boxH = 200;
                    float boxX = cardPos.x + (cardWidth - boxW) / 2;
                    float boxY = cardPos.y + 70;

                    // Card background (glass effect)
                    draw->AddRectFilled(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.15f, 0.2f, 1.0f)), 8.0f);
                    draw->AddRect(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.75f, 0.45f, 0.5f)), 8.0f, 0, 2.0f);

                    // Form fields inside card
                    float fieldY = boxY + 15;
                    for (int f = 0; f < 3; f++) {
                        draw->AddRectFilled(ImVec2(boxX + 15, fieldY), ImVec2(boxX + boxW - 15, fieldY + 20),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 0.12f)), 4.0f);
                        draw->AddRect(ImVec2(boxX + 15, fieldY), ImVec2(boxX + boxW - 15, fieldY + 20),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.75f, 0.45f, 0.5f)), 4.0f, 0, 1.5f);
                        fieldY += 30;
                    }

                    // Button
                    draw->AddRectFilled(ImVec2(boxX + 15, fieldY + 20), ImVec2(boxX + boxW - 15, fieldY + 45),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.75f, 0.45f, 1.0f)), 15.0f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.85f, 0.75f, 0.45f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Form in Center").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Form in Center");
                    ImGui::PopStyleColor();

                } else if (i == 1) { // LAYOUT 2: SPLIT SCREEN - Left info panel, Right form
                    // Draw visual layout representation

                    // Background
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.97f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 0.4f, 0.8f, 1.0f));
                    float titleW = ImGui::CalcTextSize("SPLIT SCREEN").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("SPLIT SCREEN");
                    ImGui::PopStyleColor();

                    // LEFT PANEL (Info/Image area)
                    float leftW = 100;
                    float panelH = 200;
                    float leftX = cardPos.x + 20;
                    float leftY = cardPos.y + 70;

                    draw->AddRectFilled(ImVec2(leftX, leftY), ImVec2(leftX + leftW, leftY + panelH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.4f, 0.8f, 1.0f)), 4.0f);

                    // Icon representation in left panel
                    float iconSize = 30;
                    float iconX = leftX + (leftW - iconSize) / 2;
                    float iconY = leftY + 30;
                    draw->AddCircleFilled(ImVec2(iconX + iconSize/2, iconY + iconSize/2), iconSize/2,
                        ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 0.3f)));

                    // Text lines in left panel
                    for (int ln = 0; ln < 3; ln++) {
                        float lineY = iconY + 40 + (ln * 15);
                        float lineW = 70;
                        draw->AddRectFilled(ImVec2(leftX + 15, lineY), ImVec2(leftX + 15 + lineW, lineY + 8),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 0.7f)), 2.0f);
                    }

                    // RIGHT PANEL (Form area)
                    float rightW = 110;
                    float rightX = leftX + leftW + 10;

                    draw->AddRectFilled(ImVec2(rightX, leftY), ImVec2(rightX + rightW, leftY + panelH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 4.0f);
                    draw->AddRect(ImVec2(rightX, leftY), ImVec2(rightX + rightW, leftY + panelH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.8f, 0.8f, 0.8f, 1.0f)), 4.0f, 0, 1.0f);

                    // Form fields in right panel
                    float fieldY = leftY + 20;
                    for (int f = 0; f < 3; f++) {
                        draw->AddRectFilled(ImVec2(rightX + 10, fieldY), ImVec2(rightX + rightW - 10, fieldY + 18),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                        draw->AddRect(ImVec2(rightX + 10, fieldY), ImVec2(rightX + rightW - 10, fieldY + 18),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.7f, 0.7f, 0.7f, 1.0f)), 3.0f, 0, 1.0f);
                        fieldY += 28;
                    }

                    // Button in right panel
                    draw->AddRectFilled(ImVec2(rightX + 10, fieldY + 15), ImVec2(rightX + rightW - 10, fieldY + 40),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.4f, 0.8f, 1.0f)), 12.0f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 0.4f, 0.8f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Info + Form").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Info + Form");
                    ImGui::PopStyleColor();

                } else if (i == 2) { // LAYOUT 3: TWO COLUMN GRID - Fields in 2 columns
                    // Draw visual layout representation

                    // Background
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.98f, 0.98f, 0.98f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.15f, 0.25f, 0.45f, 1.0f));
                    float titleW = ImGui::CalcTextSize("TWO COLUMNS").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("TWO COLUMNS");
                    ImGui::PopStyleColor();

                    // Container box
                    float boxW = 210;
                    float boxH = 200;
                    float boxX = cardPos.x + (cardWidth - boxW) / 2;
                    float boxY = cardPos.y + 70;

                    draw->AddRectFilled(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 6.0f);
                    draw->AddRect(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 0.3f)), 6.0f, 0, 2.0f);

                    // Title inside
                    float headerY = boxY + 15;
                    draw->AddRectFilled(ImVec2(boxX + 20, headerY), ImVec2(boxX + boxW - 20, headerY + 10),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 2.0f);

                    // Two column form fields
                    float colW = 90;
                    float leftColX = boxX + 15;
                    float rightColX = boxX + 15 + colW + 10;
                    float rowY = headerY + 25;

                    // Row 1: Name | Email
                    draw->AddRectFilled(ImVec2(leftColX, rowY), ImVec2(leftColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                    draw->AddRect(ImVec2(leftColX, rowY), ImVec2(leftColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 3.0f, 0, 1.0f);

                    draw->AddRectFilled(ImVec2(rightColX, rowY), ImVec2(rightColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                    draw->AddRect(ImVec2(rightColX, rowY), ImVec2(rightColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 3.0f, 0, 1.0f);

                    // Row 2: Phone | Company
                    rowY += 30;
                    draw->AddRectFilled(ImVec2(leftColX, rowY), ImVec2(leftColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                    draw->AddRect(ImVec2(leftColX, rowY), ImVec2(leftColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 3.0f, 0, 1.0f);

                    draw->AddRectFilled(ImVec2(rightColX, rowY), ImVec2(rightColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                    draw->AddRect(ImVec2(rightColX, rowY), ImVec2(rightColX + colW, rowY + 20),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 3.0f, 0, 1.0f);

                    // Full width message field
                    rowY += 30;
                    draw->AddRectFilled(ImVec2(leftColX, rowY), ImVec2(rightColX + colW, rowY + 45),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.95f, 0.95f, 1.0f)), 3.0f);
                    draw->AddRect(ImVec2(leftColX, rowY), ImVec2(rightColX + colW, rowY + 45),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 3.0f, 0, 1.0f);

                    // Button
                    rowY += 55;
                    draw->AddRectFilled(ImVec2(leftColX, rowY), ImVec2(rightColX + colW, rowY + 25),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.25f, 0.45f, 1.0f)), 15.0f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.15f, 0.25f, 0.45f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Grid Layout").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Grid Layout");
                    ImGui::PopStyleColor();

                } else if (i == 3) { // LAYOUT 4: HORIZONTAL WIDE - Full width with side image
                    // Draw visual layout representation

                    // Gradient background
                    draw->AddRectFilledMultiColor(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.3f, 0.5f, 1.0f)),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.5f, 0.2f, 0.8f, 1.0f)),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.5f, 0.2f, 0.8f, 1.0f)),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.3f, 0.5f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.0f));
                    float titleW = ImGui::CalcTextSize("HORIZONTAL").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("HORIZONTAL");
                    ImGui::PopStyleColor();

                    // Wide container
                    float containerW = 220;
                    float containerH = 100;
                    float containerX = cardPos.x + (cardWidth - containerW) / 2;
                    float containerY = cardPos.y + 70;

                    // Top decorative image area
                    draw->AddRectFilled(ImVec2(containerX, containerY), ImVec2(containerX + containerW, containerY + 50),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.15f, 0.4f, 1.0f)), 8.0f);

                    // Circles in image area
                    for (int c = 0; c < 4; c++) {
                        float circleX = containerX + 30 + (c * 45);
                        draw->AddCircleFilled(ImVec2(circleX, containerY + 25), 15,
                            ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 0.6f, 0.8f, 0.3f)));
                    }

                    // Form area below
                    float formY = containerY + 60;
                    draw->AddRectFilled(ImVec2(containerX, formY), ImVec2(containerX + containerW, formY + 100),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)), 8.0f);

                    // Horizontal fields
                    float fieldW = 65;
                    float fieldH = 18;
                    float fieldY = formY + 15;

                    for (int row = 0; row < 2; row++) {
                        for (int col = 0; col < 3; col++) {
                            float fieldX = containerX + 10 + (col * (fieldW + 5));
                            draw->AddRectFilled(ImVec2(fieldX, fieldY), ImVec2(fieldX + fieldW, fieldY + fieldH),
                                ImGui::ColorConvertFloat4ToU32(ImVec4(0.95f, 0.9f, 0.95f, 1.0f)), 4.0f);
                            draw->AddRect(ImVec2(fieldX, fieldY), ImVec2(fieldX + fieldW, fieldY + fieldH),
                                ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.3f, 0.5f, 0.6f)), 4.0f, 0, 1.5f);
                        }
                        fieldY += 25;
                    }

                    // Wide button
                    fieldY += 5;
                    draw->AddRectFilled(ImVec2(containerX + 10, fieldY), ImVec2(containerX + containerW - 10, fieldY + 25),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.3f, 0.5f, 1.0f)), 15.0f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.3f, 0.5f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Wide Style").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Wide Style");
                    ImGui::PopStyleColor();

                } else { // LAYOUT 5: CARD STACK - Overlapping cards style
                    // Draw visual layout representation

                    // Background
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.12f, 0.18f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
                    float titleW = ImGui::CalcTextSize("ELEGANT DARK").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("ELEGANT DARK");
                    ImGui::PopStyleColor();

                    // Back card (shadow effect)
                    float cardW = 170;
                    float cardH = 180;
                    float mainX = cardPos.x + (cardWidth - cardW) / 2;
                    float mainY = cardPos.y + 80;

                    draw->AddRectFilled(ImVec2(mainX + 8, mainY + 8), ImVec2(mainX + cardW + 8, mainY + cardH + 8),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.05f, 0.05f, 0.08f, 0.6f)), 10.0f);

                    // Main card
                    draw->AddRectFilled(ImVec2(mainX, mainY), ImVec2(mainX + cardW, mainY + cardH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.18f, 0.18f, 0.24f, 1.0f)), 10.0f);
                    draw->AddRect(ImVec2(mainX, mainY), ImVec2(mainX + cardW, mainY + cardH),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.9f, 0.9f, 0.2f)), 10.0f, 0, 1.5f);

                    // Title inside card
                    float inCardY = mainY + 20;
                    draw->AddRectFilled(ImVec2(mainX + 20, inCardY), ImVec2(mainX + cardW - 20, inCardY + 12),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.9f, 0.9f, 1.0f)), 2.0f);

                    // Form fields with elegant borders
                    float fieldY = inCardY + 25;
                    for (int f = 0; f < 3; f++) {
                        draw->AddRectFilled(ImVec2(mainX + 20, fieldY), ImVec2(mainX + cardW - 20, fieldY + 18),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.15f, 0.2f, 1.0f)), 4.0f);
                        draw->AddRect(ImVec2(mainX + 20, fieldY), ImVec2(mainX + cardW - 20, fieldY + 18),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.9f, 0.9f, 0.3f)), 4.0f, 0, 1.0f);
                        fieldY += 26;
                    }

                    // Elegant button
                    fieldY += 10;
                    draw->AddRectFilled(ImVec2(mainX + 20, fieldY), ImVec2(mainX + cardW - 20, fieldY + 30),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.9f, 0.9f, 1.0f)), 15.0f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Card Style").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Card Style");
                    ImGui::PopStyleColor();
                }
            } else if (g_PickerSectionType == SEC_GALLERY) {
                ImDrawList* draw = ImGui::GetWindowDrawList();
                ImVec2 cardPos = ImGui::GetCursorScreenPos();
                float startX = 15;
                float startY = 15;

                if (i == 0) { // LAYOUT 1: 2x2 Grid
                    // Background
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.99f, 0.99f, 1.0f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.12f, 0.15f, 0.22f, 1.0f));
                    float titleW = ImGui::CalcTextSize("2x2 GRID").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("2x2 GRID");
                    ImGui::PopStyleColor();

                    // 2x2 Grid Layout
                    float gridSize = 90;
                    float gridSpacing = 10;
                    float gridStartX = cardPos.x + (cardWidth - (2 * gridSize + gridSpacing)) / 2;
                    float gridStartY = cardPos.y + 80;

                    // Row 1
                    // Image 1
                    draw->AddRectFilled(ImVec2(gridStartX, gridStartY),
                        ImVec2(gridStartX + gridSize, gridStartY + gridSize),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.88f, 0.92f, 1.0f)), 6.0f);
                    draw->AddRect(ImVec2(gridStartX, gridStartY),
                        ImVec2(gridStartX + gridSize, gridStartY + gridSize),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.15f, 0.22f, 0.3f)), 6.0f, 0, 1.5f);

                    // Image 2
                    draw->AddRectFilled(ImVec2(gridStartX + gridSize + gridSpacing, gridStartY),
                        ImVec2(gridStartX + 2*gridSize + gridSpacing, gridStartY + gridSize),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.88f, 0.92f, 1.0f)), 6.0f);
                    draw->AddRect(ImVec2(gridStartX + gridSize + gridSpacing, gridStartY),
                        ImVec2(gridStartX + 2*gridSize + gridSpacing, gridStartY + gridSize),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.15f, 0.22f, 0.3f)), 6.0f, 0, 1.5f);

                    // Row 2
                    // Image 3
                    draw->AddRectFilled(ImVec2(gridStartX, gridStartY + gridSize + gridSpacing),
                        ImVec2(gridStartX + gridSize, gridStartY + 2*gridSize + gridSpacing),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.88f, 0.92f, 1.0f)), 6.0f);
                    draw->AddRect(ImVec2(gridStartX, gridStartY + gridSize + gridSpacing),
                        ImVec2(gridStartX + gridSize, gridStartY + 2*gridSize + gridSpacing),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.15f, 0.22f, 0.3f)), 6.0f, 0, 1.5f);

                    // Image 4
                    draw->AddRectFilled(ImVec2(gridStartX + gridSize + gridSpacing, gridStartY + gridSize + gridSpacing),
                        ImVec2(gridStartX + 2*gridSize + gridSpacing, gridStartY + 2*gridSize + gridSpacing),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.88f, 0.92f, 1.0f)), 6.0f);
                    draw->AddRect(ImVec2(gridStartX + gridSize + gridSpacing, gridStartY + gridSize + gridSpacing),
                        ImVec2(gridStartX + 2*gridSize + gridSpacing, gridStartY + 2*gridSize + gridSpacing),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.15f, 0.22f, 0.3f)), 6.0f, 0, 1.5f);

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.12f, 0.15f, 0.22f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Square Grid").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Square Grid");
                    ImGui::PopStyleColor();

                } else { // LAYOUT 2: 1x4 Horizontal
                    // Background
                    draw->AddRectFilled(cardPos, ImVec2(cardPos.x + cardWidth, cardPos.y + 60),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.99f, 0.99f, 1.0f, 1.0f)));

                    // Title label
                    ImGui::SetCursorPos(ImVec2(startX, startY + 15));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.12f, 0.15f, 0.22f, 1.0f));
                    float titleW = ImGui::CalcTextSize("1x4 HORIZONTAL").x;
                    ImGui::SetCursorPosX((cardWidth - titleW) / 2);
                    ImGui::Text("1x4 HORIZONTAL");
                    ImGui::PopStyleColor();

                    // 1x4 Horizontal Layout
                    float imgWidth = 50;
                    float imgHeight = 100;
                    float imgSpacing = 8;
                    float totalWidth = 4 * imgWidth + 3 * imgSpacing;
                    float imgStartX = cardPos.x + (cardWidth - totalWidth) / 2;
                    float imgStartY = cardPos.y + 90;

                    // Draw 4 images in horizontal row
                    for (int img = 0; img < 4; img++) {
                        float imgX = imgStartX + img * (imgWidth + imgSpacing);
                        draw->AddRectFilled(ImVec2(imgX, imgStartY),
                            ImVec2(imgX + imgWidth, imgStartY + imgHeight),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.85f, 0.88f, 0.92f, 1.0f)), 6.0f);
                        draw->AddRect(ImVec2(imgX, imgStartY),
                            ImVec2(imgX + imgWidth, imgStartY + imgHeight),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.12f, 0.15f, 0.22f, 0.3f)), 6.0f, 0, 1.5f);
                    }

                    // Label at bottom
                    ImGui::SetCursorPos(ImVec2(startX, cardHeight - 35));
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.12f, 0.15f, 0.22f, 1.0f));
                    float labelW = ImGui::CalcTextSize("Horizontal Row").x;
                    ImGui::SetCursorPosX((cardWidth - labelW) / 2);
                    ImGui::Text("Horizontal Row");
                    ImGui::PopStyleColor();
                }
            } else {
                // For other sections, show emoji + mini layout preview
                ImGui::SetCursorPosX((cardWidth - 40) / 2);
                ImGui::SetCursorPosY(15);
                ImGui::PushStyleColor(ImGuiCol_Text, titleColor);
                ImGui::Text("%s", styles[i].preview_emoji.c_str());
                ImGui::PopStyleColor();

                // Mini preview bars/shapes
                ImGui::SetCursorPos(ImVec2(15, 50));
                ImDrawList* draw = ImGui::GetWindowDrawList();
                ImVec2 pos = ImGui::GetCursorScreenPos();

                // Different layout previews for each style
                if (i == 0) { // Style 1 - centered layout
                    draw->AddRectFilled(pos, ImVec2(pos.x + 120, pos.y + 8), ImGui::ColorConvertFloat4ToU32(titleColor), 4.0f);
                    draw->AddRectFilled(ImVec2(pos.x + 20, pos.y + 15), ImVec2(pos.x + 100, pos.y + 20), ImGui::ColorConvertFloat4ToU32(subtitleColor), 2.0f);
                } else if (i == 1) { // Style 2 - left aligned
                    draw->AddRectFilled(pos, ImVec2(pos.x + 80, pos.y + 10), ImGui::ColorConvertFloat4ToU32(titleColor), 2.0f);
                    draw->AddRectFilled(ImVec2(pos.x, pos.y + 15), ImVec2(pos.x + 120, pos.y + 20), ImGui::ColorConvertFloat4ToU32(subtitleColor), 2.0f);
                } else if (i == 2) { // Style 3 - cards
                    draw->AddRectFilled(pos, ImVec2(pos.x + 35, pos.y + 25), ImGui::ColorConvertFloat4ToU32(titleColor), 4.0f);
                    draw->AddRectFilled(ImVec2(pos.x + 42, pos.y), ImVec2(pos.x + 77, pos.y + 25), ImGui::ColorConvertFloat4ToU32(titleColor), 4.0f);
                    draw->AddRectFilled(ImVec2(pos.x + 84, pos.y), ImVec2(pos.x + 119, pos.y + 25), ImGui::ColorConvertFloat4ToU32(titleColor), 4.0f);
                } else if (i == 3) { // Style 4 - gradient
                    draw->AddRectFilledMultiColor(pos, ImVec2(pos.x + 120, pos.y + 25),
                        ImGui::ColorConvertFloat4ToU32(titleColor),
                        ImGui::ColorConvertFloat4ToU32(subtitleColor),
                        ImGui::ColorConvertFloat4ToU32(subtitleColor),
                        ImGui::ColorConvertFloat4ToU32(titleColor));
                } else { // Style 5 - split
                    draw->AddRectFilled(pos, ImVec2(pos.x + 55, pos.y + 25), ImGui::ColorConvertFloat4ToU32(titleColor), 2.0f);
                    draw->AddRectFilled(ImVec2(pos.x + 65, pos.y), ImVec2(pos.x + 120, pos.y + 25), ImGui::ColorConvertFloat4ToU32(subtitleColor), 2.0f);
                }
            }

            // Style name at bottom
            ImGui::SetCursorPosY(cardHeight - 45);
            ImGui::PushTextWrapPos(cardWidth - 10);
            ImGui::PushStyleColor(ImGuiCol_Text, titleColor);
            float textWidth = ImGui::CalcTextSize(styles[i].name.c_str()).x;
            ImGui::SetCursorPosX((cardWidth - textWidth) / 2);
            ImGui::Text("%s", styles[i].name.c_str());
            ImGui::PopStyleColor();
            ImGui::PopTextWrapPos();

            ImGui::EndChild();
            ImGui::PopStyleVar();
            ImGui::PopStyleColor(2);

            // Select button
            char btnLabel[32];
            snprintf(btnLabel, sizeof(btnLabel), selected ? "Selected##%d" : "Select##%d", i);
            ImGui::PushStyleColor(ImGuiCol_Button, selected ?
                ImVec4(0.2f, 0.7f, 0.3f, 1.0f) : ImVec4(0.37f, 0.51f, 0.99f, 1.0f));
            if (ImGui::Button(btnLabel, ImVec2(cardWidth, 30))) {
                g_SelectedStyleIndex = i;
            }
            ImGui::PopStyleColor();

            ImGui::EndGroup();
        }

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        // Action buttons
        ImGui::SetCursorPosX(ImGui::GetWindowWidth() - 220);
        if (ImGui::Button("Cancel", ImVec2(100, 35))) {
            g_ShowTemplatePicker = false;
            g_SelectedStyleIndex = -1;
        }

        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.37f, 0.51f, 0.99f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.42f, 0.56f, 1.0f, 1.0f));
        bool canApply = (g_SelectedStyleIndex >= 0);
        if (!canApply) ImGui::BeginDisabled();
        if (ImGui::Button("Apply Style", ImVec2(110, 35))) {
            // Create the section with the selected style
            WebSection newSection(g_NextSectionId++, g_PickerSectionType);
            ApplyStylePreset(newSection, g_SelectedStyleIndex);

            // SMART AUTO-POSITIONING: Fill remaining space
            if (!g_Sections.empty()) {
                // Get the last added section
                WebSection& lastSec = g_Sections.back();

                // If last section has width < 100%, try to fill remaining space
                if (lastSec.section_width_percent < 100.0f) {
                    float remainingSpace = 100.0f - lastSec.section_width_percent;

                    // Set new section width to fill remaining space
                    newSection.section_width_percent = remainingSpace;

                    // Determine alignment based on last section's position
                    if (lastSec.horizontal_align == 0) {
                        // Last section is LEFT aligned, place new section on RIGHT
                        newSection.horizontal_align = 2;  // Right
                    } else if (lastSec.horizontal_align == 2) {
                        // Last section is RIGHT aligned, place new section on LEFT
                        newSection.horizontal_align = 0;  // Left
                    } else {
                        // Last section is CENTER aligned, place new section on RIGHT
                        newSection.horizontal_align = 2;  // Right
                    }

                    // FORCE enable manual positioning for side-by-side layout
                    // Calculate Y position based on whether last section uses manual position
                    if (lastSec.use_manual_position) {
                        // Last section already has manual position, use same Y
                        newSection.use_manual_position = true;
                        newSection.y_position = lastSec.y_position;
                    } else {
                        // Last section doesn't have manual position, calculate current Y
                        // Sum up heights of all previous sections
                        float calculatedY = 0;
                        for (int i = 0; i < (int)g_Sections.size(); i++) {
                            if (i == (int)g_Sections.size() - 1) break; // Stop before last section
                            if (!g_Sections[i].use_manual_position) {
                                calculatedY += g_Sections[i].height;
                            }
                        }
                        // Enable manual position for BOTH sections
                        lastSec.use_manual_position = true;
                        lastSec.y_position = calculatedY;
                        newSection.use_manual_position = true;
                        newSection.y_position = calculatedY;
                    }

                    // Match height for better alignment
                    newSection.height = lastSec.height;
                }
            }

            g_Sections.push_back(newSection);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            for (int i = 0; i < (int)g_Sections.size(); i++) {
                g_Sections[i].selected = (i == g_SelectedSectionIndex);
            }

            g_ShowTemplatePicker = false;
            g_SelectedStyleIndex = -1;
        }
        if (!canApply) ImGui::EndDisabled();
        ImGui::PopStyleColor(2);

        ImGui::EndPopup();
    }

    if (!open) {
        g_ShowTemplatePicker = false;
        g_SelectedStyleIndex = -1;
    }
}

// ============================================================================
// HELPERS
// ============================================================================
std::string EscapeString(const std::string& s) {
    std::string result;
    for (char c : s) {
        if (c == '"') result += "\\\"";
        else if (c == '\\') result += "\\\\";
        else if (c == '\n') result += "\\n";
        else result += c;
    }
    return result;
}

std::string ColorToImVec4(const ImVec4& c) {
    char buf[128];
    snprintf(buf, sizeof(buf), "ImVec4(%.3ff, %.3ff, %.3ff, %.3ff)", c.x, c.y, c.z, c.w);
    return buf;
}

std::string ColorToU32(const ImVec4& c) {
    char buf[64];
    snprintf(buf, sizeof(buf), "IM_COL32(%d, %d, %d, %d)",
        (int)(c.x*255), (int)(c.y*255), (int)(c.z*255), (int)(c.w*255));
    return buf;
}

std::string GetFilename(const std::string& path) {
    size_t pos = path.find_last_of("/\\");
    return (pos != std::string::npos) ? path.substr(pos + 1) : path;
}

std::vector<std::pair<std::string, std::string>> GetAllSectionLinks() {
    std::vector<std::pair<std::string, std::string>> links;
    for (const auto& sec : g_Sections) {
        if (sec.type != SEC_NAVBAR) {
            links.push_back({sec.name, "#" + sec.section_id});
        }
    }
    return links;
}

// ============================================================================
// TEXT WRAPPING HELPER FOR LIVE PREVIEW
// ============================================================================
float DrawWrappedText(ImDrawList* dl, const std::string& text, float x, float y, float maxWidth, ImU32 color, bool center = false, float fontSize = 16.0f, float fontWeight = 400.0f, float lineHeightMultiplier = 1.2f, float letterSpacing = 0.0f) {
    if (text.empty() || maxWidth <= 0) return 0;

    // Ensure valid font size
    if (fontSize <= 0.0f) fontSize = 16.0f;
    if (fontWeight < 100.0f) fontWeight = 400.0f;

    // Calculate font scale based on desired font size (ImGui default is 13px)
    float fontScale = fontSize / 13.0f;
    ImFont* font = ImGui::GetFont();

    std::vector<std::string> lines;
    std::string currentLine;
    std::string word;

    for (size_t i = 0; i <= text.size(); i++) {
        char c = (i < text.size()) ? text[i] : ' ';

        if (c == ' ' || c == '\n' || i == text.size()) {
            if (!word.empty()) {
                std::string testLine = currentLine.empty() ? word : currentLine + " " + word;
                ImVec2 testSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, testLine.c_str());

                if (testSize.x <= maxWidth) {
                    currentLine = testLine;
                } else {
                    if (!currentLine.empty()) {
                        lines.push_back(currentLine);
                    }
                    ImVec2 wordSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, word.c_str());
                    if (wordSize.x > maxWidth) {
                        std::string truncated = word.substr(0, std::min((size_t)15, word.size())) + "...";
                        currentLine = truncated;
                    } else {
                        currentLine = word;
                    }
                }
                word.clear();
            }
            if (c == '\n' && !currentLine.empty()) {
                lines.push_back(currentLine);
                currentLine.clear();
            }
        } else {
            word += c;
        }
    }
    if (!currentLine.empty()) {
        lines.push_back(currentLine);
    }

    // Use provided line-height multiplier instead of hardcoded value
    float lineHeight = fontSize * lineHeightMultiplier;
    float totalHeight = 0;

    // Enhanced boldness simulation based on weight
    // Weight 100-400: Normal rendering
    // Weight 500-700: Medium bold (4 layers)
    // Weight 800-1200: Heavy bold (9 layers with larger offsets)
    float boldStrength = 0;
    int boldLayers = 1;

    if (fontWeight >= 800.0f) {
        boldStrength = 1.0f + ((fontWeight - 800.0f) / 400.0f) * 1.5f; // 1.0 to 2.5
        boldLayers = 9;
    } else if (fontWeight >= 500.0f) {
        boldStrength = 0.5f + ((fontWeight - 500.0f) / 300.0f) * 0.5f; // 0.5 to 1.0
        boldLayers = 4;
    }

    for (const auto& line : lines) {
        ImVec2 lineSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, line.c_str());
        float drawX = center ? (x + (maxWidth - lineSize.x) / 2) : x;

        if (boldLayers > 1) {
            // Multiple layer rendering for boldness
            for (int layer = 0; layer < boldLayers; layer++) {
                float offsetX = (layer % 3) * boldStrength * 0.5f;
                float offsetY = (layer / 3) * boldStrength * 0.5f;
                dl->AddText(font, fontSize, ImVec2(drawX + offsetX, y + totalHeight + offsetY), color, line.c_str());
            }
        } else {
            dl->AddText(font, fontSize, ImVec2(drawX, y + totalHeight), color, line.c_str());
        }

        totalHeight += lineHeight;
    }

    return totalHeight;
}

// ============================================================================
// GENERATE IMGUI C++ CODE FOR WEBASSEMBLY
// ============================================================================
std::string GenerateImGuiCPP() {
    std::stringstream cpp;

    // MULTI-PAGE SUPPORT: First sync current page and use all pages
    if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
        g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
    }

    // Collect all unique image paths from ALL PAGES (needed for rendering code)
    std::set<std::string> imagePaths;
    std::map<std::string, std::string> imageVarNames;
    int imgIdx = 0;

    for (const auto& page : g_NormalPages) {
        for (const auto& sec : page.sections) {
            if (!sec.background_image.empty() && sec.background_image != "none") {
                imagePaths.insert(sec.background_image);
            }
            for (const auto& img : sec.hero_animation_images) {
                if (!img.empty()) imagePaths.insert(img);
            }
            for (const auto& img : sec.gallery_images) {
                if (!img.empty()) imagePaths.insert(img);
            }
            if (!sec.section_image.empty() && sec.section_image != "none") {
                imagePaths.insert(sec.section_image);
            }
            if (!sec.logo_path.empty() && sec.logo_path != "none") {
                imagePaths.insert(sec.logo_path);
            }
        }
    }

    // Generate variable names for each unique image
    for (const auto& imgPath : imagePaths) {
        size_t lastSlash = imgPath.find_last_of("/\\");
        std::string filename = (lastSlash != std::string::npos) ? imgPath.substr(lastSlash + 1) : imgPath;

        // Create safe variable name from filename
        std::string varName = "g_Texture_" + std::to_string(imgIdx++);
        imageVarNames[imgPath] = varName;
    }

    cpp << R"(// Auto-generated ImGui WebAssembly Website
// Generated by ImGui Website Designer

#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include <stdio.h>
#include <string.h>
#include <string>
#include <vector>

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <emscripten/html5.h>
#endif

#include <GLFW/glfw3.h>

// STB Image for loading images
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// Embedded Inter font (auto-generated)
#include "inter_font.h"

// Global state
GLFWwindow* g_Window = nullptr;
ImVec4 g_ClearColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White background for visibility

// Scroll state (declared first for NavigateToPage)
static float g_ScrollY = 0.0f;
static float g_ScrollTarget = 0.0f;
static float g_TotalHeight = 0.0f;

// Page state - Multi-page navigation
static int g_CurrentPage = 0;
static int g_NumPages = )" << g_NormalPages.size() << R"(;
static const char* g_PageNames[] = {)";

    // Generate page names array
    for (size_t i = 0; i < g_NormalPages.size(); i++) {
        cpp << "\"" << g_NormalPages[i].name << "\"";
        if (i < g_NormalPages.size() - 1) cpp << ", ";
    }
    cpp << R"(};

// Helper: Navigate to page by name
void NavigateToPage(const char* pageName) {
    for (int i = 0; i < g_NumPages; i++) {
        if (strcmp(g_PageNames[i], pageName) == 0) {
            g_CurrentPage = i;
            g_ScrollY = 0.0f;
            g_ScrollTarget = 0.0f;
            printf("Navigated to page: %s (index %d)\n", pageName, i);
            return;
        }
    }
    printf("Page not found: %s\n", pageName);
}

static char g_ContactName[128] = "";
static char g_ContactEmail[128] = "";
static char g_ContactMessage[512] = "";
static bool g_MessageSent = false;

// Contact Form Connector fields (up to 10 fields)
static char g_FormField0[256] = "";
static char g_FormField1[256] = "";
static char g_FormField2[256] = "";
static char g_FormField3[256] = "";
static char g_FormField4[256] = "";
static char g_FormField5[256] = "";
static char g_FormField6[1024] = "";  // Textarea
static char g_FormField7[1024] = "";  // Textarea
static char g_FormField8[256] = "";
static char g_FormField9[256] = "";
static bool g_FormSubmitted = false;

// Animation state for cards
static float g_AnimTime = 0.0f;  // Global time counter in seconds
static float g_DeltaTime = 0.016f;  // ~60 FPS

// Exported function for JavaScript wheel callback
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
extern "C" {
    EMSCRIPTEN_KEEPALIVE
    void WheelCallback(int delta) {
        // delta > 0 means scroll down (increase scroll position)
        // delta < 0 means scroll up (decrease scroll position)
        g_ScrollTarget += delta * 80.0f;
    }
}
#endif
)";

    // Generate global texture variables
    if (!imagePaths.empty()) {
        cpp << "\n// Global texture variables for images\n";
        for (const auto& pair : imageVarNames) {
            const std::string& varName = pair.second;
            cpp << "static GLuint " << varName << " = 0;\n";
        }
    }

    cpp << "\n";

    // Generate FAQ state if needed
    bool hasFAQ = false;
    for (const auto& sec : g_Sections) {
        if (sec.type == SEC_FAQ) {
            hasFAQ = true;
            cpp << "static bool g_FAQExpanded[" << sec.faq_items.size() << "] = {false};\n";
            break;
        }
    }

    // Collect all unique font sizes from sections
    std::set<int> fontSizes;
    fontSizes.insert(16); // Default body
    fontSizes.insert(14); // Small
    for (const auto& sec : g_Sections) {
        fontSizes.insert((int)sec.title_font_size);
        fontSizes.insert((int)sec.subtitle_font_size);
        fontSizes.insert((int)sec.content_font_size);
        fontSizes.insert((int)sec.button_font_size);
        fontSizes.insert((int)sec.nav_font_size);
        for (const auto& item : sec.items) {
            fontSizes.insert((int)item.title_font_size);
            fontSizes.insert((int)item.desc_font_size);
        }
    }

    cpp << R"(
// Font cache - stores fonts by size
#include <map>
static std::map<int, ImFont*> g_FontCache;
static ImFont* g_FontDefault = nullptr;

// Get font by size (creates if not cached)
ImFont* GetFont(int size) {
    if (g_FontCache.count(size)) return g_FontCache[size];
    return g_FontDefault;
}

// Legacy font pointers for compatibility
static ImFont* g_FontTitle = nullptr;
static ImFont* g_FontSubtitle = nullptr;
static ImFont* g_FontBody = nullptr;
static ImFont* g_FontButton = nullptr;
static ImFont* g_FontSmall = nullptr;

// Image/Texture cache
static std::map<std::string, GLuint> g_TextureCache;

// Helper: Load image and create OpenGL texture
GLuint LoadImageTexture(const char* filename) {
    // Check cache first
    if (g_TextureCache.count(filename)) {
        return g_TextureCache[filename];
    }

    // Load image data
    int width, height, channels;
    unsigned char* data = stbi_load(filename, &width, &height, &channels, 4);
    if (!data) {
        printf("Failed to load image: %s\n", filename);
        return 0;
    }

    // Create OpenGL texture
    GLuint texture;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

    stbi_image_free(data);

    // Cache it
    g_TextureCache[filename] = texture;
    printf("Loaded texture: %s (%dx%d, ID=%u)\n", filename, width, height, texture);

    return texture;
}

// Helper: Draw background image with 'cover' sizing (like CSS background-size: cover)
// Note: WebGL doesn't support querying texture dimensions, so we just stretch to fill
void DrawBackgroundImageCover(ImDrawList* dl, GLuint texture, float x, float y, float w, float h, float bgPosX = 0.5f, float bgPosY = 0.5f) {
    if (texture == 0) return;

    // Simply draw the image stretched to cover the entire area
    // This is equivalent to CSS background-size: cover with background-position: center
    dl->AddImage(
        (ImTextureID)(intptr_t)texture,
        ImVec2(x, y),
        ImVec2(x + w, y + h),
        ImVec2(0.0f, 0.0f),
        ImVec2(1.0f, 1.0f)
    );
}

// Custom styling - Modern, clean design
void SetupImGuiStyle() {
    ImGuiStyle& style = ImGui::GetStyle();

    // Smooth, modern rounding
    style.WindowRounding = 0.0f;
    style.FrameRounding = 8.0f;
    style.GrabRounding = 8.0f;
    style.PopupRounding = 8.0f;
    style.ScrollbarRounding = 8.0f;
    style.TabRounding = 6.0f;

    // Clean spacing - 8px grid system
    style.WindowPadding = ImVec2(0, 0);
    style.FramePadding = ImVec2(16, 12);
    style.ItemSpacing = ImVec2(12, 8);
    style.ItemInnerSpacing = ImVec2(8, 4);

    // Modern minimal borders
    style.WindowBorderSize = 0.0f;
    style.FrameBorderSize = 0.0f;
    style.PopupBorderSize = 1.0f;

    // Anti-aliasing for smooth edges
    style.AntiAliasedLines = true;
    style.AntiAliasedFill = true;

    ImVec4* colors = style.Colors;

    // Clean white/light gray backgrounds
    colors[ImGuiCol_WindowBg] = ImVec4(0.98f, 0.98f, 0.99f, 1.0f);
    colors[ImGuiCol_ChildBg] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    colors[ImGuiCol_PopupBg] = ImVec4(1.0f, 1.0f, 1.0f, 0.98f);

    // Modern blue accent (#4F6BF7 - vibrant but professional)
    colors[ImGuiCol_Button] = ImVec4(0.31f, 0.42f, 0.97f, 1.0f);
    colors[ImGuiCol_ButtonHovered] = ImVec4(0.38f, 0.50f, 1.0f, 1.0f);
    colors[ImGuiCol_ButtonActive] = ImVec4(0.25f, 0.35f, 0.90f, 1.0f);

    // Subtle input fields
    colors[ImGuiCol_FrameBg] = ImVec4(0.96f, 0.97f, 0.98f, 1.0f);
    colors[ImGuiCol_FrameBgHovered] = ImVec4(0.93f, 0.94f, 0.97f, 1.0f);
    colors[ImGuiCol_FrameBgActive] = ImVec4(0.90f, 0.92f, 0.96f, 1.0f);

    // Dark readable text
    colors[ImGuiCol_Text] = ImVec4(0.11f, 0.13f, 0.17f, 1.0f);
    colors[ImGuiCol_TextDisabled] = ImVec4(0.55f, 0.58f, 0.65f, 1.0f);

    // Accent colors
    colors[ImGuiCol_CheckMark] = ImVec4(0.31f, 0.42f, 0.97f, 1.0f);
    colors[ImGuiCol_SliderGrab] = ImVec4(0.31f, 0.42f, 0.97f, 1.0f);
    colors[ImGuiCol_SliderGrabActive] = ImVec4(0.25f, 0.35f, 0.90f, 1.0f);

    // Headers
    colors[ImGuiCol_Header] = ImVec4(0.31f, 0.42f, 0.97f, 0.15f);
    colors[ImGuiCol_HeaderHovered] = ImVec4(0.31f, 0.42f, 0.97f, 0.25f);
    colors[ImGuiCol_HeaderActive] = ImVec4(0.31f, 0.42f, 0.97f, 0.35f);

    // Subtle borders and separators
    colors[ImGuiCol_Border] = ImVec4(0.88f, 0.89f, 0.92f, 1.0f);
    colors[ImGuiCol_Separator] = ImVec4(0.90f, 0.91f, 0.93f, 1.0f);
}

// Helper: Draw modern card with layered shadow (like CSS box-shadow)
void DrawCardWithShadow(ImDrawList* dl, float x, float y, float w, float h, ImU32 color, float rounding = 12.0f) {
    // Modern multi-layer shadow (similar to CSS: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1))
    // Layer 3 - Soft outer glow
    dl->AddRectFilled(ImVec2(x-2, y+8), ImVec2(x+w+2, y+h+12), IM_COL32(0,0,0,8), rounding+2);
    // Layer 2 - Medium shadow
    dl->AddRectFilled(ImVec2(x, y+4), ImVec2(x+w, y+h+6), IM_COL32(0,0,0,15), rounding+1);
    // Layer 1 - Tight shadow
    dl->AddRectFilled(ImVec2(x+1, y+2), ImVec2(x+w-1, y+h+2), IM_COL32(0,0,0,10), rounding);
    // Card background
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), color, rounding);
    // Subtle top highlight (glass effect)
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+2), IM_COL32(255,255,255,20), rounding, ImDrawFlags_RoundCornersTop);
}

// Helper: Draw vertical gradient rect
void DrawGradientRect(ImDrawList* dl, float x, float y, float w, float h, ImU32 colTop, ImU32 colBot) {
    dl->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+w, y+h), colTop, colTop, colBot, colBot);
}

// Helper: Draw diagonal gradient (top-left to bottom-right)
void DrawDiagonalGradient(ImDrawList* dl, float x, float y, float w, float h, ImU32 col1, ImU32 col2) {
    dl->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+w, y+h), col1, col2, col2, col1);
}

// Helper: Draw modern gradient with multiple color stops (simulated)
void DrawModernGradient(ImDrawList* dl, float x, float y, float w, float h, ImU32 colStart, ImU32 colMid, ImU32 colEnd) {
    // Top half - start to mid
    dl->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+w, y+h*0.5f), colStart, colStart, colMid, colMid);
    // Bottom half - mid to end
    dl->AddRectFilledMultiColor(ImVec2(x, y+h*0.5f), ImVec2(x+w, y+h), colMid, colMid, colEnd, colEnd);
}

// Helper: Draw glassmorphism card (frosted glass effect)
void DrawGlassCard(ImDrawList* dl, float x, float y, float w, float h, float opacity, ImU32 tintColor, float rounding = 16.0f) {
    // Outer glow/shadow for depth
    dl->AddRectFilled(ImVec2(x-1, y+6), ImVec2(x+w+1, y+h+8), IM_COL32(0,0,0,15), rounding+2);

    // Glass background with transparency
    int tintR = (tintColor >> 0) & 0xFF;
    int tintG = (tintColor >> 8) & 0xFF;
    int tintB = (tintColor >> 16) & 0xFF;
    int alpha = (int)(opacity * 255);
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(tintR, tintG, tintB, alpha), rounding);

    // Frosted/blur simulation - multiple translucent layers
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(255, 255, 255, 8), rounding);

    // Top highlight (glass shine)
    dl->AddRectFilledMultiColor(
        ImVec2(x+2, y+2), ImVec2(x+w-2, y + h*0.35f),
        IM_COL32(255, 255, 255, 40), IM_COL32(255, 255, 255, 40),
        IM_COL32(255, 255, 255, 5), IM_COL32(255, 255, 255, 5)
    );

    // Glass border (subtle)
    dl->AddRect(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(255, 255, 255, 50), rounding, 0, 1.0f);
    // Inner border highlight
    dl->AddRect(ImVec2(x+1, y+1), ImVec2(x+w-1, y+h-1), IM_COL32(255, 255, 255, 20), rounding-1, 0, 1.0f);
}

// Enhanced glass card with configurable border and highlight - FIXED OVERLAPPING
void DrawGlassCardEnhanced(ImDrawList* dl, float x, float y, float w, float h, float opacity, ImU32 tintColor,
    float rounding, float borderWidth, ImU32 borderColor, bool showHighlight, float highlightOpacity) {
    // Subtle shadow for depth (lighter to avoid dark overlap)
    dl->AddRectFilled(ImVec2(x, y+4), ImVec2(x+w, y+h+6), IM_COL32(0,0,0,12), rounding+1);

    // Glass background with transparency - SINGLE LAYER ONLY
    int tintR = (tintColor >> 0) & 0xFF;
    int tintG = (tintColor >> 8) & 0xFF;
    int tintB = (tintColor >> 16) & 0xFF;
    int alpha = (int)(opacity * 255);
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(tintR, tintG, tintB, alpha), rounding);

    // REMOVED: Multiple overlapping blur layers that caused messy appearance
    // Now using single clean glass background instead

    // Top highlight (glass shine) - ONLY if enabled
    if (showHighlight) {
        int hlAlpha = (int)(highlightOpacity * 255 * 0.4f);  // Reduced from 0.5f for subtlety
        dl->AddRectFilledMultiColor(
            ImVec2(x+2, y+2), ImVec2(x+w-2, y + h*0.35f),  // Smaller highlight area
            IM_COL32(255, 255, 255, hlAlpha), IM_COL32(255, 255, 255, hlAlpha),
            IM_COL32(255, 255, 255, 0), IM_COL32(255, 255, 255, 0)
        );
    }

    // Glass border - configurable
    if (borderWidth > 0) {
        dl->AddRect(ImVec2(x, y), ImVec2(x+w, y+h), borderColor, rounding, 0, borderWidth);
        // REMOVED: Inner border that caused double-border overlap
    }
}

// Helper: Draw glassmorphism button
void DrawGlassButton(ImDrawList* dl, const char* label, float x, float y, float w, float h, float opacity, ImU32 tintColor, ImU32 textColor, float rounding = 12.0f) {
    ImGuiIO& io = ImGui::GetIO();
    bool hovered = (io.MousePos.x >= x && io.MousePos.x <= x+w && io.MousePos.y >= y && io.MousePos.y <= y+h);
    bool pressed = hovered && ImGui::IsMouseDown(0);

    float effectiveOpacity = opacity + (hovered ? 0.1f : 0.0f);
    float pressOffset = pressed ? 1.0f : 0.0f;

    int tintR = (tintColor >> 0) & 0xFF;
    int tintG = (tintColor >> 8) & 0xFF;
    int tintB = (tintColor >> 16) & 0xFF;

    // Shadow
    if (!pressed) {
        dl->AddRectFilled(ImVec2(x+1, y+4), ImVec2(x+w+1, y+h+4), IM_COL32(0,0,0,20), rounding);
    }

    // Glass background
    int alpha = (int)(effectiveOpacity * 255);
    dl->AddRectFilled(ImVec2(x, y+pressOffset), ImVec2(x+w, y+h+pressOffset), IM_COL32(tintR, tintG, tintB, alpha), rounding);

    // Top highlight
    dl->AddRectFilledMultiColor(
        ImVec2(x+2, y+2+pressOffset), ImVec2(x+w-2, y + h*0.4f + pressOffset),
        IM_COL32(255, 255, 255, 50), IM_COL32(255, 255, 255, 50),
        IM_COL32(255, 255, 255, 0), IM_COL32(255, 255, 255, 0)
    );

    // Border
    dl->AddRect(ImVec2(x, y+pressOffset), ImVec2(x+w, y+h+pressOffset), IM_COL32(255, 255, 255, 60), rounding, 0, 1.0f);

    // Text
    if (g_FontButton) ImGui::PushFont(g_FontButton);
    ImVec2 sz = ImGui::CalcTextSize(label);
    dl->AddText(ImVec2(x + (w-sz.x)/2, y + (h-sz.y)/2 + pressOffset), textColor, label);
    if (g_FontButton) ImGui::PopFont();
}

// NOTE: DrawIcon function moved to top of file after forward declaration

// Helper: Draw glass panel (for drag-drop glass elements)
void DrawGlassPanel(ImDrawList* dl, float x, float y, float w, float h, const char* text, float textSize, ImU32 textColor, float opacity, ImU32 tintColor, float rounding = 16.0f) {
    // Draw the glass effect
    DrawGlassCard(dl, x, y, w, h, opacity, tintColor, rounding);

    // Draw text if provided
    if (text && *text) {
        ImFont* font = GetFont((int)textSize);
        if (font) ImGui::PushFont(font);
        ImVec2 sz = ImGui::CalcTextSize(text);
        float textX = x + (w - sz.x) / 2;
        float textY = y + (h - sz.y) / 2;
        dl->AddText(ImVec2(textX, textY), textColor, text);
        if (font) ImGui::PopFont();
    }
}

// Helper: Draw centered text with font
void DrawCenteredText(ImDrawList* dl, ImFont* font, const char* text, float x, float y, float width, ImU32 color) {
    if (font) ImGui::PushFont(font);
    ImVec2 sz = ImGui::CalcTextSize(text);
    dl->AddText(ImVec2(x + (width - sz.x)/2, y), color, text);
    if (font) ImGui::PopFont();
}

// Helper: Draw wrapped text (word wrap)
float DrawWrappedTextEx(ImDrawList* dl, ImFont* font, const char* text, float x, float y, float maxWidth, ImU32 color, bool centered = false) {
    if (!text || !*text) return 0;
    if (font) ImGui::PushFont(font);

    std::string str(text);
    std::vector<std::string> lines;
    std::string currentLine;
    float spaceWidth = ImGui::CalcTextSize(" ").x;
    float lineHeight = ImGui::GetTextLineHeight();

    // Split into words
    std::string word;
    for (size_t i = 0; i <= str.size(); i++) {
        char c = (i < str.size()) ? str[i] : ' ';
        if (c == ' ' || c == '\n' || i == str.size()) {
            if (!word.empty()) {
                ImVec2 wordSize = ImGui::CalcTextSize(word.c_str());
                ImVec2 lineSize = ImGui::CalcTextSize(currentLine.c_str());

                if (lineSize.x + wordSize.x > maxWidth && !currentLine.empty()) {
                    lines.push_back(currentLine);
                    currentLine = word;
                } else {
                    if (!currentLine.empty()) currentLine += " ";
                    currentLine += word;
                }
                word.clear();
            }
            if (c == '\n' && !currentLine.empty()) {
                lines.push_back(currentLine);
                currentLine.clear();
            }
        } else {
            word += c;
        }
    }
    if (!currentLine.empty()) lines.push_back(currentLine);

    // Draw lines
    float totalHeight = 0;
    for (const auto& line : lines) {
        ImVec2 lineSize = ImGui::CalcTextSize(line.c_str());
        float drawX = centered ? (x + (maxWidth - lineSize.x) / 2) : x;
        dl->AddText(ImVec2(drawX, y + totalHeight), color, line.c_str());
        totalHeight += lineHeight + 4;
    }

    if (font) ImGui::PopFont();
    return totalHeight;
}

// Modern Service Card with animation
void DrawModernServiceCard(ImDrawList* dl, float x, float y, float w, float h,
                          const char* title, const char* subtitle,
                          const char** bullets, int bulletCount,
                          ImU32 iconColor, float animProgress) {
    // Animation: slide in from right
    float slideOffset = (1.0f - animProgress) * 150.0f;
    x += slideOffset;
    float alpha = animProgress;

    // Card shadow (soft, modern)
    dl->AddRectFilled(ImVec2(x + 2, y + 8), ImVec2(x + w + 2, y + h + 8),
                     IM_COL32(0, 0, 0, (int)(15 * alpha)), 16.0f);

    // Card background (white)
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h),
                     IM_COL32(255, 255, 255, (int)(255 * alpha)), 16.0f);

    // Card border (light gray, complete)
    dl->AddRect(ImVec2(x, y), ImVec2(x + w, y + h),
               IM_COL32(230, 230, 230, (int)(255 * alpha)), 16.0f, 0, 1.0f);

    // Title (bold, dark) - starts from top
    ImFont* font = ImGui::GetFont();
    float textY = y + 32;
    dl->AddText(font, 22.0f, ImVec2(x + 24, textY),
               IM_COL32(18, 18, 18, (int)(255 * alpha)), title);
    textY += 32;

    // Subtitle (gray)
    dl->AddText(font, 15.0f, ImVec2(x + 24, textY),
               IM_COL32(115, 115, 128, (int)(255 * alpha)), subtitle);
    textY += 36;

    // Bullet points
    for (int i = 0; i < bulletCount && i < 3; i++) {
        // Bullet icon (small dark circle)
        dl->AddCircleFilled(ImVec2(x + 30, textY + 7), 3, IM_COL32(60, 60, 67, (int)(255 * alpha)));

        // Bullet text
        dl->AddText(font, 14.0f, ImVec2(x + 42, textY),
                   IM_COL32(60, 60, 67, (int)(255 * alpha)), bullets[i]);
        textY += 24;
    }

    // "Learn More" link with arrow at bottom
    textY = y + h - 40;
    dl->AddText(font, 15.0f, ImVec2(x + 24, textY),
               IM_COL32(0, 112, 243, (int)(255 * alpha)), "Learn More ->");
}

// Smooth animation state for buttons
static std::map<std::string, float> g_ButtonHoverState;

// Helper: Draw modern button with smooth hover effect
bool DrawStyledButton(ImDrawList* dl, const char* label, float x, float y, float w, float h, ImU32 bgColor, ImU32 textColor, float rounding = 10.0f) {
    ImGuiIO& io = ImGui::GetIO();
    bool hovered = (io.MousePos.x >= x && io.MousePos.x <= x+w && io.MousePos.y >= y && io.MousePos.y <= y+h);
    bool clicked = hovered && ImGui::IsMouseClicked(0);
    bool pressed = hovered && ImGui::IsMouseDown(0);

    // Get/create hover animation state
    std::string btnId = std::string(label) + std::to_string((int)x) + std::to_string((int)y);
    float& hoverAnim = g_ButtonHoverState[btnId];

    // Smooth hover transition (0.0 to 1.0)
    float targetHover = hovered ? 1.0f : 0.0f;
    hoverAnim += (targetHover - hoverAnim) * 0.15f;

    // Extract RGBA from bgColor
    int r = (bgColor >> 0) & 0xFF;
    int g = (bgColor >> 8) & 0xFF;
    int b = (bgColor >> 16) & 0xFF;

    // Hover effect - brighten and slightly saturate
    r = r + (int)(30 * hoverAnim); if (r > 255) r = 255;
    g = g + (int)(30 * hoverAnim); if (g > 255) g = 255;
    b = b + (int)(30 * hoverAnim); if (b > 255) b = 255;
    ImU32 finalBg = IM_COL32(r, g, b, 255);

    // Press effect - slight scale down simulation via position offset
    float pressOffset = pressed ? 1.0f : 0.0f;

    // Modern layered shadow (less shadow when pressed/hovered for "lift" effect)
    float shadowAlpha = 35 - (hoverAnim * 10) - (pressOffset * 15);
    dl->AddRectFilled(ImVec2(x+2-pressOffset, y+4-pressOffset*2), ImVec2(x+w+2-pressOffset, y+h+4-pressOffset*2), IM_COL32(0,0,0,(int)shadowAlpha), rounding);
    dl->AddRectFilled(ImVec2(x+1, y+2-pressOffset), ImVec2(x+w+1, y+h+2-pressOffset), IM_COL32(0,0,0,15), rounding);

    // Button background with hover glow
    float btnY = y + pressOffset;
    dl->AddRectFilled(ImVec2(x, btnY), ImVec2(x+w, btnY+h), finalBg, rounding);

    // Subtle inner highlight (top edge)
    dl->AddRectFilled(ImVec2(x+2, btnY+1), ImVec2(x+w-2, btnY+3), IM_COL32(255,255,255,25), rounding);

    // Border for definition (subtle)
    dl->AddRect(ImVec2(x, btnY), ImVec2(x+w, btnY+h), IM_COL32(0,0,0,15), rounding, 0, 1.0f);

    // Text with slight shadow for readability
    if (g_FontButton) ImGui::PushFont(g_FontButton);
    ImVec2 sz = ImGui::CalcTextSize(label);
    float textX = x + (w-sz.x)/2;
    float textY = btnY + (h-sz.y)/2;
    // Text shadow
    dl->AddText(ImVec2(textX+1, textY+1), IM_COL32(0,0,0,30), label);
    // Main text
    dl->AddText(ImVec2(textX, textY), textColor, label);
    if (g_FontButton) ImGui::PopFont();

    return clicked;
}

// Helper: Draw pill/rounded button (for secondary actions)
bool DrawPillButton(ImDrawList* dl, const char* label, float x, float y, float w, float h, ImU32 borderColor, ImU32 textColor) {
    ImGuiIO& io = ImGui::GetIO();
    bool hovered = (io.MousePos.x >= x && io.MousePos.x <= x+w && io.MousePos.y >= y && io.MousePos.y <= y+h);
    bool clicked = hovered && ImGui::IsMouseClicked(0);

    float rounding = h / 2.0f;  // Full pill shape
    ImU32 bgColor = hovered ? IM_COL32(245, 247, 250, 255) : IM_COL32(255, 255, 255, 255);

    // Background
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), bgColor, rounding);
    // Border
    dl->AddRect(ImVec2(x, y), ImVec2(x+w, y+h), borderColor, rounding, 0, 1.5f);

    // Text
    if (g_FontButton) ImGui::PushFont(g_FontButton);
    ImVec2 sz = ImGui::CalcTextSize(label);
    dl->AddText(ImVec2(x + (w-sz.x)/2, y + (h-sz.y)/2), textColor, label);
    if (g_FontButton) ImGui::PopFont();

    return clicked;
}

// Drag scroll state
static bool g_IsDragging = false;
static float g_LastMouseY = 0.0f;
static float g_ScrollVelocity = 0.0f;

// Main website rendering
void RenderWebsite() {
    ImGuiIO& io = ImGui::GetIO();
    float winW = io.DisplaySize.x;
    float winH = io.DisplaySize.y;

    // Handle mouse wheel scrolling (optimized for Mac trackpad two-finger scrolling)
    if (io.MouseWheel != 0) {
        g_ScrollTarget -= io.MouseWheel * 100.0f;  // Increased from 80 to 100 for smoother trackpad scrolling
        g_ScrollVelocity = 0;  // Stop momentum when using wheel
    }

    // Handle mouse drag scrolling (like mobile/touch)
    if (ImGui::IsMouseDown(0)) {
        if (!g_IsDragging) {
            g_IsDragging = true;
            g_LastMouseY = io.MousePos.y;
            g_ScrollVelocity = 0;
        } else {
            float deltaY = g_LastMouseY - io.MousePos.y;
            g_ScrollTarget += deltaY;
            g_ScrollVelocity = deltaY;
            g_LastMouseY = io.MousePos.y;
        }
    } else {
        if (g_IsDragging) {
            g_IsDragging = false;
            // Apply momentum
            g_ScrollTarget += g_ScrollVelocity * 5.0f;
        }
        // Decay velocity
        g_ScrollVelocity *= 0.95f;
    }

    // Handle arrow keys for scrolling
    if (ImGui::IsKeyDown(ImGuiKey_DownArrow) || ImGui::IsKeyDown(ImGuiKey_PageDown)) {
        g_ScrollTarget += 20.0f;
    }
    if (ImGui::IsKeyDown(ImGuiKey_UpArrow) || ImGui::IsKeyDown(ImGuiKey_PageUp)) {
        g_ScrollTarget -= 20.0f;
    }
    if (ImGui::IsKeyPressed(ImGuiKey_Home)) {
        g_ScrollTarget = 0;
    }
    if (ImGui::IsKeyPressed(ImGuiKey_End)) {
        g_ScrollTarget = g_TotalHeight - winH;
    }

    // Smooth scrolling with optimized response for Mac trackpad
    g_ScrollY += (g_ScrollTarget - g_ScrollY) * 0.25f;  // Increased from 0.2f to 0.25f for smoother feel

    // Clamp scroll
    if (g_ScrollY < 0) { g_ScrollY = 0; g_ScrollTarget = 0; }
    float maxScroll = g_TotalHeight - winH;
    if (maxScroll < 0) maxScroll = 0;
    if (g_ScrollY > maxScroll) {
        g_ScrollY = maxScroll;
        g_ScrollTarget = maxScroll;
    }

    // Main fullscreen window
    ImGui::SetNextWindowPos(ImVec2(0, 0));
    ImGui::SetNextWindowSize(ImVec2(winW, winH));
    ImGui::Begin("##Website", nullptr,
        ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
        ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar |
        ImGuiWindowFlags_NoBackground);

    ImDrawList* dl = ImGui::GetWindowDrawList();
    float yPos = -g_ScrollY;  // Apply scroll offset

)";

    // MULTI-PAGE: Generate rendering code for ALL pages
    size_t globalSecIdx = 0;
    for (size_t pageIdx = 0; pageIdx < g_NormalPages.size(); pageIdx++) {
        const auto& currentPage = g_NormalPages[pageIdx];

        // Open page block
        cpp << "\n    // ==================== PAGE " << pageIdx << ": " << currentPage.name << " ====================\n";
        cpp << "    if (g_CurrentPage == " << pageIdx << ") {\n";
        cpp << "        yPos = -g_ScrollY;  // Reset yPos for this page\n";

        for (size_t secIdx = 0; secIdx < currentPage.sections.size(); secIdx++) {
            const auto& sec = currentPage.sections[secIdx];

        cpp << "    // ===== " << sec.name << " =====\n";
        cpp << "    {\n";
        cpp << "        float secY = yPos;\n";
        cpp << "        float secH = " << sec.height << ";\n";
        // Use ACTUAL section width and x_position from designer (respect user-defined sizes)
        float actualWidth = sec.width > 0 ? sec.width : 800.0f;
        float actualX = sec.x_position;
        cpp << "        float secW = " << actualWidth << ";\n";
        cpp << "        float secX = " << actualX << ";\n";
        // Apply horizontal alignment if section is not full width
        if (sec.horizontal_align == 1) { // Center
            cpp << "        secX = (winW - secW) / 2;\n";
        } else if (sec.horizontal_align == 2) { // Right
            cpp << "        secX = winW - secW;\n";
        }
        cpp << "        ImVec2 secMin(secX, secY);\n";
        cpp << "        ImVec2 secMax(secX + secW, secY + secH);\n\n";

        // Animation code generation
        if (sec.animation_type != ANIM_NONE) {
            cpp << "        // Animation: " << g_AnimationNames[sec.animation_type] << "\n";
            cpp << "        static float animTime" << globalSecIdx << " = 0.0f;\n";
            cpp << "        static bool animStarted" << globalSecIdx << " = false;\n";
            cpp << "        if (!animStarted" << globalSecIdx << ") {\n";
            cpp << "            animTime" << globalSecIdx << " = 0.0f;\n";
            cpp << "            animStarted" << globalSecIdx << " = true;\n";
            cpp << "        }\n";
            cpp << "        animTime" << globalSecIdx << " += io.DeltaTime;\n";
            // Format animation duration properly for C++ code
            char durationStr[32];
            snprintf(durationStr, sizeof(durationStr), "%.1ff", sec.animation_duration);
            // Use inline clamp instead of ImClamp (which may not be available in generated code)
            cpp << "        float animProgress = (animTime" << globalSecIdx << " / " << durationStr << ");\n";
            cpp << "        animProgress = (animProgress < 0.0f) ? 0.0f : (animProgress > 1.0f) ? 1.0f : animProgress;\n";

            switch (sec.animation_type) {
                case ANIM_FADE_IN:
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_SLIDE_UP:
                    cpp << "        float animOffset = (1.0f - animProgress) * 100.0f;\n";
                    cpp << "        secY += animOffset;\n";
                    cpp << "        secMin.y += animOffset; secMax.y += animOffset;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_SLIDE_DOWN:
                    cpp << "        float animOffset = (1.0f - animProgress) * -100.0f;\n";
                    cpp << "        secY += animOffset;\n";
                    cpp << "        secMin.y += animOffset; secMax.y += animOffset;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_SLIDE_LEFT:
                    cpp << "        float animOffsetX = (1.0f - animProgress) * 200.0f;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_SLIDE_RIGHT:
                    cpp << "        float animOffsetX = (1.0f - animProgress) * -200.0f;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_ZOOM_IN:
                    cpp << "        float animScale = 0.5f + animProgress * 0.5f;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_ZOOM_OUT:
                    cpp << "        float animScale = 1.5f - animProgress * 0.5f;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_BOUNCE:
                    cpp << "        float animBounce = sinf(animProgress * 3.14159f * 2.0f) * (1.0f - animProgress) * 50.0f;\n";
                    cpp << "        secY -= animBounce;\n";
                    cpp << "        secMin.y -= animBounce; secMax.y -= animBounce;\n";
                    cpp << "        float animAlpha = animProgress;\n";
                    break;
                case ANIM_ROTATE_IN:
                    cpp << "        float animAlpha = animProgress;\n";
                    cpp << "        float animRotation = (1.0f - animProgress) * 360.0f;\n";
                    break;
                default:
                    cpp << "        float animAlpha = 1.0f;\n";
                    break;
            }

            if (sec.animation_repeat) {
                cpp << "        if (animProgress >= 1.0f) { animTime" << globalSecIdx << " = 0.0f; animStarted" << globalSecIdx << " = false; }\n";
            }
            cpp << "\n";
        }

        // Background
        cpp << "        // Background\n";

        // Check if section has background image
        bool hasBackgroundImage = !sec.background_image.empty() && sec.background_image != "none" && imageVarNames.count(sec.background_image);
        bool hasHeroAnimation = !sec.hero_animation_images.empty() && sec.enable_hero_animation;

        if (hasHeroAnimation) {
            // Generate hero animation code
            cpp << "        // Hero animation (slideshow)\n";
            cpp << "        static float animTimer" << globalSecIdx << " = 0.0f;\n";
            cpp << "        static int animFrame" << globalSecIdx << " = 0;\n";
            cpp << "        animTimer" << globalSecIdx << " += io.DeltaTime;\n";
            cpp << "        if (animTimer" << globalSecIdx << " >= " << std::fixed << std::setprecision(1) << sec.hero_animation_speed << "f) {\n";
            cpp << "            animTimer" << globalSecIdx << " = 0.0f;\n";
            cpp << "            animFrame" << globalSecIdx << "++;\n";
            cpp << "            if (animFrame" << globalSecIdx << " >= " << sec.hero_animation_images.size() << ") animFrame" << globalSecIdx << " = 0;\n";
            cpp << "        }\n";
            cpp << "        GLuint animTex = 0;\n";
            cpp << "        if (animFrame" << globalSecIdx << " == 0) animTex = " << imageVarNames[sec.hero_animation_images[0]] << ";\n";
            for (size_t i = 1; i < sec.hero_animation_images.size(); i++) {
                cpp << "        else if (animFrame" << globalSecIdx << " == " << i << ") animTex = " << imageVarNames[sec.hero_animation_images[i]] << ";\n";
            }
            cpp << "        DrawBackgroundImageCover(dl, animTex, 0, secY, winW, secH);\n";
        } else if (hasBackgroundImage) {
            // Single background image
            cpp << "        DrawBackgroundImageCover(dl, " << imageVarNames[sec.background_image] << ", 0, secY, winW, secH);\n";
        } else {
            // Solid color background
            cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
        }

        cpp << "\n";

        // Generate glass panels for this section
        if (!sec.glass_panels.empty()) {
            cpp << "        // Glass Panels\n";
            for (const auto& gp : sec.glass_panels) {
                cpp << "        DrawGlassPanel(dl, " << std::fixed << std::setprecision(1) << gp.x << "f, secY + " << gp.y << "f, " << gp.width << "f, " << gp.height << "f, \"" << EscapeString(gp.text) << "\", " << gp.text_size << "f, " << ColorToU32(gp.text_color) << ", " << std::setprecision(2) << gp.opacity << "f, " << ColorToU32(gp.tint) << ", " << std::setprecision(1) << gp.border_radius << "f);\n";
            }
            cpp << "\n";
        }

        switch (sec.type) {
            case SEC_NAVBAR: {
                cpp << "        // Modern Navbar with subtle shadow\n";
                cpp << "        float navH = secH;\n";
                cpp << "        // Navbar background\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.nav_bg_color) << ");\n";
                cpp << "        // Bottom shadow for depth\n";
                cpp << "        dl->AddRectFilledMultiColor(ImVec2(0, secY + navH), ImVec2(winW, secY + navH + 4), IM_COL32(0,0,0,12), IM_COL32(0,0,0,12), IM_COL32(0,0,0,0), IM_COL32(0,0,0,0));\n";
                cpp << "        // Logo + Brand with modern font\n";
                cpp << "        ImFont* brandFont = GetFont(" << (int)sec.title_font_size << ");\n";
                cpp << "        if (brandFont) ImGui::PushFont(brandFont);\n";
                cpp << "        ImVec2 brandSize = ImGui::CalcTextSize(\"" << EscapeString(sec.title) << "\");\n";
                cpp << "        float startX = 40;\n";
                cpp << "        float centerY = secY + navH/2;\n";

                // Add logo rendering if exists
                if (sec.logo_texture_id != 0 && !sec.logo_path.empty()) {
                    auto it = imageVarNames.find(sec.logo_path);
                    if (it != imageVarNames.end()) {
                        cpp << "        // Render Logo\n";
                        cpp << "        if (" << it->second << " != 0) {\n";
                        cpp << "            float logoSize = " << sec.logo_size << ";\n";

                        if (sec.brand_text_position == 0) {
                            // SIDE: Logo left, text right
                            cpp << "            float logoY = centerY - logoSize/2;\n";
                            cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(startX, logoY), ImVec2(startX + logoSize, logoY + logoSize));\n";
                            cpp << "            startX += logoSize + 15;\n";
                        } else if (sec.brand_text_position == 1) {
                            // ABOVE: Text above logo
                            cpp << "            float logoY = centerY;\n";
                            cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(startX, logoY), ImVec2(startX + logoSize, logoY + logoSize));\n";
                            cpp << "            centerY = logoY - brandSize.y - 8;\n";
                        } else if (sec.brand_text_position == 2) {
                            // BELOW: Text below logo
                            cpp << "            float logoY = centerY - logoSize - brandSize.y/2 - 8;\n";
                            cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(startX, logoY), ImVec2(startX + logoSize, logoY + logoSize));\n";
                            cpp << "            centerY = logoY + logoSize + 8;\n";
                        }

                        cpp << "        }\n";
                    }
                }

                cpp << "        dl->AddText(ImVec2(startX, centerY - brandSize.y/2), " << ColorToU32(sec.title_color) << ", \"" << EscapeString(sec.title) << "\");\n";
                cpp << "        if (brandFont) ImGui::PopFont();\n";
                cpp << "        // Nav items with hover effect\n";
                cpp << "        float navX = winW - 40;\n";
                cpp << "        ImFont* navFont = GetFont(" << (int)sec.nav_font_size << ");\n";
                for (int i = (int)sec.nav_items.size() - 1; i >= 0; i--) {
                    cpp << "        {\n";
                    cpp << "            if (navFont) ImGui::PushFont(navFont);\n";
                    cpp << "            const char* label = \"" << EscapeString(sec.nav_items[i].label) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(label);\n";
                    cpp << "            navX -= sz.x + 32;\n";
                    cpp << "            float itemY = secY + navH/2 - sz.y/2;\n";
                    cpp << "            // Check hover\n";
                    cpp << "            bool hovered = (io.MousePos.x >= navX - 8 && io.MousePos.x <= navX + sz.x + 8 && io.MousePos.y >= itemY - 4 && io.MousePos.y <= itemY + sz.y + 4);\n";
                    cpp << "            // Hover underline effect\n";
                    cpp << "            if (hovered) {\n";
                    cpp << "                dl->AddRectFilled(ImVec2(navX, itemY + sz.y + 2), ImVec2(navX + sz.x, itemY + sz.y + 4), " << ColorToU32(sec.accent_color) << ", 1.0f);\n";
                    cpp << "            }\n";
                    cpp << "            dl->AddText(ImVec2(navX, itemY), hovered ? " << ColorToU32(sec.accent_color) << " : " << ColorToU32(sec.nav_text_color) << ", label);\n";
                    cpp << "            if (navFont) ImGui::PopFont();\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_HERO:
            case SEC_CTA: {
                cpp << "        // Modern Hero/CTA with gradient background option\n";
                // Create a subtle gradient version of the bg color
                ImVec4 bgCol = sec.bg_color;
                ImVec4 gradEnd = ImVec4(
                    bgCol.x * 0.92f,
                    bgCol.y * 0.92f,
                    bgCol.z * 0.95f,
                    bgCol.w
                );
                cpp << "        // Gradient background (top to bottom)\n";
                cpp << "        DrawGradientRect(dl, 0, secY, winW, secH, " << ColorToU32(sec.bg_color) << ", " << ColorToU32(gradEnd) << ");\n";

                // Add section image rendering if exists
                if (!sec.section_image.empty() && sec.section_image != "none") {
                    auto it = imageVarNames.find(sec.section_image);
                    if (it != imageVarNames.end()) {
                        cpp << "        // Render section image\n";
                        cpp << "        if (" << it->second << " != 0) {\n";
                        cpp << "            float imgW = winW * 0.6f;  // 60% of window width\n";
                        cpp << "            float imgH = secH * 0.4f;  // 40% of section height\n";
                        cpp << "            float imgX = (winW - imgW) / 2;\n";
                        cpp << "            float imgY = secY + 40;\n";
                        cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH));\n";
                        cpp << "            // Border around image\n";
                        cpp << "            dl->AddRect(ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH), IM_COL32(255, 255, 255, 60), 4.0f, 0, 1.5f);\n";
                        cpp << "        }\n";
                    }
                }

                cpp << "        // Content centered with proper spacing\n";
                cpp << "        float contentY = secY + secH * 0.3f;\n";
                cpp << "        float centerX = winW / 2;\n";
                cpp << "        float maxTextWidth = winW * 0.65f;  // 65% of window width\n";
                cpp << "        if (maxTextWidth > 720) maxTextWidth = 720;  // Cap for readability\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            float h = DrawWrappedTextEx(dl, GetFont(" << (int)sec.title_font_size << "), title, centerX - maxTextWidth/2, contentY, maxTextWidth, " << ColorToU32(sec.title_color) << ", true);\n";
                    cpp << "            contentY += h + 24;\n";
                    cpp << "        }\n";
                }
                if (!sec.subtitle.empty()) {
                    cpp << "        {\n";
                    cpp << "            const char* sub = \"" << EscapeString(sec.subtitle) << "\";\n";
                    cpp << "            float h = DrawWrappedTextEx(dl, GetFont(" << (int)sec.subtitle_font_size << "), sub, centerX - maxTextWidth/2, contentY, maxTextWidth, " << ColorToU32(sec.subtitle_color) << ", true);\n";
                    cpp << "            contentY += h + 40;\n";
                    cpp << "        }\n";
                }
                if (!sec.button_text.empty()) {
                    cpp << "        {\n";
                    cpp << "            ImFont* btnFont = GetFont(" << (int)sec.button_font_size << ");\n";
                    cpp << "            if (btnFont) ImGui::PushFont(btnFont);\n";
                    cpp << "            const char* btnText = \"" << EscapeString(sec.button_text) << "\";\n";
                    cpp << "            ImVec2 btnSize = ImGui::CalcTextSize(btnText);\n";
                    cpp << "            float btnW = btnSize.x + 64, btnH = 52;\n";
                    cpp << "            float btnX = centerX - btnW/2;\n";
                    if (sec.button_glass_effect) {
                        cpp << "            DrawGlassButton(dl, btnText, btnX, contentY, btnW, btnH, " << std::fixed << std::setprecision(2) << sec.button_glass_opacity << "f, " << ColorToU32(sec.button_glass_tint) << ", " << ColorToU32(sec.button_text_color) << ", 12.0f);\n";
                    } else {
                        cpp << "            DrawStyledButton(dl, btnText, btnX, contentY, btnW, btnH, " << ColorToU32(sec.button_bg_color) << ", " << ColorToU32(sec.button_text_color) << ", 10.0f);\n";
                    }
                    cpp << "            if (btnFont) ImGui::PopFont();\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_ABOUT: {
                cpp << "        // About section with text wrapping\n";
                cpp << "        float contentY = secY + 60;\n";
                cpp << "        float centerX = winW / 2;\n";
                cpp << "        float maxTextWidth = winW * 0.75f;\n";
                cpp << "        if (maxTextWidth > 900) maxTextWidth = 900;\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            float h = DrawWrappedTextEx(dl, GetFont(" << (int)sec.title_font_size << "), title, centerX - maxTextWidth/2, contentY, maxTextWidth, " << ColorToU32(sec.title_color) << ", true);\n";
                    cpp << "            contentY += h + 25;\n";
                    cpp << "        }\n";
                }
                if (!sec.content.empty()) {
                    cpp << "        {\n";
                    cpp << "            const char* content = \"" << EscapeString(sec.content) << "\";\n";
                    cpp << "            DrawWrappedTextEx(dl, GetFont(" << (int)sec.content_font_size << "), content, centerX - maxTextWidth/2, contentY, maxTextWidth, " << ColorToU32(sec.content_color) << ", true);\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_CARDS:
            case SEC_SERVICES:
            case SEC_FEATURES:
            case SEC_PRICING:
            case SEC_TEAM: {
                cpp << "        // Modern Cards section with hover effects\n";
                cpp << "        float contentY = secY + 64;\n";
                cpp << "        float centerX = winW / 2;\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            ImFont* titleFont = GetFont(" << (int)sec.title_font_size << ");\n";
                    cpp << "            if (titleFont) ImGui::PushFont(titleFont);\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(title);\n";
                    cpp << "            dl->AddText(ImVec2(centerX - sz.x/2, contentY), " << ColorToU32(sec.title_color) << ", title);\n";
                    cpp << "            if (titleFont) ImGui::PopFont();\n";
                    cpp << "            contentY += sz.y + 48;\n";
                    cpp << "        }\n";
                }
                if (!sec.subtitle.empty()) {
                    cpp << "        {\n";
                    cpp << "            ImFont* subFont = GetFont(" << (int)sec.subtitle_font_size << ");\n";
                    cpp << "            if (subFont) ImGui::PushFont(subFont);\n";
                    cpp << "            const char* sub = \"" << EscapeString(sec.subtitle) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(sub);\n";
                    cpp << "            dl->AddText(ImVec2(centerX - sz.x/2, contentY), " << ColorToU32(sec.subtitle_color) << ", sub);\n";
                    cpp << "            if (subFont) ImGui::PopFont();\n";
                    cpp << "            contentY += sz.y + 40;\n";
                    cpp << "        }\n";
                }

                // Cards with modern styling - responsive
                int cardsPerRow = sec.cards_per_row;
                float cardW = sec.card_width;
                float cardH = sec.card_height;
                float spacing = sec.card_spacing;

                cpp << "        {\n";
                cpp << "            int cardsPerRow = " << cardsPerRow << ";\n";
                cpp << "            float baseCardW = " << std::fixed << std::setprecision(1) << cardW << "f;\n";
                cpp << "            float baseCardH = " << std::fixed << std::setprecision(1) << cardH << "f;\n";
                cpp << "            float spacing = " << std::fixed << std::setprecision(1) << spacing << "f;\n";
                cpp << "            // Responsive card sizing - fit to window width\n";
                cpp << "            float maxContentW = winW * 0.9f;  // 90% of window width\n";
                cpp << "            float maxCardW = (maxContentW - (cardsPerRow - 1) * spacing) / cardsPerRow;\n";
                cpp << "            float cardW = (baseCardW < maxCardW) ? baseCardW : maxCardW;\n";
                cpp << "            float cardH = baseCardH * (cardW / baseCardW);  // Maintain aspect ratio\n";
                cpp << "            float totalW = cardsPerRow * cardW + (cardsPerRow - 1) * spacing;\n";
                cpp << "            float startX = (winW - totalW) / 2;\n";

                for (size_t i = 0; i < sec.items.size(); i++) {
                    const auto& item = sec.items[i];
                    cpp << "            // Card " << i << " with continuous animation\n";
                    cpp << "            {\n";
                    cpp << "                int row = " << i << " / cardsPerRow;\n";
                    cpp << "                int col = " << i << " % cardsPerRow;\n";
                    cpp << "                float cardX = startX + col * (cardW + spacing);\n";
                    cpp << "                float cardY = contentY + row * (cardH + spacing + 16);\n";
                    cpp << "                // Calculate staggered animation progress\n";
                    cpp << "                float animDelay = " << std::fixed << std::setprecision(2) << sec.animation_delay << "f + " << i << " * " << std::fixed << std::setprecision(2) << sec.card_stagger_delay << "f;\n";
                    cpp << "                float animDuration = " << std::fixed << std::setprecision(2) << sec.animation_duration << "f;\n";
                    cpp << "                float animProgress = fmodf((g_AnimTime + animDelay) / animDuration, 1.0f);\n";

                    // Check if using modern card style
                    if (item.card_style == 1) {
                        // Modern service card with animation
                        cpp << "                // Modern Service Card with animation\n";
                        cpp << "                const char* bullets[] = {";
                        for (size_t b = 0; b < item.bullet_points.size() && b < 3; b++) {
                            if (b > 0) cpp << ", ";
                            cpp << "\"" << EscapeString(item.bullet_points[b]) << "\"";
                        }
                        cpp << "};\n";
                        cpp << "                DrawModernServiceCard(dl, cardX, cardY, cardW, cardH, ";
                        cpp << "\"" << EscapeString(item.title) << "\", ";
                        cpp << "\"" << EscapeString(item.description) << "\", ";
                        cpp << "bullets, " << std::min((int)item.bullet_points.size(), 3) << ", ";
                        cpp << ColorToU32(item.icon_color) << ", animProgress);\n";
                    } else {
                        // Old card style (fallback)
                        cpp << "                // Check hover for lift effect\n";
                        cpp << "                bool cardHovered = (io.MousePos.x >= cardX && io.MousePos.x <= cardX + cardW && io.MousePos.y >= cardY && io.MousePos.y <= cardY + cardH);\n";
                        cpp << "                float hoverOffset = cardHovered ? -4.0f : 0.0f;\n";
                        cpp << "                // Card with modern shadow (enhanced on hover)\n";
                        cpp << "                if (cardHovered) {\n";
                        cpp << "                    dl->AddRectFilled(ImVec2(cardX-4, cardY+12), ImVec2(cardX+cardW+4, cardY+cardH+16), IM_COL32(0,0,0,20), 14.0f);\n";
                        cpp << "                }\n";
                        if (item.glass_effect) {
                            cpp << "                DrawGlassCardEnhanced(dl, cardX, cardY + hoverOffset, cardW, cardH, "
                                << std::fixed << std::setprecision(2) << item.glass_opacity << "f, "
                                << ColorToU32(item.glass_tint) << ", "
                                << std::fixed << std::setprecision(1) << item.glass_border_radius << "f, "
                                << std::fixed << std::setprecision(1) << item.glass_border_width << "f, "
                                << ColorToU32(item.glass_border_color) << ", "
                                << (item.glass_highlight ? "true" : "false") << ", "
                                << std::fixed << std::setprecision(2) << item.glass_highlight_opacity << "f);\n";
                        } else {
                            cpp << "                DrawCardWithShadow(dl, cardX, cardY + hoverOffset, cardW, cardH, " << ColorToU32(item.bg_color) << ", 12.0f);\n";
                        }
                        // Render text for old style cards only
                        if (!item.title.empty()) {
                            cpp << "                {\n";
                            cpp << "                    ImFont* cardTitleFont = GetFont(" << (int)item.title_font_size << ");\n";
                            cpp << "                    if (cardTitleFont) ImGui::PushFont(cardTitleFont);\n";
                        cpp << "                    const char* cardTitle = \"" << EscapeString(item.title) << "\";\n";
                        cpp << "                    ImVec2 tsz = ImGui::CalcTextSize(cardTitle);\n";
                        cpp << "                    dl->AddText(ImVec2(cardX + cardW/2 - tsz.x/2, cardY + hoverOffset + 28), " << ColorToU32(item.title_color) << ", cardTitle);\n";
                        cpp << "                    if (cardTitleFont) ImGui::PopFont();\n";
                        cpp << "                }\n";
                        }
                        if (!item.description.empty()) {
                            cpp << "                {\n";
                            cpp << "                    const char* cardDesc = \"" << EscapeString(item.description) << "\";\n";
                            cpp << "                    DrawWrappedTextEx(dl, GetFont(" << (int)item.desc_font_size << "), cardDesc, cardX + 20, cardY + hoverOffset + 64, cardW - 40, " << ColorToU32(item.desc_color) << ", true);\n";
                            cpp << "                }\n";
                        }
                        if (!item.price.empty()) {
                            cpp << "                {\n";
                            cpp << "                    ImFont* priceFont = GetFont(" << (int)item.title_font_size << ");\n";
                            cpp << "                    if (priceFont) ImGui::PushFont(priceFont);\n";
                            cpp << "                    const char* price = \"" << EscapeString(item.price) << "\";\n";
                            cpp << "                    ImVec2 psz = ImGui::CalcTextSize(price);\n";
                            cpp << "                    dl->AddText(ImVec2(cardX + cardW/2 - psz.x/2, cardY + hoverOffset + cardH - 48), " << ColorToU32(item.title_color) << ", price);\n";
                            cpp << "                    if (priceFont) ImGui::PopFont();\n";
                            cpp << "                }\n";
                        }
                    }  // End of old style cards
                    cpp << "            }\n";
                }
                cpp << "        }\n";
                break;
            }

            case SEC_GALLERY: {
                cpp << "        // Gallery section with grid of images\n";
                cpp << "        float contentY = secY + 64;\n";
                cpp << "        float centerX = winW / 2;\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            ImFont* titleFont = GetFont(" << (int)sec.title_font_size << ");\n";
                    cpp << "            if (titleFont) ImGui::PushFont(titleFont);\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(title);\n";
                    cpp << "            dl->AddText(ImVec2(centerX - sz.x/2, contentY), " << ColorToU32(sec.title_color) << ", title);\n";
                    cpp << "            if (titleFont) ImGui::PopFont();\n";
                    cpp << "            contentY += sz.y + 48;\n";
                    cpp << "        }\n";
                }
                if (!sec.subtitle.empty()) {
                    cpp << "        {\n";
                    cpp << "            ImFont* subFont = GetFont(" << (int)sec.subtitle_font_size << ");\n";
                    cpp << "            if (subFont) ImGui::PushFont(subFont);\n";
                    cpp << "            const char* sub = \"" << EscapeString(sec.subtitle) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(sub);\n";
                    cpp << "            dl->AddText(ImVec2(centerX - sz.x/2, contentY), " << ColorToU32(sec.subtitle_color) << ", sub);\n";
                    cpp << "            if (subFont) ImGui::PopFont();\n";
                    cpp << "            contentY += sz.y + 40;\n";
                    cpp << "        }\n";
                }

                // Render gallery images in a grid
                if (!sec.gallery_images.empty()) {
                    int columns = sec.gallery_columns > 0 ? sec.gallery_columns : 3;
                    float imgSpacing = sec.gallery_spacing;
                    float maxImgW = 400.0f; // Base image width

                    cpp << "        {\n";
                    cpp << "            int columns = " << columns << ";\n";
                    cpp << "            float imgSpacing = " << std::fixed << std::setprecision(1) << imgSpacing << "f;\n";
                    cpp << "            float maxImgW = 400.0f;\n";
                    cpp << "            float maxContentW = winW * 0.9f;\n";
                    cpp << "            float maxImgWidth = (maxContentW - (columns - 1) * imgSpacing) / columns;\n";
                    cpp << "            float imgW = (maxImgW < maxImgWidth) ? maxImgW : maxImgWidth;\n";
                    cpp << "            float imgH = imgW * 1.0f;  // Square images\n";
                    cpp << "            float totalW = columns * imgW + (columns - 1) * imgSpacing;\n";
                    cpp << "            float startX = (winW - totalW) / 2;\n";

                    for (size_t i = 0; i < sec.gallery_images.size(); i++) {
                        const auto& galleryImg = sec.gallery_images[i];
                        if (galleryImg.empty()) continue;

                        // Check if this image has a texture variable name
                        auto it = imageVarNames.find(galleryImg);
                        if (it != imageVarNames.end()) {
                            cpp << "            // Gallery image " << i << "\n";
                            cpp << "            {\n";
                            cpp << "                int row = " << i << " / columns;\n";
                            cpp << "                int col = " << i << " % columns;\n";
                            cpp << "                float imgX = startX + col * (imgW + imgSpacing);\n";
                            cpp << "                float imgY = contentY + row * (imgH + imgSpacing);\n";
                            cpp << "                if (" << it->second << " != 0) {\n";
                            cpp << "                    dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH));\n";
                            cpp << "                }\n";
                            cpp << "            }\n";
                        }
                    }

                    cpp << "        }\n";
                }
                break;
            }

            case SEC_STATS: {
                cpp << "        // Modern Stats section with clean typography\n";
                cpp << "        int numStats = " << sec.items.size() << ";\n";
                cpp << "        float maxStatW = 200.0f;\n";
                cpp << "        float totalStatsW = numStats * maxStatW;\n";
                cpp << "        float startX = (winW - totalStatsW) / 2;\n";
                cpp << "        if (startX < 40) startX = 40;\n";
                for (size_t i = 0; i < sec.items.size(); i++) {
                    const auto& item = sec.items[i];
                    cpp << "        {\n";
                    cpp << "            float statX = startX + " << i << " * (winW - startX * 2) / numStats + (winW - startX * 2) / numStats / 2;\n";
                    cpp << "            // Stat number (big, bold)\n";
                    cpp << "            ImFont* numFont = GetFont(" << (int)item.title_font_size << ");\n";
                    cpp << "            if (numFont) ImGui::PushFont(numFont);\n";
                    cpp << "            const char* num = \"" << EscapeString(item.title) << "\";\n";
                    cpp << "            ImVec2 nsz = ImGui::CalcTextSize(num);\n";
                    cpp << "            dl->AddText(ImVec2(statX - nsz.x/2, secY + secH/2 - 28), " << ColorToU32(item.title_color) << ", num);\n";
                    cpp << "            if (numFont) ImGui::PopFont();\n";
                    cpp << "            // Stat label (smaller, muted)\n";
                    cpp << "            ImFont* labelFont = GetFont(" << (int)item.desc_font_size << ");\n";
                    cpp << "            if (labelFont) ImGui::PushFont(labelFont);\n";
                    cpp << "            const char* label = \"" << EscapeString(item.description) << "\";\n";
                    cpp << "            ImVec2 lsz = ImGui::CalcTextSize(label);\n";
                    cpp << "            dl->AddText(ImVec2(statX - lsz.x/2, secY + secH/2 + 12), " << ColorToU32(item.desc_color) << ", label);\n";
                    cpp << "            if (labelFont) ImGui::PopFont();\n";
                    // Add vertical separator between stats (except last)
                    if (i < sec.items.size() - 1) {
                        cpp << "            // Separator line\n";
                        cpp << "            float sepX = startX + (" << i + 1 << ") * (winW - startX * 2) / numStats;\n";
                        cpp << "            dl->AddRectFilled(ImVec2(sepX - 0.5f, secY + secH/2 - 30), ImVec2(sepX + 0.5f, secY + secH/2 + 30), IM_COL32(200, 200, 210, 60));\n";
                    }
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_CONTACT: {
                // Add clipping to prevent contact form overlap during scrolling
                cpp << "        // Clip contact section to prevent overlap\n";
                cpp << "        dl->PushClipRect(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), true);\n";

                // Check if using split layout with image
                bool hasSplitImage = (sec.layout_style == 1 && !sec.section_image.empty());

                if (hasSplitImage) {
                    // SPLIT LAYOUT: Image on left, form on right
                    cpp << "        // Contact form - Split layout with image\n";
                    cpp << "        float sectionW = winW * " << (sec.section_width_percent / 100.0f) << "f;\n";
                    cpp << "        float leftPanelW = sectionW * 0.35f;\n";
                    cpp << "        float formW = sectionW * 0.4f;\n";
                    cpp << "        float leftX = (winW - sectionW) / 2 + sectionW * 0.1f;\n";
                    cpp << "        float rightX = leftX + leftPanelW + (sectionW * 0.1f);\n";
                    cpp << "        float panelH = " << sec.height * 0.6f << ";\n";
                    cpp << "        float panelY = secY + " << sec.padding_top << ";\n";

                    // Render image on left
                    auto it = imageVarNames.find(sec.section_image);
                    if (it != imageVarNames.end()) {
                        cpp << "        // Left panel - Contact image\n";
                        cpp << "        if (" << it->second << " != 0) {\n";
                        cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(leftX, panelY), ImVec2(leftX + leftPanelW, panelY + panelH));\n";
                        cpp << "            dl->AddRect(ImVec2(leftX, panelY), ImVec2(leftX + leftPanelW, panelY + panelH), IM_COL32(200, 200, 200, 100), 4.0f, 0, 1.5f);\n";
                        cpp << "        }\n";
                    }

                    // Form on right
                    cpp << "        // Right panel - Contact form\n";
                    cpp << "        DrawCardWithShadow(dl, rightX - 10, panelY, formW + 20, panelH, IM_COL32(255,255,255,255), 8.0f);\n";
                    cpp << "        float formY = panelY + 30;\n";
                } else {
                    // DEFAULT CENTERED LAYOUT
                    cpp << "        // Modern Contact form with card styling\n";
                    cpp << "        float formW = 420;\n";
                    cpp << "        float formX = (secX + secW - formW) / 2;\n";
                    cpp << "        float formY = secY + 100;\n";
                    cpp << "        float maxTextWidth = secW * 0.7f;\n";
                    cpp << "        if (maxTextWidth > 600) maxTextWidth = 600;\n";
                    if (!sec.title.empty()) {
                        cpp << "        {\n";
                        cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                        cpp << "            DrawWrappedTextEx(dl, GetFont(" << (int)sec.title_font_size << "), title, winW/2 - maxTextWidth/2, secY + 40, maxTextWidth, " << ColorToU32(sec.title_color) << ", true);\n";
                        cpp << "        }\n";
                    }
                    if (!sec.subtitle.empty()) {
                        cpp << "        {\n";
                        cpp << "            const char* sub = \"" << EscapeString(sec.subtitle) << "\";\n";
                        cpp << "            DrawWrappedTextEx(dl, GetFont(" << (int)sec.subtitle_font_size << "), sub, winW/2 - maxTextWidth/2, secY + 75, maxTextWidth, " << ColorToU32(sec.subtitle_color) << ", true);\n";
                        cpp << "        }\n";
                    }
                    cpp << "        // Form card background\n";
                    cpp << "        DrawCardWithShadow(dl, formX - 24, formY - 16, formW + 48, 290, IM_COL32(255,255,255,255), 12.0f);\n";
                }

                // Only reassign formX if using split layout
                if (hasSplitImage) {
                    cpp << "        formX = rightX;\n";
                }

                cpp << "        if (!g_MessageSent) {\n";
                cpp << "            // Input styling\n";
                cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 6.0f);\n";
                cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 10));\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.96f, 0.97f, 0.98f, 1.0f));\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImVec4(0.94f, 0.95f, 0.97f, 1.0f));\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(formX, formY));\n";
                cpp << "            ImGui::SetNextItemWidth(formW);\n";
                cpp << "            ImGui::InputTextWithHint(\"##name\", \"Your Name\", g_ContactName, sizeof(g_ContactName));\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(formX, formY + 52));\n";
                cpp << "            ImGui::SetNextItemWidth(formW);\n";
                cpp << "            ImGui::InputTextWithHint(\"##email\", \"Your Email\", g_ContactEmail, sizeof(g_ContactEmail));\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(formX, formY + 104));\n";
                cpp << "            ImGui::SetNextItemWidth(formW);\n";
                cpp << "            ImGui::InputTextMultiline(\"##msg\", g_ContactMessage, sizeof(g_ContactMessage), ImVec2(formW, 90));\n";
                cpp << "            ImGui::PopStyleColor(2);\n";
                cpp << "            ImGui::PopStyleVar(2);\n";
                cpp << "            // Submit button\n";
                if (sec.button_glass_effect) {
                    cpp << "            {\n";
                    cpp << "                float btnX = formX, btnY = formY + 210, btnW = formW, btnH = 46;\n";
                    cpp << "                DrawGlassButton(dl, \"" << EscapeString(sec.button_text) << "\", btnX, btnY, btnW, btnH, " << std::fixed << std::setprecision(2) << sec.button_glass_opacity << "f, " << ColorToU32(sec.button_glass_tint) << ", " << ColorToU32(sec.button_text_color) << ", 8.0f);\n";
                    cpp << "                ImVec2 mp = ImGui::GetMousePos();\n";
                    cpp << "                if (mp.x >= btnX && mp.x <= btnX + btnW && mp.y >= btnY && mp.y <= btnY + btnH && ImGui::IsMouseClicked(0)) {\n";
                    cpp << "                    if (strlen(g_ContactName) > 0 && strlen(g_ContactEmail) > 0) g_MessageSent = true;\n";
                    cpp << "                }\n";
                    cpp << "            }\n";
                } else {
                    cpp << "            ImGui::SetCursorPos(ImVec2(formX, formY + 210));\n";
                    cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 8.0f);\n";
                    cpp << "            ImGui::PushStyleColor(ImGuiCol_Button, " << ColorToImVec4(sec.button_bg_color) << ");\n";
                    cpp << "            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(" << sec.button_bg_color.x + 0.1f << "f, " << sec.button_bg_color.y + 0.1f << "f, " << sec.button_bg_color.z + 0.1f << "f, 1.0f));\n";
                    cpp << "            if (ImGui::Button(\"" << EscapeString(sec.button_text) << "\", ImVec2(formW, 46))) {\n";
                    cpp << "                if (strlen(g_ContactName) > 0 && strlen(g_ContactEmail) > 0) g_MessageSent = true;\n";
                    cpp << "            }\n";
                    cpp << "            ImGui::PopStyleColor(2);\n";
                    cpp << "            ImGui::PopStyleVar();\n";
                }
                cpp << "        } else {\n";
                cpp << "            // Success message\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(formX, formY + 80));\n";
                cpp << "            ImGui::TextColored(ImVec4(0.2f, 0.75f, 0.4f, 1), \"Thank you! Your message has been sent.\");\n";
                cpp << "        }\n";
                cpp << "        // Remove clipping for contact section\n";
                cpp << "        dl->PopClipRect();\n";
                break;
            }

            case SEC_FOOTER: {
                cpp << "        // Modern Footer with clean layout\n";
                cpp << "        float centerX = winW / 2;\n";
                cpp << "        float maxTextWidth = winW * 0.85f;\n";
                cpp << "        if (maxTextWidth > 1000) maxTextWidth = 1000;\n";
                cpp << "        // Top border separator\n";
                cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + 1), IM_COL32(200, 200, 205, 80));\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            // Footer brand/title\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            DrawWrappedTextEx(dl, GetFont(" << (int)sec.title_font_size << "), title, centerX - maxTextWidth/2, secY + 32, maxTextWidth, " << ColorToU32(sec.title_color) << ", true);\n";
                    cpp << "        }\n";
                }
                if (!sec.subtitle.empty()) {
                    cpp << "        {\n";
                    cpp << "            // Footer tagline\n";
                    cpp << "            const char* tagline = \"" << EscapeString(sec.subtitle) << "\";\n";
                    cpp << "            DrawWrappedTextEx(dl, GetFont(" << (int)sec.subtitle_font_size << "), tagline, centerX - maxTextWidth/2, secY + 70, maxTextWidth, " << ColorToU32(sec.subtitle_color) << ", true);\n";
                    cpp << "        }\n";
                }
                if (!sec.content.empty()) {
                    cpp << "        {\n";
                    cpp << "            // Copyright text at bottom\n";
                    cpp << "            const char* copy = \"" << EscapeString(sec.content) << "\";\n";
                    cpp << "            ImFont* copyFont = GetFont(" << (int)sec.content_font_size << ");\n";
                    cpp << "            if (copyFont) ImGui::PushFont(copyFont);\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(copy);\n";
                    cpp << "            dl->AddText(ImVec2(centerX - sz.x/2, secY + secH - 40), " << ColorToU32(sec.content_color) << ", copy);\n";
                    cpp << "            if (copyFont) ImGui::PopFont();\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_IMAGE: {
                cpp << "        // Image Section - Display uploaded image\n";

                // Check if section has an image
                if (!sec.section_image.empty() && sec.section_image != "none") {
                    auto it = imageVarNames.find(sec.section_image);
                    if (it != imageVarNames.end()) {
                        cpp << "        if (" << it->second << " != 0) {\n";
                        cpp << "            // Render image filling the section\n";
                        cpp << "            dl->AddImage((ImTextureID)(intptr_t)" << it->second << ", ImVec2(secX, secY), ImVec2(secX + secW, secY + secH));\n";
                        cpp << "        } else {\n";
                        cpp << "            // Placeholder if image failed to load\n";
                        cpp << "            dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), IM_COL32(30, 30, 30, 255));\n";
                        cpp << "            const char* text = \"Image Loading...\";\n";
                        cpp << "            ImVec2 sz = ImGui::CalcTextSize(text);\n";
                        cpp << "            dl->AddText(ImVec2(secX + secW/2 - sz.x/2, secY + secH/2), IM_COL32(150, 150, 150, 255), text);\n";
                        cpp << "        }\n";
                    } else {
                        cpp << "        // No image in cache\n";
                        cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), IM_COL32(30, 30, 30, 255));\n";
                    }
                } else {
                    cpp << "        // No image uploaded\n";
                    cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), IM_COL32(30, 30, 30, 255));\n";
                    cpp << "        const char* text = \"Upload Image\";\n";
                    cpp << "        ImVec2 sz = ImGui::CalcTextSize(text);\n";
                    cpp << "        dl->AddText(ImVec2(secX + secW/2 - sz.x/2, secY + secH/2), IM_COL32(150, 150, 150, 255), text);\n";
                }
                break;
            }

            // ==================== BASIC ELEMENTS (Free Design Mode) ====================
            case SEC_LOGO: {
                cpp << "        // Logo Element\n";
                cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), " << ColorToU32(sec.bg_color) << ", 6.0f);\n";
                cpp << "        {\n";
                cpp << "            const char* logoText = \"" << EscapeString(sec.title) << "\";\n";
                cpp << "            ImFont* logoFont = GetFont(24);\n";
                cpp << "            if (logoFont) ImGui::PushFont(logoFont);\n";
                cpp << "            ImVec2 sz = ImGui::CalcTextSize(logoText);\n";
                cpp << "            dl->AddText(ImVec2(secX + secW/2 - sz.x/2, secY + secH/2 - sz.y/2), " << ColorToU32(sec.text_color) << ", logoText);\n";
                cpp << "            if (logoFont) ImGui::PopFont();\n";
                cpp << "        }\n";
                break;
            }

            case SEC_HEADING: {
                cpp << "        // Heading Element\n";
                if (sec.bg_color.w > 0.01f) {
                    cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), " << ColorToU32(sec.bg_color) << ");\n";
                }
                cpp << "        {\n";
                cpp << "            const char* headingText = \"" << EscapeString(sec.title) << "\";\n";
                cpp << "            ImFont* headingFont = GetFont(" << (int)sec.title_font_size << ");\n";
                cpp << "            if (headingFont) ImGui::PushFont(headingFont);\n";
                cpp << "            ImVec2 sz = ImGui::CalcTextSize(headingText);\n";
                cpp << "            dl->AddText(ImVec2(20, secY + secH/2 - sz.y/2), " << ColorToU32(sec.title_color) << ", headingText);\n";
                cpp << "            if (headingFont) ImGui::PopFont();\n";
                cpp << "        }\n";
                break;
            }

            case SEC_TEXT_ELEMENT: {
                cpp << "        // Text Element\n";
                if (sec.bg_color.w > 0.01f) {
                    cpp << "        dl->AddRectFilled(ImVec2(secX, secY), ImVec2(secX + secW, secY + secH), " << ColorToU32(sec.bg_color) << ");\n";
                }
                cpp << "        {\n";
                cpp << "            const char* textContent = \"" << EscapeString(sec.content) << "\";\n";
                cpp << "            ImFont* textFont = GetFont(" << (int)sec.content_font_size << ");\n";
                cpp << "            if (textFont) ImGui::PushFont(textFont);\n";
                cpp << "            ImVec2 sz = ImGui::CalcTextSize(textContent);\n";
                cpp << "            dl->AddText(ImVec2(20, secY + secH/2 - sz.y/2), " << ColorToU32(sec.content_color) << ", textContent);\n";
                cpp << "            if (textFont) ImGui::PopFont();\n";
                cpp << "        }\n";
                break;
            }

            case SEC_BUTTON_ELEMENT: {
                cpp << "        // Button Element (Clickable)\n";
                float radius = sec.button_border_radius > 0 ? sec.button_border_radius : 6.0f;
                cpp << "        {\n";
                cpp << "            const char* btnText = \"" << EscapeString(sec.button_text) << "\";\n";
                cpp << "            ImFont* btnFont = GetFont(" << (int)sec.button_font_size << ");\n";
                cpp << "            if (btnFont) ImGui::PushFont(btnFont);\n";
                cpp << "            ImVec2 sz = ImGui::CalcTextSize(btnText);\n";
                cpp << "            float btnX = 0, btnY = secY, btnW = winW, btnH = secH;\n";
                cpp << "            // Check hover\n";
                cpp << "            bool hovered = (io.MousePos.x >= btnX && io.MousePos.x <= btnX + btnW && io.MousePos.y >= btnY && io.MousePos.y <= btnY + btnH);\n";
                cpp << "            ImU32 bgCol = hovered ? " << ColorToU32(ImVec4(sec.button_bg_color.x * 1.1f, sec.button_bg_color.y * 1.1f, sec.button_bg_color.z * 1.1f, sec.button_bg_color.w)) << " : " << ColorToU32(sec.button_bg_color) << ";\n";
                cpp << "            dl->AddRectFilled(ImVec2(btnX, btnY), ImVec2(btnX + btnW, btnY + btnH), bgCol, " << radius << "f);\n";
                cpp << "            dl->AddText(ImVec2(btnX + btnW/2 - sz.x/2, btnY + btnH/2 - sz.y/2), " << ColorToU32(sec.button_text_color) << ", btnText);\n";
                if (!sec.button_link.empty()) {
                    cpp << "            // Handle click\n";
                    cpp << "            if (hovered && ImGui::IsMouseClicked(0)) {\n";
                    cpp << "                #ifdef __EMSCRIPTEN__\n";
                    cpp << "                EM_ASM({ window.open(UTF8ToString($0), '_blank'); }, \"" << EscapeString(sec.button_link) << "\");\n";
                    cpp << "                #endif\n";
                    cpp << "            }\n";
                }
                cpp << "            if (btnFont) ImGui::PopFont();\n";
                cpp << "        }\n";
                break;
            }

            case SEC_NAVBAR_CONNECTOR: {
                cpp << "        // Advanced Navbar Connector with dropdowns and navigation\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.navbar_bg_color) << ");\n";
                cpp << "        // Bottom border/shadow for navbar\n";
                cpp << "        dl->AddLine(ImVec2(0, secY + secH - 1), ImVec2(winW, secY + secH - 1), IM_COL32(200, 200, 200, 100), 1.0f);\n";
                cpp << "        static int navActiveMenu = -1;\n";
                cpp << "        static float menuRects[16][4]; // x, y, w, h for up to 16 menu items\n";
                cpp << "        float menuX = " << std::fixed << std::setprecision(1) << sec.navbar_padding_x << "f;\n";
                cpp << "        float menuY = secY + " << std::fixed << std::setprecision(1) << sec.navbar_padding_y << "f;\n";
                cpp << "        float fontSize = 18.0f * " << std::fixed << std::setprecision(2) << sec.navbar_font_scale << "f;\n";
                cpp << "        bool parentHovered = false;\n";
                cpp << "        int hoveredParent = -1;\n";
                cpp << "        ImFont* nf = GetFont((int)fontSize);\n";
                cpp << "        if (nf) ImGui::PushFont(nf);\n";

                // Generate menu items with rect tracking
                for (int i = 0; i < (int)sec.navbar_items.size(); i++) {
                    const NavbarMenuItem& item = sec.navbar_items[i];
                    cpp << "        {\n";
                    cpp << "            const char* label = \"" << EscapeString(item.label) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(label);\n";
                    cpp << "            float btnW = sz.x + 20.0f;\n";
                    cpp << "            float btnH = sz.y + 10.0f;\n";
                    cpp << "            menuRects[" << i << "][0] = menuX; menuRects[" << i << "][1] = menuY;\n";
                    cpp << "            menuRects[" << i << "][2] = btnW; menuRects[" << i << "][3] = btnH;\n";
                    cpp << "            ImVec2 btnMin(menuX, menuY);\n";
                    cpp << "            ImVec2 btnMax(menuX + btnW, menuY + btnH);\n";
                    cpp << "            bool hovered = (io.MousePos.x >= btnMin.x && io.MousePos.x <= btnMax.x && io.MousePos.y >= btnMin.y && io.MousePos.y <= btnMax.y);\n";
                    cpp << "            if (hovered) { parentHovered = true; hoveredParent = " << i << "; }\n";
                    float rounding = sec.navbar_rounded ? sec.navbar_rounding : 0.0f;
                    cpp << "            if (hovered || navActiveMenu == " << i << ") {\n";
                    cpp << "                dl->AddRectFilled(btnMin, btnMax, " << ColorToU32(sec.navbar_hover_color) << ", " << std::fixed << std::setprecision(1) << rounding << "f);\n";
                    cpp << "            }\n";
                    cpp << "            dl->AddText(ImVec2(menuX + 10.0f, menuY + 5.0f), " << ColorToU32(sec.navbar_text_color) << ", label);\n";

                    // Handle click for page navigation (only if no children or clicking main item)
                    if (item.actionType == ACTION_LINK_TO_PAGE && strlen(item.actionTarget) > 0) {
                        cpp << "            if (hovered && ImGui::IsMouseClicked(0)) {\n";
                        cpp << "                NavigateToPage(\"" << EscapeString(item.actionTarget) << "\");\n";
                        cpp << "            }\n";
                    }

                    cpp << "            menuX += btnW + " << std::fixed << std::setprecision(1) << sec.navbar_spacing << "f;\n";
                    cpp << "        }\n";
                }

                // Open dropdown on hover if item has children
                cpp << "        if (parentHovered && hoveredParent >= 0) {\n";
                for (int i = 0; i < (int)sec.navbar_items.size(); i++) {
                    if (!sec.navbar_items[i].children.empty()) {
                        cpp << "            if (hoveredParent == " << i << ") navActiveMenu = " << i << ";\n";
                    }
                }
                cpp << "        }\n";

                // Render dropdowns using foreground draw list so they appear on top of everything
                cpp << "        bool dropdownHovered = false;\n";
                cpp << "        ImDrawList* fgDl = ImGui::GetForegroundDrawList();\n";
                for (int i = 0; i < (int)sec.navbar_items.size(); i++) {
                    const NavbarMenuItem& item = sec.navbar_items[i];
                    if (!item.children.empty()) {
                        cpp << "        if (navActiveMenu == " << i << ") {\n";
                        cpp << "            float dropX = menuRects[" << i << "][0];\n";
                        cpp << "            float dropY = menuRects[" << i << "][1] + menuRects[" << i << "][3] + 2.0f;\n";
                        cpp << "            float dropW = 200.0f;\n";
                        cpp << "            float dropH = " << (item.children.size() * 28 + 16) << ".0f;\n";
                        cpp << "            fgDl->AddRectFilled(ImVec2(dropX, dropY), ImVec2(dropX + dropW, dropY + dropH), " << ColorToU32(sec.navbar_dropdown_color) << ", 4.0f);\n";
                        cpp << "            fgDl->AddRect(ImVec2(dropX, dropY), ImVec2(dropX + dropW, dropY + dropH), IM_COL32(200,200,200,100), 4.0f);\n";
                        cpp << "            float itemY = dropY + 8.0f;\n";
                        for (size_t ci = 0; ci < item.children.size(); ci++) {
                            cpp << "            {\n";
                            cpp << "                const char* childLabel = \"" << EscapeString(item.children[ci]) << "\";\n";
                            cpp << "                ImVec2 itemMin(dropX + 4, itemY);\n";
                            cpp << "                ImVec2 itemMax(dropX + dropW - 4, itemY + 24.0f);\n";
                            cpp << "                bool itemHov = (io.MousePos.x >= itemMin.x && io.MousePos.x <= itemMax.x && io.MousePos.y >= itemMin.y && io.MousePos.y <= itemMax.y);\n";
                            cpp << "                if (itemHov) { dropdownHovered = true; fgDl->AddRectFilled(itemMin, itemMax, " << ColorToU32(sec.navbar_hover_color) << ", 3.0f); }\n";
                            cpp << "                fgDl->AddText(ImVec2(dropX + 12.0f, itemY + 4.0f), " << ColorToU32(sec.navbar_text_color) << ", childLabel);\n";
                            cpp << "                itemY += 28.0f;\n";
                            cpp << "            }\n";
                        }
                        cpp << "            if (io.MousePos.x >= dropX && io.MousePos.x <= dropX + dropW && io.MousePos.y >= dropY && io.MousePos.y <= dropY + dropH) dropdownHovered = true;\n";
                        cpp << "        }\n";
                    }
                }

                cpp << "        if (!parentHovered && !dropdownHovered) navActiveMenu = -1;\n";
                cpp << "        if (nf) ImGui::PopFont();\n";
                cpp << "        if (parentHovered || dropdownHovered) ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);\n";
                break;
            }

            case SEC_COPYRIGHT_CONNECTOR: {
                cpp << "        // Copyright Connector\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(ImVec4(sec.copyright_bg_color.x, sec.copyright_bg_color.y, sec.copyright_bg_color.z, sec.copyright_bg_opacity)) << ");\n";
                if (strlen(sec.copyright_text) > 0) {
                    cpp << "        {\n";
                    cpp << "            ImFont* cf = GetFont(" << (int)sec.copyright_font_size << ");\n";
                    cpp << "            if (cf) ImGui::PushFont(cf);\n";
                    cpp << "            const char* txt = \"" << EscapeString(sec.copyright_text) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(txt);\n";
                    cpp << "            dl->AddText(ImVec2(" << std::fixed << std::setprecision(1) << sec.copyright_padding << "f, secY + " << sec.copyright_padding << "f), " << ColorToU32(sec.copyright_text_color) << ", txt);\n";
                    cpp << "            if (cf) ImGui::PopFont();\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_BAR_CONNECTOR: {
                cpp << "        // Bar Connector (heading bar)\n";
                if (!sec.bar_items.empty()) {
                    const BarItem& bar = sec.bar_items[0];
                    cpp << "        {\n";
                    cpp << "            float barW = " << std::fixed << std::setprecision(1) << bar.barWidth << "f;\n";
                    cpp << "            float barH = " << std::fixed << std::setprecision(1) << bar.barHeight << "f;\n";
                    cpp << "            float barX = (winW - barW) / 2;\n";
                    cpp << "            dl->AddRectFilled(ImVec2(barX, secY), ImVec2(barX + barW, secY + barH), " << ColorToU32(bar.barColor) << ");\n";
                    cpp << "            ImFont* bf = GetFont(" << (int)(bar.headingSize * 18.0f) << ");\n";
                    cpp << "            if (bf) ImGui::PushFont(bf);\n";
                    cpp << "            const char* heading = \"" << EscapeString(bar.heading) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(heading);\n";
                    cpp << "            dl->AddText(ImVec2(barX + " << std::fixed << std::setprecision(1) << bar.paddingLeft << "f, secY + (barH - sz.y) / 2), " << ColorToU32(bar.headingColor) << ", heading);\n";
                    cpp << "            if (bf) ImGui::PopFont();\n";
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_FOOTER_CONNECTOR: {
                cpp << "        // Footer Connector with columns\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                if (!sec.footer_columns.empty()) {
                    float colW = sec.footer_column_width;
                    float totalW = colW * sec.footer_columns.size();
                    cpp << "        float startX = (winW - " << std::fixed << std::setprecision(1) << totalW << "f) / 2;\n";
                    cpp << "        float colY = secY + 30.0f;\n";
                    for (size_t ci = 0; ci < sec.footer_columns.size(); ci++) {
                        const FooterColumn& col = sec.footer_columns[ci];
                        cpp << "        {\n";
                        cpp << "            float colX" << ci << " = startX + " << std::fixed << std::setprecision(1) << (ci * colW) << "f;\n";
                        cpp << "            ImFont* hf" << ci << " = GetFont(" << (int)(sec.footer_heading_size * 18.0f) << ");\n";
                        cpp << "            if (hf" << ci << ") ImGui::PushFont(hf" << ci << ");\n";
                        cpp << "            dl->AddText(ImVec2(colX" << ci << ", colY), " << ColorToU32(sec.footer_heading_color) << ", \"" << EscapeString(col.heading) << "\");\n";
                        cpp << "            if (hf" << ci << ") ImGui::PopFont();\n";
                        cpp << "            ImFont* sf" << ci << " = GetFont(" << (int)(sec.footer_subheading_size * 18.0f) << ");\n";
                        cpp << "            if (sf" << ci << ") ImGui::PushFont(sf" << ci << ");\n";
                        cpp << "            float itemY" << ci << " = colY + 30.0f;\n";
                        for (const auto& item : col.items) {
                            cpp << "            dl->AddText(ImVec2(colX" << ci << ", itemY" << ci << "), " << ColorToU32(sec.footer_subheading_color) << ", \"" << EscapeString(item) << "\");\n";
                            cpp << "            itemY" << ci << " += " << std::fixed << std::setprecision(1) << sec.footer_item_spacing << "f + 18.0f;\n";
                        }
                        cpp << "            if (sf" << ci << ") ImGui::PopFont();\n";
                        cpp << "        }\n";
                    }
                }
                break;
            }

            case SEC_CARD_CONNECTOR: {
                cpp << "        // Thumbnail Cards (Service Cards)\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                if (!sec.connector_cards.empty()) {
                    int cardsPerRow = sec.connector_cards_per_row > 0 ? sec.connector_cards_per_row : 3;
                    float spacing = sec.connector_card_spacing;
                    cpp << "        {\n";
                    cpp << "            int cardsPerRow = " << cardsPerRow << ";\n";
                    cpp << "            float spacing = " << std::fixed << std::setprecision(1) << spacing << "f;\n";

                    for (size_t ci = 0; ci < sec.connector_cards.size(); ci++) {
                        const ThumbnailCard& card = sec.connector_cards[ci];
                        cpp << "            {\n";
                        cpp << "                float cardW = " << std::fixed << std::setprecision(1) << card.cardWidth << "f;\n";
                        cpp << "                float cardH = " << std::fixed << std::setprecision(1) << card.cardHeight << "f;\n";
                        cpp << "                int col = " << ci << " % cardsPerRow;\n";
                        cpp << "                int row = " << ci << " / cardsPerRow;\n";
                        cpp << "                float totalRowW = cardsPerRow * cardW + (cardsPerRow - 1) * spacing;\n";
                        cpp << "                float startX = (winW - totalRowW) / 2;\n";
                        cpp << "                float cardX = startX + col * (cardW + spacing);\n";
                        cpp << "                float cardY = secY + 10.0f + row * (cardH + spacing);\n";
                        cpp << "                dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH), " << ColorToU32(card.cardColor) << ", 4.0f);\n";
                        if (card.borderThickness > 0) {
                            cpp << "                dl->AddRect(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH), " << ColorToU32(card.borderColor) << ", 4.0f, 0, " << std::fixed << std::setprecision(1) << card.borderThickness << "f);\n";
                        }
                        cpp << "                ImFont* hf" << ci << " = GetFont(" << (int)(card.headingSize * 16.0f) << ");\n";
                        cpp << "                if (hf" << ci << ") ImGui::PushFont(hf" << ci << ");\n";
                        cpp << "                const char* heading" << ci << " = \"" << EscapeString(card.heading) << "\";\n";
                        cpp << "                ImVec2 hsz" << ci << " = ImGui::CalcTextSize(heading" << ci << ");\n";
                        cpp << "                dl->AddText(ImVec2(cardX + (cardW - hsz" << ci << ".x) / 2, cardY + cardH / 2 - hsz" << ci << ".y / 2), " << ColorToU32(card.headingColor) << ", heading" << ci << ");\n";
                        cpp << "                if (hf" << ci << ") ImGui::PopFont();\n";
                        cpp << "            }\n";
                    }
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_TEXT_CONNECTOR: {
                cpp << "        // Text Connector with rich text blocks\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                if (!sec.text_blocks.empty()) {
                    cpp << "        {\n";
                    cpp << "            float textY_tc = secY + " << std::fixed << std::setprecision(1) << sec.text_padding << "f;\n";
                    cpp << "            float contentW_tc = " << std::fixed << std::setprecision(1) << sec.text_content_width << "f;\n";
                    cpp << "            float startX_tc = (winW - contentW_tc) / 2;\n";

                    for (size_t bi = 0; bi < sec.text_blocks.size(); bi++) {
                        const TextBlock& block = sec.text_blocks[bi];
                        cpp << "            {\n";
                        cpp << "                ImFont* tf" << bi << " = GetFont(" << (int)block.fontSize << ");\n";
                        cpp << "                if (tf" << bi << ") ImGui::PushFont(tf" << bi << ");\n";
                        // Render all segments as one wrapped text for simplicity
                        std::string fullText;
                        for (const auto& seg : block.segments) {
                            fullText += seg.text;
                        }
                        cpp << "                DrawWrappedTextEx(dl, tf" << bi << ", \"" << EscapeString(fullText) << "\", startX_tc, textY_tc, contentW_tc, " << ColorToU32(block.textColor) << ", false);\n";
                        cpp << "                textY_tc += " << std::fixed << std::setprecision(1) << (block.lineSpacing * 20.0f) << "f;\n";
                        cpp << "                if (tf" << bi << ") ImGui::PopFont();\n";
                        cpp << "            }\n";
                    }
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_ARTICLE_CONNECTOR: {
                cpp << "        // Article Cards\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                if (!sec.article_cards.empty()) {
                    int cardsPerRow = sec.article_cards_per_row > 0 ? sec.article_cards_per_row : 3;
                    float spacing = sec.article_card_spacing;
                    cpp << "        {\n";
                    for (size_t ci = 0; ci < sec.article_cards.size(); ci++) {
                        const ArticleCard& card = sec.article_cards[ci];
                        cpp << "            {\n";
                        cpp << "                float cardW = " << std::fixed << std::setprecision(1) << card.cardWidth << "f;\n";
                        cpp << "                float cardH = " << std::fixed << std::setprecision(1) << card.cardHeight << "f;\n";
                        cpp << "                int col = " << ci << " % " << cardsPerRow << ";\n";
                        cpp << "                int row = " << ci << " / " << cardsPerRow << ";\n";
                        cpp << "                float totalRowW = " << cardsPerRow << " * cardW + (" << cardsPerRow << " - 1) * " << std::fixed << std::setprecision(1) << spacing << "f;\n";
                        cpp << "                float startX = (winW - totalRowW) / 2;\n";
                        cpp << "                float cardX = startX + col * (cardW + " << std::fixed << std::setprecision(1) << spacing << "f);\n";
                        cpp << "                float cardY = secY + 20.0f + row * (cardH + " << std::fixed << std::setprecision(1) << spacing << "f);\n";
                        cpp << "                dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH), " << ColorToU32(card.cardBgColor) << ", 4.0f);\n";
                        // Orange accent bar on left
                        cpp << "                dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + " << std::fixed << std::setprecision(1) << card.accentWidth << "f, cardY + cardH), " << ColorToU32(card.accentColor) << ");\n";
                        // Heading
                        cpp << "                ImFont* hf" << ci << " = GetFont(" << (int)(card.headingSize * 16.0f) << ");\n";
                        cpp << "                if (hf" << ci << ") ImGui::PushFont(hf" << ci << ");\n";
                        cpp << "                dl->AddText(ImVec2(cardX + " << std::fixed << std::setprecision(1) << card.cardPadding << "f, cardY + 10.0f), " << ColorToU32(card.headingColor) << ", \"" << EscapeString(card.heading) << "\");\n";
                        cpp << "                if (hf" << ci << ") ImGui::PopFont();\n";
                        // Date
                        cpp << "                ImFont* df" << ci << " = GetFont(" << (int)(card.dateSize * 14.0f) << ");\n";
                        cpp << "                if (df" << ci << ") ImGui::PushFont(df" << ci << ");\n";
                        cpp << "                dl->AddText(ImVec2(cardX + " << std::fixed << std::setprecision(1) << card.cardPadding << "f, cardY + 35.0f), " << ColorToU32(card.dateColor) << ", \"" << EscapeString(card.date) << "\");\n";
                        cpp << "                if (df" << ci << ") ImGui::PopFont();\n";
                        cpp << "            }\n";
                    }
                    cpp << "        }\n";
                }
                break;
            }

            case SEC_VERTICAL_CONNECTOR: {
                cpp << "        // Vertical Layout Connector\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                cpp << "        {\n";
                cpp << "            float contentW = " << std::fixed << std::setprecision(1) << sec.vertical_content_width << "f;\n";
                cpp << "            float startX = (winW - contentW) / 2;\n";
                cpp << "            float itemY = secY + 20.0f;\n";
                for (size_t vi = 0; vi < sec.vertical_blocks.size(); vi++) {
                    const VerticalBlock& vb = sec.vertical_blocks[vi];
                    if (vb.type == 0) { // Heading
                        cpp << "            {\n";
                        cpp << "            ImFont* hf" << vi << " = GetFont(" << (int)(sec.vertical_heading_size * 18.0f) << ");\n";
                        cpp << "            if (hf" << vi << ") ImGui::PushFont(hf" << vi << ");\n";
                        cpp << "            dl->AddText(ImVec2(startX, itemY), " << ColorToU32(sec.vertical_heading_color) << ", \"" << EscapeString(vb.text) << "\");\n";
                        cpp << "            itemY += 30.0f;\n";
                        cpp << "            if (hf" << vi << ") ImGui::PopFont();\n";
                        cpp << "            }\n";
                    } else if (vb.type == 1) { // Description
                        cpp << "            {\n";
                        cpp << "            ImFont* df" << vi << " = GetFont(" << (int)(sec.vertical_desc_size * 16.0f) << ");\n";
                        cpp << "            if (df" << vi << ") ImGui::PushFont(df" << vi << ");\n";
                        cpp << "            DrawWrappedTextEx(dl, df" << vi << ", \"" << EscapeString(vb.text) << "\", startX, itemY, contentW, " << ColorToU32(sec.vertical_desc_color) << ", false);\n";
                        cpp << "            itemY += " << std::fixed << std::setprecision(1) << sec.vertical_spacing << "f + 20.0f;\n";
                        cpp << "            if (df" << vi << ") ImGui::PopFont();\n";
                        cpp << "            }\n";
                    }
                }
                cpp << "        }\n";
                break;
            }

            case SEC_CONTACT_FORM_CONNECTOR: {
                cpp << "        // Contact Form Connector - Interactive using Child Window\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";

                float padding = sec.padding_left > 0 ? sec.padding_left : 30.0f;
                float paddingTop = sec.padding_top > 0 ? sec.padding_top : 30.0f;

                // Use a child window for proper input handling
                cpp << "        ImGui::SetCursorPos(ImVec2(0, secY));\n";
                cpp << "        ImGui::BeginChild(\"ContactFormChild\", ImVec2(winW, secH), false, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoBackground);\n";
                cpp << "        {\n";
                cpp << "            ImDrawList* cdl = ImGui::GetWindowDrawList();\n";
                cpp << "            ImVec2 cpos = ImGui::GetCursorScreenPos();\n";
                cpp << "            float formPadding = " << std::fixed << std::setprecision(1) << padding << "f;\n";
                cpp << "            float formWidth = winW - formPadding * 2;\n";
                cpp << "            if (formWidth > 600) formWidth = 600;\n";
                cpp << "            float formStartX = (winW - formWidth) / 2;\n";
                cpp << "            float localY = " << std::fixed << std::setprecision(1) << paddingTop << "f;\n";

                cpp << "            if (!g_FormSubmitted) {\n";
                // Title
                cpp << "                // Title\n";
                cpp << "                ImFont* titleFont = GetFont(" << (int)(24.0f * sec.contact_form_title_size) << ");\n";
                cpp << "                if (titleFont) ImGui::PushFont(titleFont);\n";
                cpp << "                ImGui::SetCursorPos(ImVec2(formStartX, localY));\n";
                cpp << "                ImGui::TextColored(" << ColorToImVec4(sec.contact_form_title_color) << ", \"" << EscapeString(sec.contact_form_title) << "\");\n";
                cpp << "                localY += ImGui::GetItemRectSize().y + " << std::fixed << std::setprecision(1) << sec.contact_form_spacing << "f;\n";
                cpp << "                if (titleFont) ImGui::PopFont();\n";

                // Style for input fields
                cpp << "                // Style input fields\n";
                cpp << "                ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 6.0f);\n";
                cpp << "                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 10));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.96f, 0.97f, 0.98f, 1.0f));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImVec4(0.92f, 0.93f, 0.95f, 1.0f));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImVec4(0.90f, 0.91f, 0.93f, 1.0f));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));\n";

                // Form fields
                cpp << "                float fieldX = formStartX;\n";
                cpp << "                float halfWidth = (formWidth - " << std::fixed << std::setprecision(1) << sec.contact_form_spacing << "f) / 2;\n";
                cpp << "                int fieldInRow = 0;\n";
                cpp << "                float rowStartY = localY;\n";

                for (size_t fi = 0; fi < sec.contact_form_fields.size() && fi < 10; fi++) {
                    const ContactFormField& field = sec.contact_form_fields[fi];
                    bool isFullWidth = field.width >= 1.0f;
                    bool isTextarea = field.fieldType == 3;
                    float fieldHeight = isTextarea ? sec.contact_form_textarea_height : sec.contact_form_input_height;

                    cpp << "                {\n";
                    if (isFullWidth) {
                        cpp << "                    if (fieldInRow > 0) { localY = rowStartY + " << std::fixed << std::setprecision(1) << sec.contact_form_input_height << "f + " << sec.contact_form_spacing << "f; }\n";
                        cpp << "                    fieldX = formStartX; fieldInRow = 0; rowStartY = localY;\n";
                        cpp << "                    float fieldW = formWidth;\n";
                    } else {
                        cpp << "                    if (fieldInRow >= 2) { localY = rowStartY + " << std::fixed << std::setprecision(1) << sec.contact_form_input_height << "f + " << sec.contact_form_spacing << "f; fieldX = formStartX; fieldInRow = 0; rowStartY = localY; }\n";
                        cpp << "                    float fieldW = halfWidth;\n";
                    }
                    cpp << "                    float fieldH = " << std::fixed << std::setprecision(1) << fieldHeight << "f;\n";

                    cpp << "                    ImGui::SetCursorPos(ImVec2(fieldX, localY));\n";
                    cpp << "                    ImGui::SetNextItemWidth(fieldW);\n";

                    if (isTextarea) {
                        cpp << "                    ImGui::InputTextMultiline(\"##formfield" << fi << "\", g_FormField" << fi << ", sizeof(g_FormField" << fi << "), ImVec2(fieldW, fieldH));\n";
                    } else {
                        cpp << "                    ImGui::InputTextWithHint(\"##formfield" << fi << "\", \"" << EscapeString(field.placeholder) << "\", g_FormField" << fi << ", sizeof(g_FormField" << fi << "));\n";
                    }

                    if (isFullWidth) {
                        cpp << "                    localY += fieldH + " << std::fixed << std::setprecision(1) << sec.contact_form_spacing << "f;\n";
                    } else {
                        cpp << "                    fieldX += fieldW + " << std::fixed << std::setprecision(1) << sec.contact_form_spacing << "f;\n";
                        cpp << "                    fieldInRow++;\n";
                    }
                    cpp << "                }\n";
                }

                // Finalize row position
                cpp << "                if (fieldInRow > 0) { localY = rowStartY + " << std::fixed << std::setprecision(1) << sec.contact_form_input_height << "f + " << sec.contact_form_spacing << "f; }\n";

                // Pop input styles
                cpp << "                ImGui::PopStyleColor(5);\n";
                cpp << "                ImGui::PopStyleVar(2);\n";

                // Submit button
                cpp << "                // Submit button\n";
                cpp << "                float btnW = " << std::fixed << std::setprecision(1) << sec.contact_form_button_width << "f;\n";
                cpp << "                float btnH = " << std::fixed << std::setprecision(1) << sec.contact_form_button_height << "f;\n";
                cpp << "                float btnX = formStartX + formWidth - btnW;\n";
                cpp << "                float btnY = localY + 10.0f;\n";
                cpp << "                ImGui::SetCursorPos(ImVec2(btnX, btnY));\n";
                cpp << "                ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 4.0f);\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_Button, " << ColorToImVec4(sec.contact_form_button_bg) << ");\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(" << (sec.contact_form_button_bg.x + 0.1f) << "f, " << (sec.contact_form_button_bg.y + 0.1f) << "f, " << (sec.contact_form_button_bg.z + 0.1f) << "f, 1.0f));\n";
                cpp << "                ImGui::PushStyleColor(ImGuiCol_Text, " << ColorToImVec4(sec.contact_form_button_text) << ");\n";
                cpp << "                if (ImGui::Button(\"" << EscapeString(sec.contact_form_submit_text) << "\", ImVec2(btnW, btnH))) {\n";
                cpp << "                    g_FormSubmitted = true;\n";
                cpp << "                }\n";
                cpp << "                ImGui::PopStyleColor(3);\n";
                cpp << "                ImGui::PopStyleVar();\n";
                cpp << "            } else {\n";
                // Show success message
                cpp << "                // Success message\n";
                cpp << "                ImGui::SetCursorPos(ImVec2(0, secH / 2 - 20));\n";
                cpp << "                ImFont* msgFont = GetFont(24);\n";
                cpp << "                if (msgFont) ImGui::PushFont(msgFont);\n";
                cpp << "                float textW = ImGui::CalcTextSize(\"Thank you! Your message has been sent.\").x;\n";
                cpp << "                ImGui::SetCursorPosX((winW - textW) / 2);\n";
                cpp << "                ImGui::TextColored(ImVec4(0.2f, 0.7f, 0.4f, 1.0f), \"Thank you! Your message has been sent.\");\n";
                cpp << "                if (msgFont) ImGui::PopFont();\n";
                cpp << "            }\n";
                cpp << "        }\n";
                cpp << "        ImGui::EndChild();\n";
                break;
            }

            case SEC_SEARCH_CONNECTOR: {
                cpp << "        // Search Bar Connector - Interactive\n";
                cpp << "        dl->AddRectFilled(secMin, secMax, " << ColorToU32(sec.bg_color) << ");\n";
                cpp << "        {\n";
                cpp << "            float totalW = " << std::fixed << std::setprecision(1) << (sec.search_input_width + sec.search_button_width) << "f;\n";
                cpp << "            float startX = (winW - totalW) / 2;\n";
                cpp << "            float centerY = secY + (secH - " << std::fixed << std::setprecision(1) << sec.search_input_height << "f) / 2;\n";
                cpp << "            float inputW = " << std::fixed << std::setprecision(1) << sec.search_input_width << "f;\n";
                cpp << "            float inputH = " << std::fixed << std::setprecision(1) << sec.search_input_height << "f;\n";
                cpp << "            float btnW = " << std::fixed << std::setprecision(1) << sec.search_button_width << "f;\n";
                cpp << "            float radius = " << std::fixed << std::setprecision(1) << sec.search_border_radius << "f;\n";
                cpp << "            // Input field\n";
                cpp << "            dl->AddRectFilled(ImVec2(startX, centerY), ImVec2(startX + inputW, centerY + inputH), " << ColorToU32(sec.search_input_bg) << ", radius);\n";
                cpp << "            dl->AddRect(ImVec2(startX, centerY), ImVec2(startX + inputW, centerY + inputH), " << ColorToU32(sec.search_input_border) << ", radius, 0, 1.0f);\n";
                cpp << "            // Use ImGui input for interactivity\n";
                cpp << "            static char searchQuery[256] = \"\";\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(startX, centerY));\n";
                cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, radius);\n";
                cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(15, (inputH - 16) / 2));\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_FrameBg, " << ColorToImVec4(sec.search_input_bg) << ");\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, " << ColorToImVec4(sec.search_input_bg) << ");\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, " << ColorToImVec4(sec.search_input_bg) << ");\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_Text, " << ColorToImVec4(sec.search_input_text) << ");\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_Border, " << ColorToImVec4(sec.search_input_border) << ");\n";
                cpp << "            ImGui::SetNextItemWidth(inputW);\n";
                cpp << "            ImGui::InputTextWithHint(\"##search\", \"" << EscapeString(sec.search_placeholder) << "\", searchQuery, sizeof(searchQuery));\n";
                cpp << "            ImGui::PopStyleColor(5);\n";
                cpp << "            ImGui::PopStyleVar(2);\n";
                cpp << "            // Search button\n";
                cpp << "            ImGui::SetCursorPos(ImVec2(startX + inputW, centerY));\n";
                cpp << "            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, radius);\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_Button, " << ColorToImVec4(sec.search_button_bg) << ");\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(" << (sec.search_button_bg.x * 0.9f) << "f, " << (sec.search_button_bg.y * 0.9f) << "f, " << (sec.search_button_bg.z * 0.9f) << "f, 1.0f));\n";
                cpp << "            ImGui::PushStyleColor(ImGuiCol_Text, " << ColorToImVec4(sec.search_button_text_color) << ");\n";
                cpp << "            if (ImGui::Button(\"" << EscapeString(sec.search_button_text) << "\", ImVec2(btnW, inputH))) {\n";
                cpp << "                printf(\"Search: %s\\n\", searchQuery);\n";
                cpp << "            }\n";
                cpp << "            ImGui::PopStyleColor(3);\n";
                cpp << "            ImGui::PopStyleVar();\n";
                cpp << "        }\n";
                break;
            }

            default:
                cpp << "        // Custom section\n";
                if (!sec.title.empty()) {
                    cpp << "        {\n";
                    cpp << "            const char* title = \"" << EscapeString(sec.title) << "\";\n";
                    cpp << "            ImVec2 sz = ImGui::CalcTextSize(title);\n";
                    cpp << "            dl->AddText(ImVec2(secX + secW/2 - sz.x/2, secY + secH/2), " << ColorToU32(sec.title_color) << ", title);\n";
                    cpp << "        }\n";
                }
                break;
        }

            cpp << "        yPos += secH;\n";
            cpp << "    }\n\n";
            globalSecIdx++;
        } // End section loop for this page

        // Close the page block
        cpp << "    } // End page " << pageIdx << ": " << currentPage.name << "\n\n";
    } // End page loop

    cpp << R"(
    // Update total height for scrolling
    g_TotalHeight = yPos + g_ScrollY;

    ImGui::End();
}

// Main frame
void MainLoopStep() {
    glfwPollEvents();
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    // Update animation time for continuous card animations
    g_AnimTime += g_DeltaTime;

    // Handle scroll input
    ImGuiIO& io = ImGui::GetIO();

#ifdef __EMSCRIPTEN__
    // Get scroll delta from JavaScript
    float jsDelta = (float)EM_ASM_DOUBLE({
        if (Module.getScrollDelta) {
            return Module.getScrollDelta();
        }
        return 0;
    });
    if (jsDelta != 0) {
        g_ScrollTarget += jsDelta * 0.5f;  // Scale down for smoother scroll
    }
#endif

    // Also check ImGui mouse wheel (for non-Emscripten builds)
    if (io.MouseWheel != 0) {
        g_ScrollTarget -= io.MouseWheel * 80.0f;
    }

    // Smooth scrolling
    g_ScrollY += (g_ScrollTarget - g_ScrollY) * 0.2f;

    // Clamp scroll
    if (g_ScrollY < 0) { g_ScrollY = 0; g_ScrollTarget = 0; }
    float maxScroll = g_TotalHeight - io.DisplaySize.y;
    if (maxScroll < 0) maxScroll = 0;
    if (g_ScrollY > maxScroll) { g_ScrollY = maxScroll; g_ScrollTarget = maxScroll; }

    RenderWebsite();

    ImGui::Render();
    int display_w, display_h;
    glfwGetFramebufferSize(g_Window, &display_w, &display_h);
    glViewport(0, 0, display_w, display_h);
    glClearColor(g_ClearColor.x, g_ClearColor.y, g_ClearColor.z, g_ClearColor.w);
    glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    glfwSwapBuffers(g_Window);
}

int main(int, char**) {
    if (!glfwInit()) {
        printf("Failed to initialize GLFW\n");
        return 1;
    }

    const char* glsl_version = "#version 300 es";
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);
    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);

    g_Window = glfwCreateWindow(1280, 720, ")" << EscapeString(g_ProjectName) << R"(", nullptr, nullptr);
    if (!g_Window) {
        printf("Failed to create window\n");
        glfwTerminate();
        return 1;
    }

    glfwMakeContextCurrent(g_Window);
    glfwSwapInterval(1);

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    io.ConfigInputTextCursorBlink = true;  // Enable cursor blink
    io.ConfigInputTextEnterKeepActive = true;  // Keep input active after Enter

    // Load Inter font from embedded data at multiple sizes
    ImFontConfig fontConfig;
    fontConfig.FontDataOwnedByAtlas = false;  // Don't free the static data
)";

    // Generate dynamic font loading based on collected sizes
    for (int size : fontSizes) {
        cpp << "    g_FontCache[" << size << "] = io.Fonts->AddFontFromMemoryTTF((void*)inter_font_data, inter_font_size, " << size << ".0f, &fontConfig);\n";
    }
    cpp << "    g_FontDefault = g_FontCache[16];\n";

    // Set legacy font pointers based on default sizes
    cpp << "    // Legacy font pointers\n";
    cpp << "    g_FontTitle = g_FontCache.count(42) ? g_FontCache[42] : g_FontDefault;\n";
    cpp << "    g_FontSubtitle = g_FontCache.count(24) ? g_FontCache[24] : g_FontDefault;\n";
    cpp << "    g_FontBody = g_FontCache.count(16) ? g_FontCache[16] : g_FontDefault;\n";
    cpp << "    g_FontButton = g_FontCache.count(16) ? g_FontCache[16] : g_FontDefault;\n";
    cpp << "    g_FontSmall = g_FontCache.count(14) ? g_FontCache[14] : g_FontDefault;\n";

    // Generate texture loading code in main() (global declarations already generated earlier)
    if (!imagePaths.empty()) {
        cpp << "\n    // Load images\n";
        cpp << "    printf(\"Loading " << imagePaths.size() << " images...\\n\");\n";
        for (const auto& pair : imageVarNames) {
            const std::string& imgPath = pair.first;
            const std::string& varName = pair.second;

            // Extract just the filename
            size_t lastSlash = imgPath.find_last_of("/\\");
            std::string filename = (lastSlash != std::string::npos) ? imgPath.substr(lastSlash + 1) : imgPath;

            cpp << "    " << varName << " = LoadImageTexture(\"images/" << filename << "\");\n";
        }
        cpp << "\n";
    }

    cpp << R"(
    SetupImGuiStyle();

    ImGui_ImplGlfw_InitForOpenGL(g_Window, true);
    ImGui_ImplOpenGL3_Init(glsl_version);

    printf("Website Started!\n");

#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(MainLoopStep, 0, 1);
#else
    while (!glfwWindowShouldClose(g_Window)) {
        MainLoopStep();
    }
#endif

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwDestroyWindow(g_Window);
    glfwTerminate();
    return 0;
}
)";

    return cpp.str();
}

// ============================================================================
// GENERATE BUILD SCRIPT
// ============================================================================
std::string GenerateBuildScript() {
    return R"(#!/bin/bash

echo "Building ImGui Website for WebAssembly..."

# Check if emsdk is available
if [ -z "$EMSDK" ]; then
    if [ -d "$HOME/emsdk" ]; then
        source $HOME/emsdk/emsdk_env.sh 2>/dev/null
    elif [ -d "/Users/imaging/emsdk" ]; then
        source /Users/imaging/emsdk/emsdk_env.sh 2>/dev/null
    else
        echo "ERROR: Emscripten SDK not found!"
        echo "Install it from: https://emscripten.org/docs/getting_started/downloads.html"
        exit 1
    fi
fi

# Cache directory for pre-compiled ImGui
CACHE_DIR="$HOME/.imgui_wasm_cache"
IMGUI_LIB="$CACHE_DIR/libimgui.a"

# Check if we need to build ImGui library (only once)
if [ ! -f "$IMGUI_LIB" ]; then
    echo "First run: Pre-compiling ImGui library (this only happens once)..."
    mkdir -p "$CACHE_DIR"

    # Compile each ImGui source to object file
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/imgui.cpp -o "$CACHE_DIR/imgui.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/imgui_draw.cpp -o "$CACHE_DIR/imgui_draw.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/imgui_tables.cpp -o "$CACHE_DIR/imgui_tables.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/imgui_widgets.cpp -o "$CACHE_DIR/imgui_widgets.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/imgui_demo.cpp -o "$CACHE_DIR/imgui_demo.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/backends/imgui_impl_glfw.cpp -o "$CACHE_DIR/imgui_impl_glfw.o" -s USE_GLFW=3
    emcc -std=c++17 -O2 -c -I./imgui -I./imgui/backends imgui/backends/imgui_impl_opengl3.cpp -o "$CACHE_DIR/imgui_impl_opengl3.o" -s USE_GLFW=3

    # Create static library
    emar rcs "$IMGUI_LIB" "$CACHE_DIR"/*.o
    echo "ImGui library cached! Future builds will be much faster."
fi

echo "Compiling website (using cached ImGui)..."

# Only compile main.cpp and link with cached library (FAST!)
emcc -std=c++17 -O2 \
    -I./imgui \
    -I./imgui/backends \
    main.cpp \
    "$IMGUI_LIB" \
    -s USE_GLFW=3 \
    -s USE_WEBGL2=1 \
    -s FULL_ES3=1 \
    -s WASM=1 \
    -s ALLOW_MEMORY_GROWTH=1 \
    -s NO_EXIT_RUNTIME=1 \
    -s ASYNCIFY \
    --preload-file images \
    --shell-file shell.html \
    -o index.html

if [ $? -eq 0 ]; then
    echo ""
    echo "=========================================="
    echo "Build successful!"
    echo "=========================================="
    echo ""
    echo "To view your website:"
    echo "1. Run: python3 -m http.server 8080"
    echo "2. Open: http://localhost:8080"
    echo ""
else
    echo "Build failed!"
    exit 1
fi
)";
}

// ============================================================================
// GENERATE SHELL HTML
// ============================================================================
std::string GenerateShellHTML() {
    std::stringstream html;
    html << "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n";
    html << "    <meta charset=\"utf-8\">\n";
    html << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    html << "    <title>" << g_ProjectName << "</title>\n";
    html << "    <style>\n";
    html << "        * { margin: 0; padding: 0; box-sizing: border-box; }\n";
    html << "        body { background: #1a1a1f; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }\n";
    html << "        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1f; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }\n";
    html << "        #loading h1 { color: #4d85ff; font-size: 2rem; margin-bottom: 20px; }\n";
    html << "        #loading .spinner { width: 50px; height: 50px; border: 4px solid #333; border-top-color: #4d85ff; border-radius: 50%; animation: spin 1s linear infinite; }\n";
    html << "        @keyframes spin { to { transform: rotate(360deg); } }\n";
    html << "        #loading p { color: #888; margin-top: 20px; }\n";
    html << "        .emscripten { position: fixed; top: 0; left: 0; }\n";
    html << "        canvas.emscripten { display: block; width: 100vw; height: 100vh; outline: none; }\n";
    html << "    </style>\n</head>\n<body>\n";
    html << "    <div id=\"loading\">\n";
    html << "        <h1>" << g_ProjectName << "</h1>\n";
    html << "        <div class=\"spinner\"></div>\n";
    html << "        <p>Loading...</p>\n";
    html << "    </div>\n";
    html << "    <canvas class=\"emscripten\" id=\"canvas\" oncontextmenu=\"event.preventDefault()\" tabindex=\"-1\"></canvas>\n";
    html << "    <script type='text/javascript'>\n";
    html << "        var Module = {\n";
    html << "            preRun: [], postRun: [],\n";
    html << "            print: function(text) { console.log(text); },\n";
    html << "            printErr: function(text) { console.error(text); },\n";
    html << "            canvas: (function() {\n";
    html << "                var canvas = document.getElementById('canvas');\n";
    html << "                canvas.addEventListener(\"webglcontextlost\", function(e) { alert('WebGL context lost. Reload the page.'); e.preventDefault(); }, false);\n";
    html << "                return canvas;\n";
    html << "            })(),\n";
    html << "            setStatus: function(text) { if (text === '') document.getElementById('loading').style.display = 'none'; },\n";
    html << "            totalDependencies: 0,\n";
    html << "            monitorRunDependencies: function(left) { this.totalDependencies = Math.max(this.totalDependencies, left); }\n";
    html << "        };\n";
    html << "        function resizeCanvas() { var c = document.getElementById('canvas'); c.width = window.innerWidth; c.height = window.innerHeight; }\n";
    html << "        window.addEventListener('resize', resizeCanvas);\n";
    html << "        resizeCanvas();\n";
    html << "        \n";
    html << "        // Ensure canvas gets focus for scroll/keyboard events\n";
    html << "        var canvas = document.getElementById('canvas');\n";
    html << "        \n";
    html << "        // Give canvas focus immediately and on any click\n";
    html << "        window.addEventListener('load', function() {\n";
    html << "            canvas.focus();\n";
    html << "        });\n";
    html << "        \n";
    html << "        canvas.addEventListener('click', function() {\n";
    html << "            canvas.focus();\n";
    html << "        });\n";
    html << "        \n";
    html << "        // Scroll handling - store scroll delta for the app to read\n";
    html << "        var scrollDelta = 0;\n";
    html << "        canvas.addEventListener('wheel', function(e) {\n";
    html << "            e.preventDefault();\n";
    html << "            e.stopPropagation();\n";
    html << "            scrollDelta = e.deltaY;\n";
    html << "        }, { passive: false });\n";
    html << "        // Expose scroll delta to Module\n";
    html << "        Module.getScrollDelta = function() { var d = scrollDelta; scrollDelta = 0; return d; };\n";
    html << "    </script>\n";
    html << "    {{{ SCRIPT }}}\n";
    html << "</body>\n</html>\n";
    return html.str();
}

// ============================================================================
// IMGUI TEMPLATES - Save/Load ImGui templates to database
// ============================================================================

// Create imgui_templates table if it doesn't exist
void EnsureImGuiTemplatesTable() {
    if (!g_DBConnection) return;

    std::string query = "CREATE TABLE IF NOT EXISTS imgui_templates ("
                        "id SERIAL PRIMARY KEY, "
                        "name VARCHAR(255) NOT NULL, "
                        "canvas_width REAL, "
                        "canvas_height REAL, "
                        "layer_count INTEGER, "
                        "imgui_code TEXT, "
                        "screenshot_data BYTEA, "
                        "screenshot_path TEXT, "
                        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
                        ")";

    // Also add screenshot_path, canvas_bg_color, and is_normal_mode columns if table exists but they don't
    PGresult* alterResult = PQexec(g_DBConnection,
        "ALTER TABLE imgui_templates ADD COLUMN IF NOT EXISTS screenshot_path TEXT");
    PQclear(alterResult);
    alterResult = PQexec(g_DBConnection,
        "ALTER TABLE imgui_templates ADD COLUMN IF NOT EXISTS canvas_bg_color VARCHAR(64)");
    PQclear(alterResult);
    alterResult = PQexec(g_DBConnection,
        "ALTER TABLE imgui_templates ADD COLUMN IF NOT EXISTS is_normal_mode BOOLEAN DEFAULT FALSE");
    PQclear(alterResult);
    PGresult* result = PQexec(g_DBConnection, query.c_str());
    if (PQresultStatus(result) != PGRES_COMMAND_OK) {
        printf("[ImGui Templates] Error creating table: %s\n", PQerrorMessage(g_DBConnection));
    }
    PQclear(result);

    // Create imgui_template_layers table for storing layer data
    query = "CREATE TABLE IF NOT EXISTS imgui_template_layers ("
            "id SERIAL PRIMARY KEY, "
            "template_id INTEGER REFERENCES imgui_templates(id) ON DELETE CASCADE, "
            "layer_order INTEGER, "
            "layer_type INTEGER, "
            "name VARCHAR(255), "
            "x REAL, y REAL, width REAL, height REAL, "
            "text TEXT, "
            "font_size REAL, "
            "opacity REAL, "
            "bg_color VARCHAR(64), "
            "text_color VARCHAR(64), "
            "border_radius REAL, "
            "border_width REAL, "
            "image_data BYTEA"
            ")";
    result = PQexec(g_DBConnection, query.c_str());
    if (PQresultStatus(result) != PGRES_COMMAND_OK) {
        printf("[ImGui Templates] Error creating layers table: %s\n", PQerrorMessage(g_DBConnection));
    }
    PQclear(result);

    // Add new columns for z_index and border_color if they don't exist
    PGresult* alterRes;
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS z_index INTEGER DEFAULT 0");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS border_color VARCHAR(64)");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS href TEXT");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS onclick_action TEXT");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS action_type VARCHAR(32)");
    PQclear(alterRes);
    alterRes = PQexec(g_DBConnection, "ALTER TABLE imgui_template_layers ADD COLUMN IF NOT EXISTS image_path TEXT");
    PQclear(alterRes);
}

// Get list of saved ImGui templates
std::vector<ImGuiTemplateInfo> GetImGuiTemplates() {
    std::vector<ImGuiTemplateInfo> templates;
    if (!g_DBConnection) return templates;

    EnsureImGuiTemplatesTable();

    std::string query = "SELECT id, name, created_at, layer_count, canvas_width, canvas_height "
                        "FROM imgui_templates ORDER BY created_at DESC";
    PGresult* result = PQexec(g_DBConnection, query.c_str());

    if (PQresultStatus(result) == PGRES_TUPLES_OK) {
        int rows = PQntuples(result);
        for (int i = 0; i < rows; i++) {
            ImGuiTemplateInfo info;
            info.id = atoi(PQgetvalue(result, i, 0));
            info.name = PQgetvalue(result, i, 1);
            info.created_at = PQgetvalue(result, i, 2);
            info.layer_count = atoi(PQgetvalue(result, i, 3));
            info.canvas_width = atof(PQgetvalue(result, i, 4));
            info.canvas_height = atof(PQgetvalue(result, i, 5));
            templates.push_back(info);
        }
    }
    PQclear(result);
    return templates;
}

// Convert Normal mode sections to Figma layers for saving
void ConvertSectionsToLayers() {
    if (g_FigmaMode) return;  // Already in Figma mode, no conversion needed

    g_FigmaProject.layers.clear();
    g_FigmaProject.canvas_width = 1400;
    g_FigmaProject.canvas_height = 3000;
    g_FigmaProject.canvas_bg_color = g_NormalCanvasBgColor;

    for (const auto& sec : g_Sections) {
        WebLayer layer;
        layer.id = g_FigmaProject.next_layer_id++;
        layer.name = sec.name;
        layer.x = sec.x_position;
        layer.y = sec.y_position;
        layer.width = sec.width;
        layer.height = sec.height;
        layer.z_index = sec.z_index;
        layer.bg_color = sec.bg_color;
        layer.text_color = sec.text_color;
        layer.opacity = 1.0f;
        layer.visible = true;
        layer.locked = false;

        // Set layer type based on section type
        switch (sec.type) {
            case SEC_LOGO:
                layer.type = LAYER_IMAGE;
                layer.name = "Logo";
                layer.text = sec.title;
                layer.image_path = sec.logo_path;
                layer.texture_id = sec.logo_texture_id;
                break;
            case SEC_HEADING:
                layer.type = LAYER_TEXT;
                layer.name = "Heading";
                layer.text = sec.title;
                layer.font_size = sec.title_font_size;
                layer.text_color = sec.title_color;
                break;
            case SEC_TEXT_ELEMENT:
                layer.type = LAYER_TEXT;
                layer.name = "Text";
                layer.text = sec.content;
                layer.font_size = sec.content_font_size;
                layer.text_color = sec.content_color;
                break;
            case SEC_BUTTON_ELEMENT:
                layer.type = LAYER_BUTTON;
                layer.name = "Button";
                layer.text = sec.button_text;
                layer.href = sec.button_link;
                layer.onclick_action = sec.button_link;
                layer.action_type = "link";
                layer.bg_color = sec.button_bg_color;
                layer.text_color = sec.button_text_color;
                layer.border_radius = 6;
                break;
            default:
                layer.type = LAYER_DIV;
                layer.name = sec.name;
                layer.text = sec.title;
                break;
        }

        g_FigmaProject.layers.push_back(layer);
    }

    printf("[Convert] Converted %zu sections to %zu layers\n", g_Sections.size(), g_FigmaProject.layers.size());
}

// Convert Figma layers back to Normal mode sections for loading
void ConvertLayersToSections() {
    g_Sections.clear();
    g_NormalCanvasBgColor = g_FigmaProject.canvas_bg_color;

    for (const auto& layer : g_FigmaProject.layers) {
        SectionType secType = SEC_CUSTOM;

        // Determine section type from layer type and name
        if (layer.type == LAYER_IMAGE || layer.name == "Logo" || layer.name.find("Logo") != std::string::npos) {
            secType = SEC_LOGO;
        } else if (layer.type == LAYER_BUTTON || layer.name == "Button" || layer.name.find("Button") != std::string::npos) {
            secType = SEC_BUTTON_ELEMENT;
        } else if (layer.type == LAYER_TEXT) {
            if (layer.name == "Heading" || layer.name.find("Heading") != std::string::npos || layer.font_size >= 24) {
                secType = SEC_HEADING;
            } else {
                secType = SEC_TEXT_ELEMENT;
            }
        }

        WebSection sec(g_NextSectionId++, secType);
        sec.name = layer.name;
        sec.x_position = layer.x;
        sec.y_position = layer.y;
        sec.width = layer.width;
        sec.height = layer.height;
        sec.z_index = layer.z_index;
        sec.bg_color = layer.bg_color;
        sec.text_color = layer.text_color;

        switch (secType) {
            case SEC_LOGO:
                sec.title = layer.text;
                sec.logo_path = layer.image_path;
                // Load logo texture if path exists
                if (!sec.logo_path.empty()) {
                    int w, h, n;
                    unsigned char* imgData = stbi_load(sec.logo_path.c_str(), &w, &h, &n, 4);
                    if (imgData) {
                        glGenTextures(1, &sec.logo_texture_id);
                        glBindTexture(GL_TEXTURE_2D, sec.logo_texture_id);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData);
                        stbi_image_free(imgData);
                    }
                }
                break;
            case SEC_HEADING:
                sec.title = layer.text;
                sec.title_font_size = layer.font_size > 0 ? layer.font_size : 32;
                sec.title_color = layer.text_color;
                break;
            case SEC_TEXT_ELEMENT:
                sec.content = layer.text;
                sec.content_font_size = layer.font_size > 0 ? layer.font_size : 16;
                sec.content_color = layer.text_color;
                break;
            case SEC_BUTTON_ELEMENT:
                sec.button_text = layer.text;
                sec.button_link = layer.href.empty() ? layer.onclick_action : layer.href;
                sec.button_bg_color = layer.bg_color;
                sec.button_text_color = layer.text_color;
                break;
            default:
                sec.title = layer.text;
                break;
        }

        g_Sections.push_back(sec);
    }

    // Select first section if any
    if (!g_Sections.empty()) {
        g_SelectedSectionIndex = 0;
        g_Sections[0].selected = true;
    }

    printf("[Convert] Converted %zu layers to %zu sections\n", g_FigmaProject.layers.size(), g_Sections.size());
}

// Save current Figma project as ImGui template
bool SaveAsImGuiTemplate(const std::string& templateName) {
    // Check if saving from Normal mode BEFORE any conversion
    bool isNormalMode = !g_FigmaMode;

    // If in Normal mode, FIRST save sections using SaveTemplate to preserve all images
    if (isNormalMode && !g_Sections.empty()) {
        printf("[Save] Saving Normal mode template with %zu sections...\n", g_Sections.size());
        SaveTemplate(templateName, "User designed template");  // This saves all section images
        ConvertSectionsToLayers();  // Also convert to layers for layer-based loading
    }
    // If in Figma mode, convert layers to sections first, then save both ways
    else if (g_FigmaMode && !g_FigmaProject.layers.empty()) {
        printf("[Save] Saving Figma template with %zu layers...\n", g_FigmaProject.layers.size());
        // Convert Figma layers to Normal mode sections for unified saving
        ConvertLayersToSections();
        // Save sections to templates/sections tables
        if (!g_Sections.empty()) {
            SaveTemplate(templateName, "Figma imported template");
            printf("[Save] Converted and saved %zu sections to database\n", g_Sections.size());
        }
    }

    if (!g_DBConnection) {
        printf("[Save] No database connection!\n");
        return false;
    }

    // For Figma mode with no layers but has sections, still continue
    if (g_FigmaProject.layers.empty() && g_Sections.empty()) {
        printf("[Save] No layers or sections to save!\n");
        return false;
    }

    EnsureImGuiTemplatesTable();

    // Insert template record with screenshot path
    std::ostringstream query;
    query << "INSERT INTO imgui_templates (name, canvas_width, canvas_height, layer_count, screenshot_path, canvas_bg_color, is_normal_mode) VALUES ("
          << "'" << SQLEscape(templateName) << "', "
          << g_FigmaProject.canvas_width << ", "
          << g_FigmaProject.canvas_height << ", "
          << g_FigmaProject.layers.size() << ", "
          << "'" << SQLEscape(g_FigmaProject.screenshot_path) << "', "
          << "'" << ColorToSQL(g_FigmaProject.canvas_bg_color) << "', "
          << (isNormalMode ? "TRUE" : "FALSE") << ") RETURNING id";

    PGresult* result = PQexec(g_DBConnection, query.str().c_str());
    if (PQresultStatus(result) != PGRES_TUPLES_OK) {
        printf("[ImGui Templates] Error inserting template: %s\n", PQerrorMessage(g_DBConnection));
        PQclear(result);
        return false;
    }

    int templateId = atoi(PQgetvalue(result, 0, 0));
    PQclear(result);

    printf("[ImGui Templates] Created template ID: %d\n", templateId);

    // Insert layers
    for (size_t i = 0; i < g_FigmaProject.layers.size(); i++) {
        const WebLayer& layer = g_FigmaProject.layers[i];

        // Read image data if exists
        std::string imageDataHex = "NULL";
        if (layer.type == LAYER_IMAGE && !layer.image_path.empty()) {
            std::vector<unsigned char> imgData = ReadImageFile(layer.image_path);
            if (!imgData.empty()) {
                imageDataHex = BinaryToHex(imgData);
            }
        }

        std::ostringstream layerQuery;
        layerQuery << "INSERT INTO imgui_template_layers ("
                   << "template_id, layer_order, layer_type, name, x, y, width, height, "
                   << "text, font_size, opacity, bg_color, text_color, border_radius, border_width, image_data, "
                   << "href, onclick_action, action_type, image_path, z_index, border_color"
                   << ") VALUES ("
                   << templateId << ", " << i << ", " << (int)layer.type << ", "
                   << "'" << SQLEscape(layer.name) << "', "
                   << layer.x << ", " << layer.y << ", " << layer.width << ", " << layer.height << ", "
                   << "'" << SQLEscape(layer.text) << "', "
                   << layer.font_size << ", " << layer.opacity << ", "
                   << "'" << ColorToSQL(layer.bg_color) << "', "
                   << "'" << ColorToSQL(layer.text_color) << "', "
                   << layer.border_radius << ", " << layer.border_width << ", "
                   << imageDataHex << ", "
                   << "'" << SQLEscape(layer.href) << "', "
                   << "'" << SQLEscape(layer.onclick_action) << "', "
                   << "'" << SQLEscape(layer.action_type) << "', "
                   << "'" << SQLEscape(layer.image_path) << "', "
                   << layer.z_index << ", "
                   << "'" << ColorToSQL(layer.border_color) << "')";

        result = PQexec(g_DBConnection, layerQuery.str().c_str());
        if (PQresultStatus(result) != PGRES_COMMAND_OK) {
            printf("[ImGui Templates] Error inserting layer %zu: %s\n", i, PQerrorMessage(g_DBConnection));
        }
        PQclear(result);
    }

    printf("[ImGui Templates] Saved '%s' with %zu layers!\n", templateName.c_str(), g_FigmaProject.layers.size());

    // ALSO save to templates + figma_layers tables for Template Gallery compatibility
    {
        // Read screenshot data
        std::vector<unsigned char> screenshotData;
        if (!g_FigmaProject.screenshot_path.empty()) {
            screenshotData = ReadImageFile(g_FigmaProject.screenshot_path);
        }

        // Ensure columns exist
        std::string alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS is_figma_template BOOLEAN DEFAULT FALSE";
        PGresult* alterResult = PQexec(g_DBConnection, alterQuery.c_str());
        PQclear(alterResult);

        alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_screenshot_path TEXT";
        alterResult = PQexec(g_DBConnection, alterQuery.c_str());
        PQclear(alterResult);

        alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_screenshot_data BYTEA";
        alterResult = PQexec(g_DBConnection, alterQuery.c_str());
        PQclear(alterResult);

        alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_canvas_width REAL";
        alterResult = PQexec(g_DBConnection, alterQuery.c_str());
        PQclear(alterResult);

        alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_canvas_height REAL";
        alterResult = PQexec(g_DBConnection, alterQuery.c_str());
        PQclear(alterResult);

        // Create template in templates table
        std::string tQuery = "INSERT INTO templates (template_name, description, project_name) VALUES ('" +
            SQLEscape(templateName) + "', 'Figma-style imported template', '" +
            SQLEscape(templateName) + "') " +
            "ON CONFLICT (template_name) DO UPDATE SET description='Figma-style imported template', " +
            "project_name='" + SQLEscape(templateName) + "', updated_date=NOW()";

        result = PQexec(g_DBConnection, tQuery.c_str());
        if (PQresultStatus(result) != PGRES_COMMAND_OK) {
            printf("[Template Gallery] Error creating template: %s\n", PQerrorMessage(g_DBConnection));
        }
        PQclear(result);

        // Get template ID
        tQuery = "SELECT id FROM templates WHERE template_name='" + SQLEscape(templateName) + "'";
        result = PQexec(g_DBConnection, tQuery.c_str());
        int galleryTemplateId = 0;
        if (PQresultStatus(result) == PGRES_TUPLES_OK && PQntuples(result) > 0) {
            galleryTemplateId = atoi(PQgetvalue(result, 0, 0));
        }
        PQclear(result);

        if (galleryTemplateId > 0) {
            // Delete old figma_layers
            tQuery = "DELETE FROM figma_layers WHERE template_id=" + std::to_string(galleryTemplateId);
            result = PQexec(g_DBConnection, tQuery.c_str());
            PQclear(result);

            // Create figma_layers table if not exists
            tQuery = "CREATE TABLE IF NOT EXISTS figma_layers ("
                    "id SERIAL PRIMARY KEY, "
                    "template_id INTEGER REFERENCES templates(id), "
                    "layer_order INTEGER, "
                    "layer_type INTEGER, "
                    "name VARCHAR(255), "
                    "x REAL, y REAL, width REAL, height REAL, "
                    "text TEXT, "
                    "font_size REAL, "
                    "opacity REAL, "
                    "image_path TEXT, "
                    "image_data BYTEA, "
                    "bg_color VARCHAR(64), "
                    "text_color VARCHAR(64), "
                    "href TEXT, "
                    "onclick_action TEXT, "
                    "action_type VARCHAR(32), "
                    "z_index INTEGER DEFAULT 0, "
                    "border_color VARCHAR(64), "
                    "border_radius REAL, "
                    "border_width REAL"
                    ")";
            result = PQexec(g_DBConnection, tQuery.c_str());
            PQclear(result);

            // Add new columns if they don't exist
            result = PQexec(g_DBConnection, "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS z_index INTEGER DEFAULT 0");
            PQclear(result);
            result = PQexec(g_DBConnection, "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS border_color VARCHAR(64)");
            PQclear(result);
            result = PQexec(g_DBConnection, "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS border_radius REAL");
            PQclear(result);
            result = PQexec(g_DBConnection, "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS border_width REAL");
            result = PQexec(g_DBConnection, tQuery.c_str());
            PQclear(result);

            // Add is_normal_mode column if not exists
            result = PQexec(g_DBConnection, "ALTER TABLE templates ADD COLUMN IF NOT EXISTS is_normal_mode BOOLEAN DEFAULT FALSE");
            PQclear(result);

            // Update template with Figma info
            std::ostringstream updateQuery;
            updateQuery << "UPDATE templates SET "
                        << "figma_screenshot_path='" << SQLEscape(g_FigmaProject.screenshot_path) << "', "
                        << "figma_canvas_width=" << g_FigmaProject.canvas_width << ", "
                        << "figma_canvas_height=" << g_FigmaProject.canvas_height << ", "
                        << "is_figma_template=TRUE, "
                        << "is_normal_mode=" << (isNormalMode ? "TRUE" : "FALSE");
            if (!screenshotData.empty()) {
                updateQuery << ", figma_screenshot_data=" << BinaryToHex(screenshotData);
            }
            updateQuery << " WHERE id=" << galleryTemplateId;
            result = PQexec(g_DBConnection, updateQuery.str().c_str());
            PQclear(result);

            // Insert each layer into figma_layers
            for (size_t i = 0; i < g_FigmaProject.layers.size(); i++) {
                const auto& l = g_FigmaProject.layers[i];

                std::vector<unsigned char> imgData;
                if (!l.image_path.empty()) {
                    imgData = ReadImageFile(l.image_path);
                }

                std::ostringstream lq;
                lq << "INSERT INTO figma_layers ("
                   << "template_id, layer_order, layer_type, name, x, y, width, height, "
                   << "text, font_size, opacity, image_path, image_data, bg_color, text_color, "
                   << "href, onclick_action, action_type, z_index, border_color, border_radius, border_width"
                   << ") VALUES ("
                   << galleryTemplateId << ", " << i << ", " << (int)l.type << ", "
                   << "'" << SQLEscape(l.name) << "', "
                   << l.x << ", " << l.y << ", " << l.width << ", " << l.height << ", "
                   << "'" << SQLEscape(l.text) << "', "
                   << l.font_size << ", " << l.opacity << ", "
                   << "'" << SQLEscape(l.image_path) << "', "
                   << (imgData.empty() ? "NULL" : BinaryToHex(imgData)) << ", "
                   << "'" << ColorToSQL(l.bg_color) << "', "
                   << "'" << ColorToSQL(l.text_color) << "', "
                   << "'" << SQLEscape(l.href) << "', "
                   << "'" << SQLEscape(l.onclick_action) << "', "
                   << "'" << SQLEscape(l.action_type) << "', "
                   << l.z_index << ", "
                   << "'" << ColorToSQL(l.border_color) << "', "
                   << l.border_radius << ", "
                   << l.border_width
                   << ")";

                result = PQexec(g_DBConnection, lq.str().c_str());
                PQclear(result);
            }

            printf("[Template Gallery] Also saved to templates table with ID: %d\n", galleryTemplateId);
        }
    }

    return true;
}

// Load ImGui template from database
bool LoadImGuiTemplate(int templateId) {
    if (!g_DBConnection) return false;

    // Get template info (including screenshot_path, canvas_bg_color, and is_normal_mode)
    std::string query = "SELECT name, canvas_width, canvas_height, screenshot_path, canvas_bg_color, is_normal_mode FROM imgui_templates WHERE id=" + std::to_string(templateId);
    PGresult* result = PQexec(g_DBConnection, query.c_str());

    if (PQresultStatus(result) != PGRES_TUPLES_OK || PQntuples(result) == 0) {
        printf("[ImGui Templates] Template not found: %d\n", templateId);
        PQclear(result);
        return false;
    }

    // Clear current project
    g_FigmaProject = FigmaProject();
    g_FigmaProject.name = PQgetvalue(result, 0, 0);
    g_FigmaProject.canvas_width = atof(PQgetvalue(result, 0, 1));
    g_FigmaProject.canvas_height = atof(PQgetvalue(result, 0, 2));

    // Load canvas background color if available
    std::string canvasBgColorStr = PQgetisnull(result, 0, 4) ? "" : PQgetvalue(result, 0, 4);
    if (!canvasBgColorStr.empty()) {
        g_FigmaProject.canvas_bg_color = SQLToColor(canvasBgColorStr);
    }

    // Check if this is a Normal mode template
    bool isNormalModeTemplate = false;
    if (!PQgetisnull(result, 0, 5)) {
        std::string isNormalStr = PQgetvalue(result, 0, 5);
        isNormalModeTemplate = (isNormalStr == "t" || isNormalStr == "true" || isNormalStr == "1");
    }

    // Load screenshot if available
    std::string screenshotPath = PQgetisnull(result, 0, 3) ? "" : PQgetvalue(result, 0, 3);
    if (!screenshotPath.empty()) {
        g_FigmaProject.screenshot_path = screenshotPath;
        int w, h, n;
        unsigned char* imgData = stbi_load(screenshotPath.c_str(), &w, &h, &n, 4);
        if (imgData) {
            glGenTextures(1, &g_FigmaProject.screenshot_texture_id);
            glBindTexture(GL_TEXTURE_2D, g_FigmaProject.screenshot_texture_id);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData);
            stbi_image_free(imgData);
            g_FigmaProject.show_reference = true;  // Enable reference mode
            printf("[ImGui Templates] Loaded screenshot: %dx%d\n", w, h);
        }
    }
    PQclear(result);

    // Load layers
    query = "SELECT layer_type, name, x, y, width, height, text, font_size, opacity, "
            "bg_color, text_color, border_radius, border_width, image_data, "
            "href, onclick_action, action_type, image_path, z_index, border_color "
            "FROM imgui_template_layers WHERE template_id=" + std::to_string(templateId) +
            " ORDER BY layer_order";
    result = PQexec(g_DBConnection, query.c_str());

    if (PQresultStatus(result) == PGRES_TUPLES_OK) {
        int rows = PQntuples(result);
        for (int i = 0; i < rows; i++) {
            WebLayer layer;
            layer.id = g_FigmaProject.next_layer_id++;
            layer.type = (LayerType)atoi(PQgetvalue(result, i, 0));
            layer.name = PQgetvalue(result, i, 1);
            layer.x = atof(PQgetvalue(result, i, 2));
            layer.y = atof(PQgetvalue(result, i, 3));
            layer.width = atof(PQgetvalue(result, i, 4));
            layer.height = atof(PQgetvalue(result, i, 5));
            layer.text = PQgetvalue(result, i, 6);
            layer.font_size = atof(PQgetvalue(result, i, 7));
            layer.opacity = atof(PQgetvalue(result, i, 8));
            layer.bg_color = SQLToColor(PQgetvalue(result, i, 9));
            layer.text_color = SQLToColor(PQgetvalue(result, i, 10));
            layer.border_radius = atof(PQgetvalue(result, i, 11));
            layer.border_width = atof(PQgetvalue(result, i, 12));
            layer.visible = true;
            layer.locked = false;

            // Load action data for buttons/links
            layer.href = PQgetisnull(result, i, 14) ? "" : PQgetvalue(result, i, 14);
            layer.onclick_action = PQgetisnull(result, i, 15) ? "" : PQgetvalue(result, i, 15);
            layer.action_type = PQgetisnull(result, i, 16) ? "" : PQgetvalue(result, i, 16);
            layer.image_path = PQgetisnull(result, i, 17) ? "" : PQgetvalue(result, i, 17);

            // Load z_index and border_color
            layer.z_index = PQgetisnull(result, i, 18) ? 0 : atoi(PQgetvalue(result, i, 18));
            layer.border_color = PQgetisnull(result, i, 19) ? ImVec4(0,0,0,1) : SQLToColor(PQgetvalue(result, i, 19));

            // Load image from path if available
            if (!layer.image_path.empty() && layer.type == LAYER_IMAGE) {
                int w, h, n;
                unsigned char* pixels = stbi_load(layer.image_path.c_str(), &w, &h, &n, 4);
                if (pixels) {
                    glGenTextures(1, &layer.texture_id);
                    glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
                    stbi_image_free(pixels);
                }
            }

            // Load image data if present (BYTEA)
            if (!PQgetisnull(result, i, 13)) {
                const char* hexData = PQgetvalue(result, i, 13);
                size_t hexLen = PQgetlength(result, i, 13);
                std::vector<unsigned char> imgData = DecodePostgresHexBytea(hexData, hexLen);

                if (!imgData.empty()) {
                    // Create texture from data
                    int w, h, n;
                    unsigned char* pixels = stbi_load_from_memory(imgData.data(), imgData.size(), &w, &h, &n, 4);
                    if (pixels) {
                        glGenTextures(1, &layer.texture_id);
                        glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
                        stbi_image_free(pixels);
                    }
                }
            }

            g_FigmaProject.layers.push_back(layer);
        }
    }
    PQclear(result);

    // Check if this is a Normal mode template - if so, convert layers to sections
    if (isNormalModeTemplate) {
        ConvertLayersToSections();
        g_FigmaMode = false;
        g_SelectedLayerId = -1;
        printf("[ImGui Templates] Loaded Normal mode template '%s' with %zu sections\n", g_FigmaProject.name.c_str(), g_Sections.size());
    } else {
        // Switch to Figma mode
        g_FigmaMode = true;
        g_SelectedLayerId = -1;
        printf("[ImGui Templates] Loaded Figma template '%s' with %zu layers\n", g_FigmaProject.name.c_str(), g_FigmaProject.layers.size());
    }

    return true;
}

// Delete ImGui template from database
bool DeleteImGuiTemplate(int templateId) {
    if (!g_DBConnection) return false;

    std::string query = "DELETE FROM imgui_templates WHERE id=" + std::to_string(templateId);
    PGresult* result = PQexec(g_DBConnection, query.c_str());
    bool success = (PQresultStatus(result) == PGRES_COMMAND_OK);
    PQclear(result);

    if (success) {
        printf("[ImGui Templates] Deleted template %d\n", templateId);
    }
    return success;
}

// ============================================================================
// EXPORT FIGMA DESIGN TO STANDALONE IMGUI C++ APPLICATION
// ============================================================================
void ExportFigmaToImGui() {
    if (g_FigmaProject.layers.empty()) {
        printf("[Export] No layers to export!\n");
        return;
    }

    std::string folder = ChooseFolderDialog("Choose export folder for Figma project");
    if (folder.empty()) return;
    if (folder.back() == '/') folder.pop_back();

    std::string projectName = g_FigmaProject.name.empty() ? "figma_export" : g_FigmaProject.name;
    // Sanitize project name (remove spaces, special chars)
    for (char& c : projectName) {
        if (!isalnum(c) && c != '_') c = '_';
    }

    std::string exportFolder = folder + "/" + projectName + "_ImGui";
    std::string imguiFolder = exportFolder + "/imgui";
    std::string imagesFolder = exportFolder + "/images";

    // Create directories
    mkdir(exportFolder.c_str(), 0755);
    mkdir(imguiFolder.c_str(), 0755);
    mkdir(imagesFolder.c_str(), 0755);

    printf("[Export Figma] Exporting to: %s\n", exportFolder.c_str());

    // Copy ImGui core files
    std::vector<std::string> imguiFiles = {
        "imgui.cpp", "imgui.h", "imgui_demo.cpp", "imgui_draw.cpp",
        "imgui_internal.h", "imgui_tables.cpp", "imgui_widgets.cpp",
        "imconfig.h", "imstb_rectpack.h", "imstb_textedit.h", "imstb_truetype.h"
    };
    for (const auto& f : imguiFiles) {
        std::ifstream src("imgui/" + f, std::ios::binary);
        if (src.good()) {
            std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
            dst << src.rdbuf();
        }
    }

    // Copy ImGui GLFW/OpenGL backend files (from imgui/backends/)
    std::vector<std::string> backendFiles = {
        "imgui_impl_glfw.cpp", "imgui_impl_glfw.h",
        "imgui_impl_opengl3.cpp", "imgui_impl_opengl3.h", "imgui_impl_opengl3_loader.h"
    };
    for (const auto& f : backendFiles) {
        std::ifstream src("imgui/backends/" + f, std::ios::binary);
        if (src.good()) {
            std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
            dst << src.rdbuf();
        }
    }

    // Copy stb_image.h
    {
        std::ifstream src("stb_image.h", std::ios::binary);
        if (src.good()) {
            std::ofstream dst(exportFolder + "/stb_image.h", std::ios::binary);
            dst << src.rdbuf();
        }
    }

    // Copy screenshot image
    std::string screenshotDest = "";
    if (!g_FigmaProject.screenshot_path.empty()) {
        screenshotDest = imagesFolder + "/screenshot.png";
        std::ifstream src(g_FigmaProject.screenshot_path, std::ios::binary);
        if (src.good()) {
            std::ofstream dst(screenshotDest, std::ios::binary);
            dst << src.rdbuf();
            printf("[Export Figma] Copied screenshot\n");
        }
    }

    // Copy layer images and build image list
    std::vector<std::pair<std::string, std::string>> imageMap; // original path -> new filename
    // Also track animation images per layer: layerId -> vector of animation image filenames
    std::map<int, std::vector<std::string>> animationImageMap;
    int imgIndex = 0;

    for (const auto& layer : g_FigmaProject.layers) {
        // Copy main image
        if (!layer.image_path.empty()) {
            bool found = false;
            for (const auto& p : imageMap) {
                if (p.first == layer.image_path) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                std::string ext = ".png";
                size_t dotPos = layer.image_path.rfind('.');
                if (dotPos != std::string::npos) {
                    ext = layer.image_path.substr(dotPos);
                }
                std::string newName = "img_" + std::to_string(imgIndex++) + ext;
                std::string destPath = imagesFolder + "/" + newName;

                std::ifstream src(layer.image_path, std::ios::binary);
                if (src.good()) {
                    std::ofstream dst(destPath, std::ios::binary);
                    dst << src.rdbuf();
                    imageMap.push_back({layer.image_path, newName});
                    printf("[Export Figma] Copied image: %s\n", newName.c_str());
                }
            }
        }

        // Copy animation/slideshow images
        if (layer.enable_animation && !layer.animation_images.empty()) {
            std::vector<std::string> animFiles;
            for (const auto& animImg : layer.animation_images) {
                std::string ext = ".png";
                size_t dotPos = animImg.rfind('.');
                if (dotPos != std::string::npos) {
                    ext = animImg.substr(dotPos);
                }
                std::string newName = "anim_" + std::to_string(layer.id) + "_" + std::to_string(animFiles.size()) + ext;
                std::string destPath = imagesFolder + "/" + newName;

                std::ifstream src(animImg, std::ios::binary);
                if (src.good()) {
                    std::ofstream dst(destPath, std::ios::binary);
                    dst << src.rdbuf();
                    animFiles.push_back(newName);
                    printf("[Export Figma] Copied animation image: %s\n", newName.c_str());
                }
            }
            if (!animFiles.empty()) {
                animationImageMap[layer.id] = animFiles;
            }
        }
    }

    // Generate main.cpp
    std::ostringstream cpp;

    cpp << "// ============================================================================\n";
    cpp << "// " << projectName << " - Exported from Website Builder Figma Import\n";
    cpp << "// Generated ImGui Standalone Application\n";
    cpp << "// ============================================================================\n\n";

    cpp << "#include \"imgui/imgui.h\"\n";
    cpp << "#include \"imgui/imgui_impl_glfw.h\"\n";
    cpp << "#include \"imgui/imgui_impl_opengl3.h\"\n";
    cpp << "#include <GLFW/glfw3.h>\n";
    cpp << "#include <cstdio>\n";
    cpp << "#include <cmath>\n";
    cpp << "#include <map>\n";
    cpp << "#include <string>\n\n";

    cpp << "#define STB_IMAGE_IMPLEMENTATION\n";
    cpp << "#include \"stb_image.h\"\n\n";

    // Add font management
    cpp << "// ============================================================================\n";
    cpp << "// FONT MANAGEMENT - Multiple sizes for accuracy\n";
    cpp << "// ============================================================================\n";
    cpp << "std::map<int, ImFont*> g_Fonts; // fontSize -> font pointer\n";
    cpp << "ImFont* g_DefaultFont = nullptr;\n\n";

    cpp << "ImFont* GetFontForSize(int size) {\n";
    cpp << "    // Find closest available font size\n";
    cpp << "    if (g_Fonts.empty()) return g_DefaultFont;\n";
    cpp << "    int closest = 16;\n";
    cpp << "    int minDiff = 9999;\n";
    cpp << "    for (auto& kv : g_Fonts) {\n";
    cpp << "        int diff = abs(kv.first - size);\n";
    cpp << "        if (diff < minDiff) {\n";
    cpp << "            minDiff = diff;\n";
    cpp << "            closest = kv.first;\n";
    cpp << "        }\n";
    cpp << "    }\n";
    cpp << "    return g_Fonts[closest];\n";
    cpp << "}\n\n";

    cpp << "// ============================================================================\n";
    cpp << "// TEXTURE LOADING\n";
    cpp << "// ============================================================================\n";
    cpp << "GLuint LoadTexture(const char* path) {\n";
    cpp << "    int w, h, n;\n";
    cpp << "    unsigned char* data = stbi_load(path, &w, &h, &n, 4);\n";
    cpp << "    if (!data) {\n";
    cpp << "        printf(\"Failed to load: %s\\n\", path);\n";
    cpp << "        return 0;\n";
    cpp << "    }\n";
    cpp << "    GLuint tex;\n";
    cpp << "    glGenTextures(1, &tex);\n";
    cpp << "    glBindTexture(GL_TEXTURE_2D, tex);\n";
    cpp << "    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n";
    cpp << "    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n";
    cpp << "    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n";
    cpp << "    stbi_image_free(data);\n";
    cpp << "    return tex;\n";
    cpp << "}\n\n";

    cpp << "// ============================================================================\n";
    cpp << "// GLOBAL TEXTURES\n";
    cpp << "// ============================================================================\n";
    cpp << "GLuint g_ScreenshotTex = 0;\n";
    for (size_t i = 0; i < imageMap.size(); i++) {
        cpp << "GLuint g_ImageTex_" << i << " = 0;\n";
    }
    cpp << "\n";

    // Animation textures for each layer with animation
    cpp << "// Animation textures (slideshow)\n";
    for (const auto& layer : g_FigmaProject.layers) {
        if (layer.enable_animation && animationImageMap.find(layer.id) != animationImageMap.end()) {
            const auto& animFiles = animationImageMap.at(layer.id);
            cpp << "GLuint g_AnimTex_" << layer.id << "[" << animFiles.size() << "] = {0};\n";
            cpp << "int g_AnimFrame_" << layer.id << " = 0;\n";
            cpp << "float g_AnimTimer_" << layer.id << " = 0.0f;\n";
            cpp << "float g_AnimSpeed_" << layer.id << " = " << layer.animation_speed << "f;\n";
        }
    }
    cpp << "\n";

    cpp << "// Canvas dimensions\n";
    cpp << "const float CANVAS_WIDTH = " << g_FigmaProject.canvas_width << ".0f;\n";
    cpp << "const float CANVAS_HEIGHT = " << g_FigmaProject.canvas_height << ".0f;\n\n";

    cpp << "// Scroll position\n";
    cpp << "float g_ScrollY = 0.0f;\n\n";

    cpp << "// ============================================================================\n";
    cpp << "// LOAD ALL TEXTURES\n";
    cpp << "// ============================================================================\n";
    cpp << "void LoadAllTextures() {\n";
    if (!screenshotDest.empty()) {
        cpp << "    g_ScreenshotTex = LoadTexture(\"images/screenshot.png\");\n";
    }
    for (size_t i = 0; i < imageMap.size(); i++) {
        cpp << "    g_ImageTex_" << i << " = LoadTexture(\"images/" << imageMap[i].second << "\");\n";
    }
    // Load animation textures
    for (const auto& layer : g_FigmaProject.layers) {
        if (layer.enable_animation && animationImageMap.find(layer.id) != animationImageMap.end()) {
            const auto& animFiles = animationImageMap.at(layer.id);
            for (size_t i = 0; i < animFiles.size(); i++) {
                cpp << "    g_AnimTex_" << layer.id << "[" << i << "] = LoadTexture(\"images/" << animFiles[i] << "\");\n";
            }
        }
    }
    cpp << "}\n\n";

    cpp << "// ============================================================================\n";
    cpp << "// RENDER WEBSITE\n";
    cpp << "// ============================================================================\n";
    cpp << "void RenderWebsite() {\n";
    cpp << "    ImGuiIO& io = ImGui::GetIO();\n";
    cpp << "    ImDrawList* dl = ImGui::GetWindowDrawList();\n";
    cpp << "    ImVec2 winPos = ImGui::GetWindowPos();\n";
    cpp << "    ImVec2 winSize = ImGui::GetWindowSize();\n\n";

    cpp << "    // Handle scrolling\n";
    cpp << "    if (ImGui::IsWindowHovered()) {\n";
    cpp << "        g_ScrollY -= io.MouseWheel * 50.0f;\n";
    cpp << "        if (g_ScrollY < 0) g_ScrollY = 0;\n";
    cpp << "        float maxScroll = CANVAS_HEIGHT - winSize.y;\n";
    cpp << "        if (maxScroll < 0) maxScroll = 0;\n";
    cpp << "        if (g_ScrollY > maxScroll) g_ScrollY = maxScroll;\n";
    cpp << "    }\n\n";

    cpp << "    // Background\n";
    cpp << "    dl->AddRectFilled(winPos, ImVec2(winPos.x + winSize.x, winPos.y + winSize.y), IM_COL32(255, 255, 255, 255));\n\n";

    // Render screenshot as background reference
    if (!screenshotDest.empty()) {
        cpp << "    // Screenshot background\n";
        cpp << "    if (g_ScreenshotTex) {\n";
        cpp << "        ImVec2 imgMin(winPos.x, winPos.y - g_ScrollY);\n";
        cpp << "        ImVec2 imgMax(winPos.x + CANVAS_WIDTH, winPos.y + CANVAS_HEIGHT - g_ScrollY);\n";
        cpp << "        dl->AddImage((ImTextureID)(intptr_t)g_ScreenshotTex, imgMin, imgMax);\n";
        cpp << "    }\n\n";
    }

    cpp << "    // ==================== RENDER LAYERS ====================\n\n";

    // Generate code for each layer
    int layerNum = 0;
    for (const auto& layer : g_FigmaProject.layers) {
        if (!layer.visible) continue;

        cpp << "    // Layer " << layerNum << ": " << layer.name << " (" <<
            (layer.type == LAYER_TEXT ? "TEXT" :
             layer.type == LAYER_IMAGE ? "IMAGE" :
             layer.type == LAYER_BUTTON ? "BUTTON" :
             layer.type == LAYER_INPUT ? "INPUT" : "DIV") << ")\n";

        cpp << "    {\n";
        cpp << "        float x = winPos.x + " << layer.x << ".0f;\n";
        cpp << "        float y = winPos.y + " << layer.y << ".0f - g_ScrollY;\n";
        cpp << "        float w = " << layer.width << ".0f;\n";
        cpp << "        float h = " << layer.height << ".0f;\n";
        cpp << "        ImVec2 p1(x, y);\n";
        cpp << "        ImVec2 p2(x + w, y + h);\n\n";

        // Skip if outside viewport
        cpp << "        // Skip if outside viewport\n";
        cpp << "        if (y + h >= winPos.y && y <= winPos.y + winSize.y) {\n";

        switch (layer.type) {
            case LAYER_IMAGE: {
                // Check if this layer has animation
                if (layer.enable_animation && animationImageMap.find(layer.id) != animationImageMap.end()) {
                    const auto& animFiles = animationImageMap.at(layer.id);
                    int numFrames = (int)animFiles.size();
                    cpp << "            // Slideshow animation - " << numFrames << " images, " << layer.animation_speed << "s per frame\n";
                    cpp << "            {\n";
                    cpp << "                g_AnimTimer_" << layer.id << " += io.DeltaTime;\n";
                    cpp << "                if (g_AnimTimer_" << layer.id << " >= g_AnimSpeed_" << layer.id << ") {\n";
                    cpp << "                    g_AnimTimer_" << layer.id << " = 0.0f;\n";
                    cpp << "                    g_AnimFrame_" << layer.id << " = (g_AnimFrame_" << layer.id << " + 1) % " << numFrames << ";\n";
                    cpp << "                }\n";
                    cpp << "                GLuint tex = g_AnimTex_" << layer.id << "[g_AnimFrame_" << layer.id << "];\n";
                    cpp << "                if (tex) {\n";
                    cpp << "                    dl->AddImage((ImTextureID)(intptr_t)tex, p1, p2);\n";
                    cpp << "                }\n";
                    cpp << "            }\n";
                } else {
                    // Static image
                    int imgIdx = -1;
                    for (size_t i = 0; i < imageMap.size(); i++) {
                        if (imageMap[i].first == layer.image_path) {
                            imgIdx = i;
                            break;
                        }
                    }
                    if (imgIdx >= 0) {
                        cpp << "            if (g_ImageTex_" << imgIdx << ") {\n";
                        cpp << "                dl->AddImage((ImTextureID)(intptr_t)g_ImageTex_" << imgIdx << ", p1, p2);\n";
                        cpp << "            }\n";
                    }
                }
                break;
            }

            case LAYER_TEXT: {
                // Escape the text for C++ string
                std::string escapedText = layer.text;
                size_t pos = 0;
                while ((pos = escapedText.find("\\", pos)) != std::string::npos) {
                    escapedText.replace(pos, 1, "\\\\");
                    pos += 2;
                }
                pos = 0;
                while ((pos = escapedText.find("\"", pos)) != std::string::npos) {
                    escapedText.replace(pos, 1, "\\\"");
                    pos += 2;
                }
                pos = 0;
                while ((pos = escapedText.find("\n", pos)) != std::string::npos) {
                    escapedText.replace(pos, 1, "\\n");
                    pos += 2;
                }

                int fontSize = (int)layer.font_size;
                if (fontSize < 8) fontSize = 16; // default

                ImU32 textCol = ImGui::ColorConvertFloat4ToU32(layer.text_color);
                int r = (int)((textCol >> 0) & 0xFF);
                int g = (int)((textCol >> 8) & 0xFF);
                int b = (int)((textCol >> 16) & 0xFF);
                int a = (int)((textCol >> 24) & 0xFF);

                cpp << "            // Text with font size " << fontSize << "\n";
                cpp << "            {\n";
                cpp << "                ImFont* font = GetFontForSize(" << fontSize << ");\n";
                cpp << "                if (font) ImGui::PushFont(font);\n";
                cpp << "                const char* text = \"" << escapedText << "\";\n";
                cpp << "                ImVec2 textSize = ImGui::CalcTextSize(text);\n";
                cpp << "                // Draw text with wrapping if needed\n";
                cpp << "                if (textSize.x > w && w > 50) {\n";
                cpp << "                    dl->AddText(font, " << fontSize << ".0f, p1, IM_COL32(" << r << ", " << g << ", " << b << ", " << a << "), text, nullptr, w);\n";
                cpp << "                } else {\n";
                cpp << "                    dl->AddText(p1, IM_COL32(" << r << ", " << g << ", " << b << ", " << a << "), text);\n";
                cpp << "                }\n";
                cpp << "                if (font) ImGui::PopFont();\n";
                cpp << "            }\n";
                break;
            }

            case LAYER_BUTTON: {
                ImU32 bgCol = ImGui::ColorConvertFloat4ToU32(layer.bg_color);
                ImU32 textCol = ImGui::ColorConvertFloat4ToU32(layer.text_color);
                ImU32 borderCol = ImGui::ColorConvertFloat4ToU32(layer.border_color);

                std::string escapedText = layer.text;
                size_t pos = 0;
                while ((pos = escapedText.find("\"", pos)) != std::string::npos) {
                    escapedText.replace(pos, 1, "\\\"");
                    pos += 2;
                }

                int fontSize = (int)layer.font_size;
                if (fontSize < 8) fontSize = 14; // default for buttons

                int bgR = (int)((bgCol >> 0) & 0xFF);
                int bgG = (int)((bgCol >> 8) & 0xFF);
                int bgB = (int)((bgCol >> 16) & 0xFF);
                int bgA = (int)((bgCol >> 24) & 0xFF);

                int txtR = (int)((textCol >> 0) & 0xFF);
                int txtG = (int)((textCol >> 8) & 0xFF);
                int txtB = (int)((textCol >> 16) & 0xFF);
                int txtA = (int)((textCol >> 24) & 0xFF);

                int brdR = (int)((borderCol >> 0) & 0xFF);
                int brdG = (int)((borderCol >> 8) & 0xFF);
                int brdB = (int)((borderCol >> 16) & 0xFF);
                int brdA = (int)((borderCol >> 24) & 0xFF);

                cpp << "            // Button with font size " << fontSize << "\n";
                cpp << "            {\n";
                cpp << "                // Background\n";
                cpp << "                dl->AddRectFilled(p1, p2, IM_COL32(" << bgR << ", " << bgG << ", " << bgB << ", " << bgA << "), " << layer.border_radius << ".0f);\n";

                // Add border if visible
                if (layer.border_color.w > 0.01f) {
                    cpp << "                // Border\n";
                    cpp << "                dl->AddRect(p1, p2, IM_COL32(" << brdR << ", " << brdG << ", " << brdB << ", " << brdA << "), " << layer.border_radius << ".0f, 0, " << layer.border_width << ".0f);\n";
                }

                cpp << "                // Centered text\n";
                cpp << "                ImFont* font = GetFontForSize(" << fontSize << ");\n";
                cpp << "                if (font) ImGui::PushFont(font);\n";
                cpp << "                const char* btnText = \"" << escapedText << "\";\n";
                cpp << "                ImVec2 textSize = ImGui::CalcTextSize(btnText);\n";
                cpp << "                ImVec2 textPos(x + (w - textSize.x) / 2.0f, y + (h - textSize.y) / 2.0f);\n";
                cpp << "                dl->AddText(textPos, IM_COL32(" << txtR << ", " << txtG << ", " << txtB << ", " << txtA << "), btnText);\n";
                cpp << "                if (font) ImGui::PopFont();\n";
                cpp << "            }\n";
                break;
            }

            case LAYER_INPUT: {
                // Render input field
                ImU32 bgCol = ImGui::ColorConvertFloat4ToU32(layer.bg_color);
                ImU32 borderCol = ImGui::ColorConvertFloat4ToU32(layer.border_color);
                ImU32 textCol = ImGui::ColorConvertFloat4ToU32(layer.text_color);

                int bgR = (int)((bgCol >> 0) & 0xFF);
                int bgG = (int)((bgCol >> 8) & 0xFF);
                int bgB = (int)((bgCol >> 16) & 0xFF);
                int bgA = (int)((bgCol >> 24) & 0xFF);
                if (bgA < 10) { bgR = 255; bgG = 255; bgB = 255; bgA = 255; } // default white bg

                int brdR = (int)((borderCol >> 0) & 0xFF);
                int brdG = (int)((borderCol >> 8) & 0xFF);
                int brdB = (int)((borderCol >> 16) & 0xFF);
                int brdA = (int)((borderCol >> 24) & 0xFF);
                if (brdA < 10) { brdR = 180; brdG = 180; brdB = 180; brdA = 255; } // default gray border

                int txtR = (int)((textCol >> 0) & 0xFF);
                int txtG = (int)((textCol >> 8) & 0xFF);
                int txtB = (int)((textCol >> 16) & 0xFF);
                int txtA = (int)((textCol >> 24) & 0xFF);

                std::string placeholder = layer.text.empty() ? "Enter text..." : layer.text;
                // Escape
                size_t pos = 0;
                while ((pos = placeholder.find("\"", pos)) != std::string::npos) {
                    placeholder.replace(pos, 1, "\\\"");
                    pos += 2;
                }

                cpp << "            // Input field\n";
                cpp << "            {\n";
                cpp << "                // Background\n";
                cpp << "                dl->AddRectFilled(p1, p2, IM_COL32(" << bgR << ", " << bgG << ", " << bgB << ", " << bgA << "), " << layer.border_radius << ".0f);\n";
                cpp << "                // Border\n";
                cpp << "                dl->AddRect(p1, p2, IM_COL32(" << brdR << ", " << brdG << ", " << brdB << ", " << brdA << "), " << layer.border_radius << ".0f, 0, 1.0f);\n";
                cpp << "                // Placeholder text\n";
                cpp << "                ImVec2 textPos(x + 10.0f, y + (h - 16.0f) / 2.0f);\n";
                cpp << "                dl->AddText(textPos, IM_COL32(" << txtR << ", " << txtG << ", " << txtB << ", 128), \"" << placeholder << "\");\n";
                cpp << "            }\n";
                break;
            }

            case LAYER_DIV:
            default: {
                ImU32 bgCol = ImGui::ColorConvertFloat4ToU32(layer.bg_color);
                ImU32 borderCol = ImGui::ColorConvertFloat4ToU32(layer.border_color);

                int bgR = (int)((bgCol >> 0) & 0xFF);
                int bgG = (int)((bgCol >> 8) & 0xFF);
                int bgB = (int)((bgCol >> 16) & 0xFF);
                int bgA = (int)((bgCol >> 24) & 0xFF);

                int brdR = (int)((borderCol >> 0) & 0xFF);
                int brdG = (int)((borderCol >> 8) & 0xFF);
                int brdB = (int)((borderCol >> 16) & 0xFF);
                int brdA = (int)((borderCol >> 24) & 0xFF);

                if (layer.bg_color.w > 0.01f) {
                    cpp << "            // DIV background\n";
                    cpp << "            dl->AddRectFilled(p1, p2, IM_COL32(" << bgR << ", " << bgG << ", " << bgB << ", " << bgA << "), " << layer.border_radius << ".0f);\n";
                }

                // DIV with animation (slideshow)
                if (layer.enable_animation && animationImageMap.find(layer.id) != animationImageMap.end()) {
                    const auto& animFiles = animationImageMap.at(layer.id);
                    int numFrames = (int)animFiles.size();
                    cpp << "            // DIV slideshow animation - " << numFrames << " images\n";
                    cpp << "            {\n";
                    cpp << "                g_AnimTimer_" << layer.id << " += io.DeltaTime;\n";
                    cpp << "                if (g_AnimTimer_" << layer.id << " >= g_AnimSpeed_" << layer.id << ") {\n";
                    cpp << "                    g_AnimTimer_" << layer.id << " = 0.0f;\n";
                    cpp << "                    g_AnimFrame_" << layer.id << " = (g_AnimFrame_" << layer.id << " + 1) % " << numFrames << ";\n";
                    cpp << "                }\n";
                    cpp << "                GLuint tex = g_AnimTex_" << layer.id << "[g_AnimFrame_" << layer.id << "];\n";
                    cpp << "                if (tex) {\n";
                    cpp << "                    dl->AddImage((ImTextureID)(intptr_t)tex, p1, p2);\n";
                    cpp << "                }\n";
                    cpp << "            }\n";
                }
                // DIV with static image
                else if (!layer.image_path.empty()) {
                    int imgIdx = -1;
                    for (size_t i = 0; i < imageMap.size(); i++) {
                        if (imageMap[i].first == layer.image_path) {
                            imgIdx = i;
                            break;
                        }
                    }
                    if (imgIdx >= 0) {
                        cpp << "            // DIV image\n";
                        cpp << "            if (g_ImageTex_" << imgIdx << ") {\n";
                        cpp << "                dl->AddImage((ImTextureID)(intptr_t)g_ImageTex_" << imgIdx << ", p1, p2);\n";
                        cpp << "            }\n";
                    }
                }

                if (layer.border_color.w > 0.01f && layer.border_width > 0) {
                    cpp << "            // DIV border\n";
                    cpp << "            dl->AddRect(p1, p2, IM_COL32(" << brdR << ", " << brdG << ", " << brdB << ", " << brdA << "), " << layer.border_radius << ".0f, 0, " << layer.border_width << ".0f);\n";
                }
                break;
            }
        }

        cpp << "        }\n";
        cpp << "    }\n\n";
        layerNum++;
    }

    cpp << "}\n\n";

    // Main function
    cpp << "// ============================================================================\n";
    cpp << "// MAIN FUNCTION\n";
    cpp << "// ============================================================================\n";
    cpp << "int main() {\n";
    cpp << "    // Initialize GLFW\n";
    cpp << "    if (!glfwInit()) {\n";
    cpp << "        printf(\"Failed to initialize GLFW\\n\");\n";
    cpp << "        return -1;\n";
    cpp << "    }\n\n";

    cpp << "    // OpenGL 3.3 Core\n";
    cpp << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n";
    cpp << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n";
    cpp << "    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n";
    cpp << "#ifdef __APPLE__\n";
    cpp << "    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n";
    cpp << "#endif\n\n";

    cpp << "    // Create window\n";
    cpp << "    GLFWwindow* window = glfwCreateWindow(1280, 800, \"" << projectName << "\", NULL, NULL);\n";
    cpp << "    if (!window) {\n";
    cpp << "        printf(\"Failed to create window\\n\");\n";
    cpp << "        glfwTerminate();\n";
    cpp << "        return -1;\n";
    cpp << "    }\n";
    cpp << "    glfwMakeContextCurrent(window);\n";
    cpp << "    glfwSwapInterval(1);\n\n";

    cpp << "    // Initialize ImGui\n";
    cpp << "    IMGUI_CHECKVERSION();\n";
    cpp << "    ImGui::CreateContext();\n";
    cpp << "    ImGuiIO& io = ImGui::GetIO();\n";
    cpp << "    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;\n\n";

    cpp << "    // Load fonts at key sizes for accuracy\n";
    cpp << "    g_DefaultFont = io.Fonts->AddFontDefault();\n";
    cpp << "    g_Fonts[13] = g_DefaultFont; // Default size\n";
    cpp << "    // Add a few key font sizes\n";
    cpp << "    ImFontConfig config;\n";
    cpp << "    config.SizePixels = 16.0f; g_Fonts[16] = io.Fonts->AddFontDefault(&config);\n";
    cpp << "    config.SizePixels = 20.0f; g_Fonts[20] = io.Fonts->AddFontDefault(&config);\n";
    cpp << "    config.SizePixels = 24.0f; g_Fonts[24] = io.Fonts->AddFontDefault(&config);\n";
    cpp << "    config.SizePixels = 32.0f; g_Fonts[32] = io.Fonts->AddFontDefault(&config);\n";
    cpp << "    config.SizePixels = 48.0f; g_Fonts[48] = io.Fonts->AddFontDefault(&config);\n\n";

    cpp << "    // Setup Platform/Renderer backends\n";
    cpp << "    ImGui_ImplGlfw_InitForOpenGL(window, true);\n";
    cpp << "    ImGui_ImplOpenGL3_Init(\"#version 330\");\n\n";

    cpp << "    // Load textures\n";
    cpp << "    LoadAllTextures();\n\n";

    cpp << "    // Main loop\n";
    cpp << "    while (!glfwWindowShouldClose(window)) {\n";
    cpp << "        glfwPollEvents();\n\n";

    cpp << "        // Start ImGui frame\n";
    cpp << "        ImGui_ImplOpenGL3_NewFrame();\n";
    cpp << "        ImGui_ImplGlfw_NewFrame();\n";
    cpp << "        ImGui::NewFrame();\n\n";

    cpp << "        // Fullscreen window\n";
    cpp << "        ImGui::SetNextWindowPos(ImVec2(0, 0));\n";
    cpp << "        ImGui::SetNextWindowSize(io.DisplaySize);\n";
    cpp << "        ImGui::Begin(\"##Main\", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar);\n\n";

    cpp << "        RenderWebsite();\n\n";

    cpp << "        ImGui::End();\n\n";

    cpp << "        // Render\n";
    cpp << "        ImGui::Render();\n";
    cpp << "        int display_w, display_h;\n";
    cpp << "        glfwGetFramebufferSize(window, &display_w, &display_h);\n";
    cpp << "        glViewport(0, 0, display_w, display_h);\n";
    cpp << "        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n";
    cpp << "        glClear(GL_COLOR_BUFFER_BIT);\n";
    cpp << "        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n";

    cpp << "        glfwSwapBuffers(window);\n";
    cpp << "    }\n\n";

    cpp << "    // Cleanup\n";
    cpp << "    ImGui_ImplOpenGL3_Shutdown();\n";
    cpp << "    ImGui_ImplGlfw_Shutdown();\n";
    cpp << "    ImGui::DestroyContext();\n";
    cpp << "    glfwDestroyWindow(window);\n";
    cpp << "    glfwTerminate();\n\n";

    cpp << "    return 0;\n";
    cpp << "}\n";

    // Write main.cpp
    std::ofstream mainFile(exportFolder + "/main.cpp");
    mainFile << cpp.str();
    mainFile.close();

    // Generate build script
    std::ofstream buildScript(exportFolder + "/build.sh");
    buildScript << "#!/bin/bash\n\n";
    buildScript << "# Build script for " << projectName << "\n\n";
    buildScript << "echo \"Building " << projectName << "...\"\n\n";
    buildScript << "g++ -std=c++17 -O2 \\\n";
    buildScript << "    main.cpp \\\n";
    buildScript << "    imgui/imgui.cpp \\\n";
    buildScript << "    imgui/imgui_draw.cpp \\\n";
    buildScript << "    imgui/imgui_tables.cpp \\\n";
    buildScript << "    imgui/imgui_widgets.cpp \\\n";
    buildScript << "    imgui/imgui_impl_glfw.cpp \\\n";
    buildScript << "    imgui/imgui_impl_opengl3.cpp \\\n";
    buildScript << "    -I. -Iimgui \\\n";
    buildScript << "    -lglfw -framework OpenGL -framework Cocoa -framework IOKit \\\n";
    buildScript << "    -o " << projectName << "\n\n";
    buildScript << "if [ $? -eq 0 ]; then\n";
    buildScript << "    echo \"Build successful! Run with: ./" << projectName << "\"\n";
    buildScript << "else\n";
    buildScript << "    echo \"Build failed!\"\n";
    buildScript << "fi\n";
    buildScript.close();
    chmod((exportFolder + "/build.sh").c_str(), 0755);

    // Generate README
    std::ofstream readme(exportFolder + "/README.md");
    readme << "# " << projectName << "\n\n";
    readme << "Exported from Website Builder - Figma Style Import\n\n";
    readme << "## Build Instructions\n\n";
    readme << "### Prerequisites\n";
    readme << "- C++17 compiler (g++ or clang++)\n";
    readme << "- GLFW library (`brew install glfw` on macOS)\n\n";
    readme << "### Build\n";
    readme << "```bash\n";
    readme << "chmod +x build.sh\n";
    readme << "./build.sh\n";
    readme << "```\n\n";
    readme << "### Run\n";
    readme << "```bash\n";
    readme << "./" << projectName << "\n";
    readme << "```\n\n";
    readme << "## Project Structure\n";
    readme << "- `main.cpp` - Main application source\n";
    readme << "- `imgui/` - Dear ImGui library\n";
    readme << "- `images/` - Image assets\n";
    readme << "- `build.sh` - Build script\n\n";
    readme << "## Controls\n";
    readme << "- Scroll: Navigate up/down\n";
    readme << "- Close window to exit\n\n";
    readme << "## Stats\n";
    readme << "- Canvas: " << g_FigmaProject.canvas_width << " x " << g_FigmaProject.canvas_height << " pixels\n";
    readme << "- Layers: " << g_FigmaProject.layers.size() << "\n";
    readme << "- Images: " << imageMap.size() << "\n";
    readme.close();

    printf("\n========================================\n");
    printf("[Export Figma] SUCCESS!\n");
    printf("Exported to: %s\n", exportFolder.c_str());
    printf("Layers: %zu\n", g_FigmaProject.layers.size());
    printf("Images: %zu\n", imageMap.size());
    printf("\nTo build:\n");
    printf("  cd \"%s\"\n", exportFolder.c_str());
    printf("  ./build.sh\n");
    printf("  ./%s\n", projectName.c_str());
    printf("========================================\n\n");

    // Show success message in app
    g_ShowExportSuccess = true;
    g_ExportSuccessTimer = 3.0f;
    g_ExportPath = "Figma Export: " + exportFolder;
}

// ============================================================================
// EXPORT TO IMGUI WEBASSEMBLY PROJECT
// ============================================================================
void ExportImGuiWebsite() {
    std::string folder = ChooseFolderDialog("Choose export folder");
    if (folder.empty()) return;
    if (folder.back() == '/') folder.pop_back();

    std::string webFolder = folder + "/" + g_ProjectName + "_ImGui";
    std::string imguiFolder = webFolder + "/imgui";
    std::string backendsFolder = imguiFolder + "/backends";
    mkdir(webFolder.c_str(), 0755);
    mkdir(imguiFolder.c_str(), 0755);
    mkdir(backendsFolder.c_str(), 0755);

    // Copy ImGui files
    std::vector<std::string> imguiFiles = {"imgui.cpp", "imgui.h", "imgui_demo.cpp",
        "imgui_draw.cpp", "imgui_internal.h", "imgui_tables.cpp", "imgui_widgets.cpp",
        "imconfig.h", "imstb_rectpack.h", "imstb_textedit.h", "imstb_truetype.h"};
    for (const auto& f : imguiFiles) {
        std::ifstream src("imgui/" + f, std::ios::binary);
        std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }
    std::vector<std::string> backendFiles = {"imgui_impl_glfw.cpp", "imgui_impl_glfw.h",
        "imgui_impl_opengl3.cpp", "imgui_impl_opengl3.h", "imgui_impl_opengl3_loader.h"};
    for (const auto& f : backendFiles) {
        std::ifstream src("imgui/backends/" + f, std::ios::binary);
        std::ofstream dst(backendsFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }

    // Write generated files
    std::ofstream(webFolder + "/main.cpp") << GenerateImGuiCPP();
    std::ofstream(webFolder + "/build_web.sh") << GenerateBuildScript();
    std::ofstream(webFolder + "/shell.html") << GenerateShellHTML();

    // Copy Inter font header
    {
        std::ifstream src("inter_font.h", std::ios::binary);
        std::ofstream dst(webFolder + "/inter_font.h", std::ios::binary);
        dst << src.rdbuf();
    }

    // Make build script executable
    chmod((webFolder + "/build_web.sh").c_str(), 0755);

    // Create README
    std::ofstream readme(webFolder + "/README.txt");
    readme << "==========================================\n";
    readme << "   " << g_ProjectName << " - ImGui Website\n";
    readme << "==========================================\n\n";
    readme << "This is an ImGui website that runs in the browser via WebAssembly.\n\n";
    readme << "TO BUILD:\n";
    readme << "1. Install Emscripten: https://emscripten.org/docs/getting_started/downloads.html\n";
    readme << "2. Run: ./build_web.sh\n";
    readme << "3. Start server: python3 -m http.server 8080\n";
    readme << "4. Open: http://localhost:8080\n\n";
    readme << "REQUIREMENTS:\n";
    readme << "- Emscripten SDK (emsdk)\n";
    readme << "- Python 3 (for local server)\n";
    readme.close();

    g_ExportPath = webFolder;
    g_ShowExportSuccess = true;
    g_ExportSuccessTimer = 3.0f;

    system(("open \"" + webFolder + "\"").c_str());
}

// Generate ImGui C++ code for Figma layers preview - uses screenshot as background
std::string GenerateFigmaImGuiCPP() {
    std::stringstream ss;

    // Header includes
    ss << "#include \"imgui.h\"\n";
    ss << "#include \"imgui_impl_glfw.h\"\n";
    ss << "#include \"imgui_impl_opengl3.h\"\n";
    ss << "#include <GLFW/glfw3.h>\n";
    ss << "#include <emscripten.h>\n";
    ss << "#include <emscripten/html5.h>\n";
    ss << "#include <cstdio>\n";
    ss << "#include <cmath>\n";
    ss << "#include <string>\n";
    ss << "#include <vector>\n";
    ss << "#include <algorithm>\n";
    ss << "#define STB_IMAGE_IMPLEMENTATION\n";
    ss << "#include \"stb_image.h\"\n\n";

    // Global state
    ss << "static GLFWwindow* g_Window = nullptr;\n";
    ss << "static float g_ScrollY = 0.0f;\n";
    ss << "static float g_TargetScrollY = 0.0f;\n";
    ss << "static float g_ScrollDelta = 0.0f;\n";
    ss << "static float g_CanvasWidth = " << g_FigmaProject.canvas_width << ".0f;\n";
    ss << "static float g_CanvasHeight = " << g_FigmaProject.canvas_height << ".0f;\n";
    ss << "static GLuint g_ScreenshotTexture = 0;\n";
    ss << "static int g_ScreenshotWidth = 0;\n";
    ss << "static int g_ScreenshotHeight = 0;\n\n";

    // JavaScript wheel callback for Mac trackpad support
    ss << "extern \"C\" {\n";
    ss << "    EMSCRIPTEN_KEEPALIVE void js_scroll(float deltaY) {\n";
    ss << "        g_ScrollDelta += deltaY;\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Button structure (only interactive elements)
    ss << "struct Button {\n";
    ss << "    float x, y, width, height;\n";
    ss << "    std::string href;\n";
    ss << "    std::string action_type;\n";
    ss << "    std::string element_id;\n";
    ss << "    float border_radius;\n";
    ss << "};\n\n";

    ss << "static std::vector<Button> g_Buttons;\n\n";

    // Helper to escape strings
    auto escapeStr = [](const std::string& s) -> std::string {
        std::string result;
        for (char c : s) {
            if (c == '\\') result += "\\\\";
            else if (c == '"') result += "\\\"";
            else if (c == '\n') result += "\\n";
            else if (c == '\r') result += "\\r";
            else result += c;
        }
        return result;
    };

    // Helper to format float with decimal point
    auto fmtFloat = [](float v) -> std::string {
        char buf[32];
        snprintf(buf, sizeof(buf), "%.1f", v);
        return std::string(buf) + "f";
    };

    // Initialize buttons function - only buttons/links
    ss << "void InitButtons() {\n";
    ss << "    g_Buttons.clear();\n";

    for (const auto& layer : g_FigmaProject.layers) {
        // Include any element with href (link) or explicit button type
        bool hasHref = !layer.href.empty();
        bool isButton = layer.type == LAYER_BUTTON;
        bool hasAction = !layer.action_type.empty() && layer.action_type != "none";

        if ((hasHref || isButton || hasAction) && !layer.disabled) {
            // Default to "link" if has href but no action_type
            std::string actionType = layer.action_type;
            if (actionType.empty() || actionType == "none") {
                if (hasHref) {
                    if (layer.href[0] == '#') actionType = "scroll";
                    else if (layer.href.find("mailto:") == 0) actionType = "email";
                    else if (layer.href.find("tel:") == 0) actionType = "phone";
                    else actionType = "link";
                } else {
                    actionType = "button";
                }
            }

            ss << "    g_Buttons.push_back({";
            ss << fmtFloat(layer.x) << ", " << fmtFloat(layer.y) << ", ";
            ss << fmtFloat(layer.width) << ", " << fmtFloat(layer.height) << ", ";
            ss << "\"" << escapeStr(layer.href) << "\", ";
            ss << "\"" << escapeStr(actionType) << "\", ";
            ss << "\"" << escapeStr(layer.element_id) << "\", ";
            ss << fmtFloat(layer.border_radius) << "});\n";
        }
    }
    ss << "}\n\n";

    // Load screenshot texture
    ss << "void LoadScreenshot() {\n";
    ss << "    int w, h, n;\n";
    ss << "    unsigned char* data = stbi_load(\"screenshot.png\", &w, &h, &n, 4);\n";
    ss << "    if (data) {\n";
    ss << "        glGenTextures(1, &g_ScreenshotTexture);\n";
    ss << "        glBindTexture(GL_TEXTURE_2D, g_ScreenshotTexture);\n";
    ss << "        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n";
    ss << "        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n";
    ss << "        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n";
    ss << "        g_ScreenshotWidth = w;\n";
    ss << "        g_ScreenshotHeight = h;\n";
    ss << "        stbi_image_free(data);\n";
    ss << "        printf(\"Loaded screenshot: %dx%d\\n\", w, h);\n";
    ss << "    } else {\n";
    ss << "        printf(\"Failed to load screenshot.png\\n\");\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Open URL function
    ss << "void OpenURL(const std::string& url) {\n";
    ss << "    std::string js = \"window.open('\" + url + \"', '_blank');\";\n";
    ss << "    emscripten_run_script(js.c_str());\n";
    ss << "}\n\n";

    // Scroll to element
    ss << "void ScrollToElement(const std::string& elementId) {\n";
    ss << "    for (const auto& btn : g_Buttons) {\n";
    ss << "        if (btn.element_id == elementId) {\n";
    ss << "            g_TargetScrollY = btn.y - 100.0f;\n";
    ss << "            if (g_TargetScrollY < 0) g_TargetScrollY = 0;\n";
    ss << "            return;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Main render function
    ss << "void Render() {\n";
    ss << "    ImGuiIO& io = ImGui::GetIO();\n";
    ss << "    ImDrawList* drawList = ImGui::GetBackgroundDrawList();\n";
    ss << "    \n";
    ss << "    float windowW = io.DisplaySize.x;\n";
    ss << "    float windowH = io.DisplaySize.y;\n";
    ss << "    float scale = windowW / g_CanvasWidth;\n";
    ss << "    float imgH = g_CanvasHeight * scale;\n";
    ss << "    float maxScroll = imgH - windowH;\n";
    ss << "    if (maxScroll < 0) maxScroll = 0;\n";
    ss << "    \n";
    ss << "    // Handle mouse wheel scrolling (from JS callback for Mac trackpad)\n";
    ss << "    if (g_ScrollDelta != 0) {\n";
    ss << "        g_TargetScrollY += g_ScrollDelta;\n";
    ss << "        g_ScrollDelta = 0;\n";
    ss << "    }\n";
    ss << "    // Also check ImGui mouse wheel (for regular mouse)\n";
    ss << "    if (io.MouseWheel != 0) {\n";
    ss << "        g_TargetScrollY -= io.MouseWheel * 80.0f;\n";
    ss << "    }\n";
    ss << "    // Clamp scroll\n";
    ss << "    if (g_TargetScrollY < 0) g_TargetScrollY = 0;\n";
    ss << "    if (g_TargetScrollY > maxScroll) g_TargetScrollY = maxScroll;\n";
    ss << "    // Smooth scroll\n";
    ss << "    g_ScrollY += (g_TargetScrollY - g_ScrollY) * 0.2f;\n";
    ss << "    \n";
    ss << "    // Draw screenshot as background\n";
    ss << "    if (g_ScreenshotTexture) {\n";
    ss << "        ImVec2 p1(0, -g_ScrollY);\n";
    ss << "        ImVec2 p2(windowW, imgH - g_ScrollY);\n";
    ss << "        drawList->AddImage((ImTextureID)(intptr_t)g_ScreenshotTexture, p1, p2);\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    // Process buttons (invisible overlays)\n";
    ss << "    static int hoveredBtn = -1;\n";
    ss << "    hoveredBtn = -1;\n";
    ss << "    \n";
    ss << "    for (size_t i = 0; i < g_Buttons.size(); i++) {\n";
    ss << "        const Button& btn = g_Buttons[i];\n";
    ss << "        \n";
    ss << "        float x = btn.x * scale;\n";
    ss << "        float y = btn.y * scale - g_ScrollY;\n";
    ss << "        float w = btn.width * scale;\n";
    ss << "        float h = btn.height * scale;\n";
    ss << "        float r = btn.border_radius * scale;\n";
    ss << "        \n";
    ss << "        if (y + h < 0 || y > windowH) continue;\n";
    ss << "        \n";
    ss << "        ImVec2 p1(x, y);\n";
    ss << "        ImVec2 p2(x + w, y + h);\n";
    ss << "        \n";
    ss << "        bool isHovered = io.MousePos.x >= p1.x && io.MousePos.x <= p2.x &&\n";
    ss << "                         io.MousePos.y >= p1.y && io.MousePos.y <= p2.y;\n";
    ss << "        \n";
    ss << "        if (isHovered) {\n";
    ss << "            hoveredBtn = i;\n";
    ss << "            // Draw hover highlight\n";
    ss << "            drawList->AddRectFilled(p1, p2, IM_COL32(0, 200, 100, 40), r);\n";
    ss << "            drawList->AddRect(p1, p2, IM_COL32(0, 200, 100, 200), r, 0, 2.0f);\n";
    ss << "            \n";
    ss << "            // Handle click\n";
    ss << "            if (ImGui::IsMouseClicked(0)) {\n";
    ss << "                if (btn.action_type == \"link\" && !btn.href.empty()) {\n";
    ss << "                    OpenURL(btn.href);\n";
    ss << "                } else if (btn.action_type == \"scroll\" && btn.href.length() > 1) {\n";
    ss << "                    std::string anchor = btn.href.substr(1);\n";
    ss << "                    ScrollToElement(anchor);\n";
    ss << "                } else if (btn.action_type == \"email\" || btn.action_type == \"phone\") {\n";
    ss << "                    OpenURL(btn.href);\n";
    ss << "                }\n";
    ss << "            }\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    if (hoveredBtn >= 0) {\n";
    ss << "        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Main loop
    ss << "void main_loop() {\n";
    ss << "    glfwPollEvents();\n";
    ss << "    ImGui_ImplOpenGL3_NewFrame();\n";
    ss << "    ImGui_ImplGlfw_NewFrame();\n";
    ss << "    ImGui::NewFrame();\n";
    ss << "    \n";
    ss << "    glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\n";
    ss << "    glClear(GL_COLOR_BUFFER_BIT);\n";
    ss << "    \n";
    ss << "    Render();\n";
    ss << "    \n";
    ss << "    ImGui::Render();\n";
    ss << "    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n";
    ss << "    glfwSwapBuffers(g_Window);\n";
    ss << "}\n\n";

    // Main function
    ss << "int main() {\n";
    ss << "    if (!glfwInit()) return -1;\n";
    ss << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n";
    ss << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n";
    ss << "    \n";
    ss << "    g_Window = glfwCreateWindow(1280, 800, \"Website Preview\", nullptr, nullptr);\n";
    ss << "    if (!g_Window) { glfwTerminate(); return -1; }\n";
    ss << "    \n";
    ss << "    glfwMakeContextCurrent(g_Window);\n";
    ss << "    glfwSwapInterval(1);\n";
    ss << "    \n";
    ss << "    IMGUI_CHECKVERSION();\n";
    ss << "    ImGui::CreateContext();\n";
    ss << "    ImGuiIO& io = ImGui::GetIO();\n";
    ss << "    \n";
    ss << "    ImGui::StyleColorsDark();\n";
    ss << "    ImGui_ImplGlfw_InitForOpenGL(g_Window, true);\n";
    ss << "    ImGui_ImplOpenGL3_Init(\"#version 300 es\");\n";
    ss << "    \n";
    ss << "    LoadScreenshot();\n";
    ss << "    InitButtons();\n";
    ss << "    \n";
    ss << "    emscripten_set_main_loop(main_loop, 0, 1);\n";
    ss << "    return 0;\n";
    ss << "}\n";

    return ss.str();
}

// Helper to convert LayerType to string
std::string layerTypeToString(LayerType type) {
    switch (type) {
        case LAYER_DIV: return "LAYER_DIV";
        case LAYER_TEXT: return "LAYER_TEXT";
        case LAYER_IMAGE: return "LAYER_IMAGE";
        case LAYER_BUTTON: return "LAYER_BUTTON";
        case LAYER_INPUT: return "LAYER_INPUT";
        case LAYER_VIDEO: return "LAYER_VIDEO";
        case LAYER_ICON: return "LAYER_ICON";
        case LAYER_SHAPE: return "LAYER_SHAPE";
        default: return "LAYER_DIV";
    }
}

// Generate ImGui C++ code for REAL layout rendering (not screenshot)
std::string GenerateFigmaImGuiCPP_RealLayout() {
    std::stringstream ss;

    // Helper to format float
    auto fmtFloat = [](float v) -> std::string {
        char buf[32];
        snprintf(buf, sizeof(buf), "%.1f", v);
        return std::string(buf) + "f";
    };

    // Helper to escape strings
    auto escapeStr = [](const std::string& s) -> std::string {
        std::string result;
        for (char c : s) {
            if (c == '\\') result += "\\\\";
            else if (c == '"') result += "\\\"";
            else if (c == '\n') result += "\\n";
            else if (c == '\r') result += "\\r";
            else result += c;
        }
        return result;
    };

    // Helper to convert ImVec4 to string
    auto imvec4ToString = [](const ImVec4& c) -> std::string {
        char buf[128];
        snprintf(buf, sizeof(buf), "ImVec4(%.3ff, %.3ff, %.3ff, %.3ff)", c.x, c.y, c.z, c.w);
        return std::string(buf);
    };

    // Header includes
    ss << "#include \"imgui.h\"\n";
    ss << "#include \"imgui_impl_glfw.h\"\n";
    ss << "#include \"imgui_impl_opengl3.h\"\n";
    ss << "#include <GLFW/glfw3.h>\n";
    ss << "#include <emscripten.h>\n";
    ss << "#include <cstdio>\n";
    ss << "#include <cmath>\n";
    ss << "#include <string>\n";
    ss << "#include <vector>\n";
    ss << "#define STB_IMAGE_IMPLEMENTATION\n";
    ss << "#include \"stb_image.h\"\n\n";

    // Global state
    ss << "static GLFWwindow* g_Window = nullptr;\n";
    ss << "static float g_ScrollY = 0.0f;\n";
    ss << "static float g_TargetScrollY = 0.0f;\n";
    ss << "static float g_ScrollDelta = 0.0f;\n";
    ss << "static float g_CanvasWidth = " << fmtFloat(g_FigmaProject.canvas_width) << ";\n";
    ss << "static float g_CanvasHeight = " << fmtFloat(g_FigmaProject.canvas_height) << ";\n\n";

    // JavaScript scroll callback
    ss << "extern \"C\" {\n";
    ss << "    EMSCRIPTEN_KEEPALIVE void js_scroll(float deltaY) {\n";
    ss << "        g_ScrollDelta += deltaY;\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Layer structure
    ss << "struct Layer {\n";
    ss << "    int id;\n";
    ss << "    std::string type;\n";
    ss << "    std::string name;\n";
    ss << "    float x, y, width, height;\n";
    ss << "    std::string text;\n";
    ss << "    std::string href;\n";
    ss << "    std::string action_type;\n";
    ss << "    ImVec4 bg_color;\n";
    ss << "    ImVec4 text_color;\n";
    ss << "    float font_size;\n";
    ss << "    float border_radius;\n";
    ss << "    float opacity;\n";
    ss << "    std::string image_path;\n";
    ss << "    GLuint texture_id;\n";
    ss << "    int img_w, img_h;\n";
    ss << "};\n\n";

    ss << "static std::vector<Layer> g_Layers;\n\n";

    // Open URL function
    ss << "void OpenURL(const std::string& url) {\n";
    ss << "    std::string js = \"window.open('\" + url + \"', '_blank');\";\n";
    ss << "    emscripten_run_script(js.c_str());\n";
    ss << "}\n\n";

    // Scroll to section
    ss << "void ScrollToSection(const std::string& sectionId) {\n";
    ss << "    for (const auto& layer : g_Layers) {\n";
    ss << "        if (layer.name == sectionId) {\n";
    ss << "            g_TargetScrollY = layer.y - 50.0f;\n";
    ss << "            if (g_TargetScrollY < 0) g_TargetScrollY = 0;\n";
    ss << "            return;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Load image texture
    ss << "GLuint LoadTexture(const char* path, int* w, int* h) {\n";
    ss << "    int n;\n";
    ss << "    unsigned char* data = stbi_load(path, w, h, &n, 4);\n";
    ss << "    if (!data) return 0;\n";
    ss << "    GLuint tex;\n";
    ss << "    glGenTextures(1, &tex);\n";
    ss << "    glBindTexture(GL_TEXTURE_2D, tex);\n";
    ss << "    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n";
    ss << "    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n";
    ss << "    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, *w, *h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n";
    ss << "    stbi_image_free(data);\n";
    ss << "    return tex;\n";
    ss << "}\n\n";

    // Initialize layers
    ss << "void InitLayers() {\n";
    ss << "    g_Layers.clear();\n";

    for (const auto& layer : g_FigmaProject.layers) {
        ss << "    g_Layers.push_back({";
        ss << layer.id << ", ";
        ss << "\"" << escapeStr(layerTypeToString(layer.type)) << "\", ";
        ss << "\"" << escapeStr(layer.name) << "\", ";
        ss << fmtFloat(layer.x) << ", " << fmtFloat(layer.y) << ", ";
        ss << fmtFloat(layer.width) << ", " << fmtFloat(layer.height) << ", ";
        ss << "\"" << escapeStr(layer.text) << "\", ";
        ss << "\"" << escapeStr(layer.href) << "\", ";
        ss << "\"" << escapeStr(layer.action_type) << "\", ";
        ss << imvec4ToString(layer.bg_color) << ", ";
        ss << imvec4ToString(layer.text_color) << ", ";
        ss << fmtFloat(layer.font_size) << ", ";
        ss << fmtFloat(layer.border_radius) << ", ";
        ss << fmtFloat(layer.opacity) << ", ";
        ss << "\"" << escapeStr(layer.image_path) << "\", ";
        ss << "0, 0, 0});\n";
    }
    ss << "}\n\n";

    // Load textures for images
    ss << "void LoadTextures() {\n";
    ss << "    for (auto& layer : g_Layers) {\n";
    ss << "        if (!layer.image_path.empty()) {\n";
    ss << "            layer.texture_id = LoadTexture(layer.image_path.c_str(), &layer.img_w, &layer.img_h);\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Render function
    ss << "void Render() {\n";
    ss << "    ImGuiIO& io = ImGui::GetIO();\n";
    ss << "    ImDrawList* dl = ImGui::GetBackgroundDrawList();\n";
    ss << "    \n";
    ss << "    float winW = io.DisplaySize.x;\n";
    ss << "    float winH = io.DisplaySize.y;\n";
    ss << "    float scale = winW / g_CanvasWidth;\n";
    ss << "    float contentH = g_CanvasHeight * scale;\n";
    ss << "    float maxScroll = contentH - winH;\n";
    ss << "    if (maxScroll < 0) maxScroll = 0;\n";
    ss << "    \n";
    ss << "    // Handle scrolling\n";
    ss << "    if (g_ScrollDelta != 0) {\n";
    ss << "        g_TargetScrollY += g_ScrollDelta;\n";
    ss << "        g_ScrollDelta = 0;\n";
    ss << "    }\n";
    ss << "    if (io.MouseWheel != 0) {\n";
    ss << "        g_TargetScrollY -= io.MouseWheel * 60.0f;\n";
    ss << "    }\n";
    ss << "    if (g_TargetScrollY < 0) g_TargetScrollY = 0;\n";
    ss << "    if (g_TargetScrollY > maxScroll) g_TargetScrollY = maxScroll;\n";
    ss << "    g_ScrollY += (g_TargetScrollY - g_ScrollY) * 0.15f;\n";
    ss << "    \n";
    ss << "    static int hoveredLayer = -1;\n";
    ss << "    hoveredLayer = -1;\n";
    ss << "    \n";
    ss << "    // Render layers\n";
    ss << "    for (size_t i = 0; i < g_Layers.size(); i++) {\n";
    ss << "        const Layer& L = g_Layers[i];\n";
    ss << "        \n";
    ss << "        float x = L.x * scale;\n";
    ss << "        float y = L.y * scale - g_ScrollY;\n";
    ss << "        float w = L.width * scale;\n";
    ss << "        float h = L.height * scale;\n";
    ss << "        float r = L.border_radius * scale;\n";
    ss << "        \n";
    ss << "        // Skip if off-screen\n";
    ss << "        if (y + h < 0 || y > winH) continue;\n";
    ss << "        \n";
    ss << "        ImVec2 p1(x, y);\n";
    ss << "        ImVec2 p2(x + w, y + h);\n";
    ss << "        \n";
    ss << "        // Draw background\n";
    ss << "        if (L.bg_color.w > 0.01f) {\n";
    ss << "            ImU32 bgCol = ImGui::ColorConvertFloat4ToU32(ImVec4(L.bg_color.x, L.bg_color.y, L.bg_color.z, L.bg_color.w * L.opacity));\n";
    ss << "            dl->AddRectFilled(p1, p2, bgCol, r);\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        // Draw image if present\n";
    ss << "        if (L.texture_id > 0) {\n";
    ss << "            dl->AddImage((ImTextureID)(intptr_t)L.texture_id, p1, p2);\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        // Draw text\n";
    ss << "        if (!L.text.empty() && L.type != \"LAYER_IMAGE\") {\n";
    ss << "            float fontSize = L.font_size * scale;\n";
    ss << "            if (fontSize < 8) fontSize = 8;\n";
    ss << "            if (fontSize > 48) fontSize = 48;\n";
    ss << "            ImU32 textCol = ImGui::ColorConvertFloat4ToU32(L.text_color);\n";
    ss << "            ImVec2 textPos(x + 4, y + (h - fontSize) * 0.5f);\n";
    ss << "            dl->AddText(NULL, fontSize, textPos, textCol, L.text.c_str());\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        // Check hover for clickable elements\n";
    ss << "        bool isClickable = !L.href.empty() || L.type == \"LAYER_BUTTON\";\n";
    ss << "        if (isClickable) {\n";
    ss << "            bool isHovered = io.MousePos.x >= p1.x && io.MousePos.x <= p2.x &&\n";
    ss << "                             io.MousePos.y >= p1.y && io.MousePos.y <= p2.y;\n";
    ss << "            if (isHovered) {\n";
    ss << "                hoveredLayer = i;\n";
    ss << "                // Hover effect\n";
    ss << "                dl->AddRectFilled(p1, p2, IM_COL32(255, 255, 255, 30), r);\n";
    ss << "                dl->AddRect(p1, p2, IM_COL32(0, 150, 255, 200), r, 0, 2.0f);\n";
    ss << "                \n";
    ss << "                // Handle click\n";
    ss << "                if (ImGui::IsMouseClicked(0)) {\n";
    ss << "                    if (L.action_type == \"scroll\" && L.href.length() > 1) {\n";
    ss << "                        ScrollToSection(L.href.substr(1));\n";
    ss << "                    } else if (!L.href.empty()) {\n";
    ss << "                        OpenURL(L.href);\n";
    ss << "                    }\n";
    ss << "                }\n";
    ss << "            }\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    if (hoveredLayer >= 0) {\n";
    ss << "        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);\n";
    ss << "    }\n";
    ss << "}\n\n";

    // Main loop
    ss << "void main_loop() {\n";
    ss << "    glfwPollEvents();\n";
    ss << "    ImGui_ImplOpenGL3_NewFrame();\n";
    ss << "    ImGui_ImplGlfw_NewFrame();\n";
    ss << "    ImGui::NewFrame();\n";
    ss << "    \n";
    ss << "    glClearColor(0.95f, 0.95f, 0.95f, 1.0f);\n";
    ss << "    glClear(GL_COLOR_BUFFER_BIT);\n";
    ss << "    \n";
    ss << "    Render();\n";
    ss << "    \n";
    ss << "    ImGui::Render();\n";
    ss << "    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n";
    ss << "    glfwSwapBuffers(g_Window);\n";
    ss << "}\n\n";

    // Main function
    ss << "int main() {\n";
    ss << "    if (!glfwInit()) return -1;\n";
    ss << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n";
    ss << "    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n";
    ss << "    \n";
    ss << "    g_Window = glfwCreateWindow(1280, 800, \"Website Preview\", nullptr, nullptr);\n";
    ss << "    if (!g_Window) { glfwTerminate(); return -1; }\n";
    ss << "    \n";
    ss << "    glfwMakeContextCurrent(g_Window);\n";
    ss << "    glfwSwapInterval(1);\n";
    ss << "    \n";
    ss << "    IMGUI_CHECKVERSION();\n";
    ss << "    ImGui::CreateContext();\n";
    ss << "    ImGui::StyleColorsDark();\n";
    ss << "    ImGui_ImplGlfw_InitForOpenGL(g_Window, true);\n";
    ss << "    ImGui_ImplOpenGL3_Init(\"#version 300 es\");\n";
    ss << "    \n";
    ss << "    InitLayers();\n";
    ss << "    LoadTextures();\n";
    ss << "    \n";
    ss << "    emscripten_set_main_loop(main_loop, 0, 1);\n";
    ss << "    return 0;\n";
    ss << "}\n";

    return ss.str();
}

// Preview Figma layers in browser using REAL ImGui layout
void PreviewFigmaWebsiteRealLayout() {
    if (g_FigmaProject.layers.empty()) {
        printf("[Preview] ERROR: No layers to preview!\n");
        return;
    }

    printf("\n========================================\n");
    printf("[RealLayout] Starting preview with %zu layers\n", g_FigmaProject.layers.size());
    printf("========================================\n\n");

    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    std::string tmp = "/tmp/figma_real_preview";
    std::string imguiFolder = tmp + "/imgui";
    std::string backendsFolder = imguiFolder + "/backends";
    std::string imagesFolder = tmp + "/images";

    // Create directories
    system(("rm -rf \"" + tmp + "\"").c_str());
    mkdir(tmp.c_str(), 0755);
    mkdir(imguiFolder.c_str(), 0755);
    mkdir(backendsFolder.c_str(), 0755);
    mkdir(imagesFolder.c_str(), 0755);

    // Copy ImGui files
    std::vector<std::string> imguiFiles = {"imgui.cpp", "imgui.h", "imgui_demo.cpp",
        "imgui_draw.cpp", "imgui_internal.h", "imgui_tables.cpp", "imgui_widgets.cpp",
        "imconfig.h", "imstb_rectpack.h", "imstb_textedit.h", "imstb_truetype.h"};
    for (const auto& f : imguiFiles) {
        std::ifstream src(basePath + "imgui/" + f, std::ios::binary);
        std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }
    std::vector<std::string> backendFiles = {"imgui_impl_glfw.cpp", "imgui_impl_glfw.h",
        "imgui_impl_opengl3.cpp", "imgui_impl_opengl3.h", "imgui_impl_opengl3_loader.h"};
    for (const auto& f : backendFiles) {
        std::ifstream src(basePath + "imgui/backends/" + f, std::ios::binary);
        std::ofstream dst(backendsFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }

    // Copy stb_image.h
    {
        std::ifstream src(basePath + "stb_image.h", std::ios::binary);
        std::ofstream dst(tmp + "/stb_image.h", std::ios::binary);
        dst << src.rdbuf();
    }

    // Copy images
    for (const auto& layer : g_FigmaProject.layers) {
        if (!layer.image_path.empty()) {
            std::string srcPath = basePath + layer.image_path;
            std::string dstPath = tmp + "/" + layer.image_path;
            // Create subdirs if needed
            size_t pos = dstPath.rfind('/');
            if (pos != std::string::npos) {
                std::string dir = dstPath.substr(0, pos);
                system(("mkdir -p \"" + dir + "\"").c_str());
            }
            std::ifstream src(srcPath, std::ios::binary);
            std::ofstream dst(dstPath, std::ios::binary);
            dst << src.rdbuf();
        }
    }

    // Generate main.cpp
    std::ofstream mainFile(tmp + "/main.cpp");
    mainFile << GenerateFigmaImGuiCPP_RealLayout();
    mainFile.close();

    // Generate build script
    std::ofstream buildScript(tmp + "/build_web.sh");
    buildScript << "#!/bin/bash\n";
    buildScript << "source ~/emsdk/emsdk_env.sh 2>/dev/null || source /opt/emsdk/emsdk_env.sh 2>/dev/null\n";
    buildScript << "em++ -O2 -o index.html main.cpp \\\n";
    buildScript << "    imgui/imgui.cpp imgui/imgui_draw.cpp imgui/imgui_tables.cpp imgui/imgui_widgets.cpp \\\n";
    buildScript << "    imgui/backends/imgui_impl_glfw.cpp imgui/backends/imgui_impl_opengl3.cpp \\\n";
    buildScript << "    -I. -Iimgui -Iimgui/backends \\\n";
    buildScript << "    -s USE_GLFW=3 -s USE_WEBGL2=1 -s FULL_ES3=1 \\\n";
    buildScript << "    -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 \\\n";
    buildScript << "    -s EXPORTED_FUNCTIONS='[\"_main\",\"_js_scroll\"]' \\\n";
    buildScript << "    -s EXPORTED_RUNTIME_METHODS='[\"ccall\",\"cwrap\"]' \\\n";
    buildScript << "    --preload-file images \\\n";
    buildScript << "    --shell-file shell.html\n";
    buildScript.close();
    chmod((tmp + "/build_web.sh").c_str(), 0755);

    // Generate shell.html
    std::ofstream shellFile(tmp + "/shell.html");
    shellFile << "<!DOCTYPE html>\n<html>\n<head>\n";
    shellFile << "<meta charset=\"utf-8\">\n";
    shellFile << "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    shellFile << "<title>Website Preview - Real Layout</title>\n";
    shellFile << "<style>\n";
    shellFile << "* { margin: 0; padding: 0; box-sizing: border-box; }\n";
    shellFile << "html, body { width: 100%; height: 100%; overflow: hidden; background: #f5f5f5; }\n";
    shellFile << "canvas { display: block; width: 100vw !important; height: 100vh !important; }\n";
    shellFile << "</style>\n";
    shellFile << "</head>\n<body>\n";
    shellFile << "<canvas id=\"canvas\" oncontextmenu=\"event.preventDefault()\"></canvas>\n";
    shellFile << "<script>\n";
    shellFile << "var Module = {\n";
    shellFile << "    canvas: document.getElementById('canvas'),\n";
    shellFile << "    onRuntimeInitialized: function() {\n";
    shellFile << "        console.log('Real Layout Preview Ready!');\n";
    shellFile << "        document.getElementById('canvas').addEventListener('wheel', function(e) {\n";
    shellFile << "            e.preventDefault();\n";
    shellFile << "            if (Module._js_scroll) Module._js_scroll(e.deltaY);\n";
    shellFile << "        }, { passive: false });\n";
    shellFile << "    }\n";
    shellFile << "};\n";
    shellFile << "</script>\n";
    shellFile << "{{{ SCRIPT }}}\n";
    shellFile << "</body>\n</html>\n";
    shellFile.close();

    // Build
    printf("[RealLayout] Building WebAssembly...\n");
    std::string buildCmd = "cd \"" + tmp + "\" && ./build_web.sh 2>&1";
    int result = system(buildCmd.c_str());

    if (result == 0) {
        printf("[RealLayout] Build successful! Starting server...\n");
        system("lsof -ti:8082 | xargs kill -9 2>/dev/null");
        sleep(1);
        std::string serveCmd = "cd \"" + tmp + "\" && python3 -m http.server 8082 > /dev/null 2>&1 &";
        system(serveCmd.c_str());
        sleep(2);
        system("open -na 'Google Chrome' --args 'http://localhost:8082/index.html'");
        printf("[RealLayout] Preview opened in Chrome!\n");
    } else {
        printf("[RealLayout] ERROR: Build failed!\n");
    }
}

// Simple HTML preview - generates static HTML and opens in Chrome (no build required)
void PreviewFigmaAsHTML() {
    if (g_FigmaProject.layers.empty()) {
        printf("[HTMLPreview] ERROR: No layers to preview!\n");
        return;
    }

    printf("\n========================================\n");
    printf("[HTMLPreview] Generating HTML preview with %zu layers\n", g_FigmaProject.layers.size());
    printf("========================================\n\n");

    std::string tmp = "/private/tmp/figma_website_preview";
    std::string imagesFolder = tmp + "/images";

    // Create directories
    system(("mkdir -p \"" + imagesFolder + "\"").c_str());

    // Copy images
    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    for (const auto& layer : g_FigmaProject.layers) {
        if (!layer.image_path.empty() && layer.type == LAYER_IMAGE) {
            std::string srcPath = layer.image_path;
            // Handle relative paths
            if (!srcPath.empty() && srcPath[0] != '/') {
                srcPath = basePath + srcPath;
            }

            // Get just the filename
            size_t lastSlash = layer.image_path.rfind('/');
            std::string filename = (lastSlash != std::string::npos) ?
                layer.image_path.substr(lastSlash + 1) : layer.image_path;

            std::string dstPath = imagesFolder + "/" + filename;

            // Copy file
            std::ifstream src(srcPath, std::ios::binary);
            if (src.good()) {
                std::ofstream dst(dstPath, std::ios::binary);
                dst << src.rdbuf();
            }
        }
    }

    // Generate HTML
    std::ofstream html(tmp + "/index.html");
    html << "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n";
    html << "<meta charset=\"UTF-8\">\n";
    html << "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    html << "<title>" << g_FigmaProject.name << " - Preview</title>\n";
    html << "<style>\n";
    html << "* { margin: 0; padding: 0; box-sizing: border-box; }\n";
    html << "body { background: #f5f5f5; min-height: 100vh; }\n";
    html << ".canvas { position: relative; width: " << (int)g_FigmaProject.canvas_width << "px; ";
    html << "min-height: " << (int)g_FigmaProject.canvas_height << "px; ";
    html << "background: #ffffff; margin: 0 auto; overflow: hidden; }\n";
    html << ".layer { box-sizing: border-box; position: absolute; }\n";
    html << ".button-layer { display: flex; align-items: center; justify-content: center; ";
    html << "text-decoration: none; cursor: pointer; transition: opacity 0.2s; }\n";
    html << ".button-layer:hover { opacity: 0.85; }\n";
    html << ".image-layer { object-fit: cover; }\n";
    html << ".text-layer { overflow: hidden; white-space: pre-wrap; }\n";
    html << ".div-layer { overflow: hidden; }\n";
    html << "</style>\n</head>\n<body>\n<div class=\"canvas\">\n";

    // Sort layers by z-index for proper rendering order
    // For same z-index, larger layers (containers) render first, smaller on top
    std::vector<WebLayer> sortedLayers = g_FigmaProject.layers;
    std::sort(sortedLayers.begin(), sortedLayers.end(), [](const WebLayer& a, const WebLayer& b) {
        if (a.z_index != b.z_index) return a.z_index < b.z_index;
        // Same z_index: larger area first (background)
        float areaA = a.width * a.height;
        float areaB = b.width * b.height;
        return areaA > areaB;
    });

    // Track rendered text to avoid duplicates
    std::set<std::string> renderedTexts;

    // Generate layer HTML
    for (const auto& layer : sortedLayers) {
        if (!layer.visible) continue;

        // Skip full-page container layers (body, html, root)
        bool isFullPageContainer = (layer.name.find("body") != std::string::npos ||
                                    layer.name == "html" || layer.name == "root") &&
                                   layer.width >= g_FigmaProject.canvas_width * 0.95f &&
                                   layer.height >= g_FigmaProject.canvas_height * 0.5f;
        if (isFullPageContainer && layer.type == LAYER_DIV) continue;

        // Skip duplicate text content
        if (layer.type == LAYER_TEXT && !layer.text.empty()) {
            std::string textKey = layer.text + "_" + std::to_string((int)layer.y);
            if (renderedTexts.count(textKey) > 0) continue;
            renderedTexts.insert(textKey);
        }

        std::ostringstream style;
        style << "left:" << (int)layer.x << "px;";
        style << "top:" << (int)layer.y << "px;";
        style << "width:" << (int)layer.width << "px;";
        style << "height:" << (int)layer.height << "px;";
        style << "z-index:" << (layer.z_index > 0 ? layer.z_index : layer.id) << ";";

        if (layer.bg_color.w > 0.01f) {
            style << "background-color:rgba("
                  << (int)(layer.bg_color.x * 255) << ","
                  << (int)(layer.bg_color.y * 255) << ","
                  << (int)(layer.bg_color.z * 255) << ","
                  << layer.bg_color.w << ");";
        }

        if (layer.text_color.w > 0) {
            style << "color:rgba("
                  << (int)(layer.text_color.x * 255) << ","
                  << (int)(layer.text_color.y * 255) << ","
                  << (int)(layer.text_color.z * 255) << ","
                  << layer.text_color.w << ");";
        }

        style << "font-size:" << (int)layer.font_size << "px;";
        if (layer.font_weight > 400) style << "font-weight:" << (int)layer.font_weight << ";";
        if (!layer.font_family.empty()) style << "font-family:" << layer.font_family << ";";
        if (layer.border_radius > 0) style << "border-radius:" << (int)layer.border_radius << "px;";
        if (layer.border_width > 0) {
            style << "border:" << (int)layer.border_width << "px solid rgba("
                  << (int)(layer.border_color.x * 255) << ","
                  << (int)(layer.border_color.y * 255) << ","
                  << (int)(layer.border_color.z * 255) << ","
                  << layer.border_color.w << ");";
        }
        if (layer.opacity < 1.0f) style << "opacity:" << layer.opacity << ";";
        if (!layer.box_shadow.empty() && layer.box_shadow != "none") {
            style << "box-shadow:" << layer.box_shadow << ";";
        }

        std::string id = layer.element_id.empty() ? ("layer_" + std::to_string(layer.id)) : layer.element_id;

        // Clean text - decode unicode escapes and HTML entities
        auto cleanText = [](const std::string& text) -> std::string {
            std::string result = text;
            // Replace common unicode escapes
            size_t pos;
            while ((pos = result.find("\\u00a0")) != std::string::npos) {
                result.replace(pos, 6, " ");  // Non-breaking space to regular space
            }
            while ((pos = result.find("\\u0024")) != std::string::npos) {
                result.replace(pos, 6, "$");  // Dollar sign
            }
            // Escape HTML special characters
            std::string escaped;
            for (char c : result) {
                switch (c) {
                    case '<': escaped += "&lt;"; break;
                    case '>': escaped += "&gt;"; break;
                    case '&': escaped += "&amp;"; break;
                    case '"': escaped += "&quot;"; break;
                    default: escaped += c;
                }
            }
            return escaped;
        };

        std::string displayText = cleanText(layer.text);

        if (layer.type == LAYER_IMAGE && !layer.image_path.empty()) {
            size_t lastSlash = layer.image_path.rfind('/');
            std::string filename = (lastSlash != std::string::npos) ?
                layer.image_path.substr(lastSlash + 1) : layer.image_path;

            html << "<img id=\"" << id << "\" class=\"layer image-layer\" src=\"images/" << filename
                 << "\" style=\"" << style.str() << "\" alt=\"\"/>\n";
        }
        else if (layer.type == LAYER_TEXT) {
            html << "<div id=\"" << id << "\" class=\"layer text-layer\" style=\"" << style.str() << "\">"
                 << displayText << "</div>\n";
        }
        else if (layer.type == LAYER_BUTTON) {
            if (!layer.href.empty() && layer.href.find("http") == 0) {
                html << "<a id=\"" << id << "\" class=\"layer button-layer\" href=\"" << layer.href
                     << "\" target=\"_blank\" style=\"" << style.str() << "\">" << displayText << "</a>\n";
            } else {
                html << "<button id=\"" << id << "\" class=\"layer button-layer\" style=\"" << style.str()
                     << "\">" << displayText << "</button>\n";
            }
        }
        else if (layer.type == LAYER_INPUT) {
            html << "<input id=\"" << id << "\" class=\"layer input-layer\" placeholder=\"" << displayText
                 << "\" style=\"" << style.str() << "\"/>\n";
        }
        else {
            // DIV
            html << "<div id=\"" << id << "\" class=\"layer div-layer\" style=\"" << style.str() << "\"></div>\n";
        }
    }

    html << "</div>\n";
    html << "<script>\n";
    html << "document.querySelectorAll('a[href^=\"#\"]').forEach(anchor => {\n";
    html << "  anchor.addEventListener('click', function(e) {\n";
    html << "    const target = document.getElementById(this.getAttribute('href').substring(1));\n";
    html << "    if (target) { e.preventDefault(); target.scrollIntoView({behavior:'smooth'}); }\n";
    html << "  });\n";
    html << "});\n";
    html << "// Block external links - stay in template\n";
    html << "document.querySelectorAll('a[href^=\"http\"]').forEach(link => {\n";
    html << "  link.addEventListener('click', function(e) {\n";
    html << "    e.preventDefault();\n";
    html << "    const href = this.getAttribute('href');\n";
    html << "    if (href.includes('#')) {\n";
    html << "      const hash = href.split('#')[1];\n";
    html << "      const target = document.getElementById(hash);\n";
    html << "      if (target) { target.scrollIntoView({behavior:'smooth'}); return; }\n";
    html << "    }\n";
    html << "    const linkText = this.textContent.trim().toLowerCase();\n";
    html << "    const sections = ['home','about','services','contact','portfolio','features','pricing','team','blog','faq'];\n";
    html << "    for (const sec of sections) {\n";
    html << "      if (linkText.includes(sec)) {\n";
    html << "        let target = document.getElementById(sec) || document.querySelector('.'+sec);\n";
    html << "        if (target) { target.scrollIntoView({behavior:'smooth'}); return; }\n";
    html << "      }\n";
    html << "    }\n";
    html << "    this.style.outline = '2px solid #4CAF50';\n";
    html << "    setTimeout(() => { this.style.outline = ''; }, 500);\n";
    html << "  });\n";
    html << "});\n";
    html << "document.querySelectorAll('button').forEach(btn => {\n";
    html << "  btn.addEventListener('click', function(e) {\n";
    html << "    e.preventDefault();\n";
    html << "    this.style.transform = 'scale(0.95)';\n";
    html << "    setTimeout(() => { this.style.transform = ''; }, 150);\n";
    html << "  });\n";
    html << "});\n";
    html << "</script>\n</body>\n</html>\n";
    html.close();

    printf("[HTMLPreview] HTML file generated: %s/index.html\n", tmp.c_str());

    // Kill existing server and start new one
    system("lsof -ti:8083 | xargs kill -9 2>/dev/null");
    sleep(1);
    std::string serveCmd = "cd \"" + tmp + "\" && python3 -m http.server 8083 > /dev/null 2>&1 &";
    system(serveCmd.c_str());
    sleep(1);

    // Open in Chrome
    system("open -na 'Google Chrome' --args 'http://localhost:8083/index.html'");
    printf("[HTMLPreview] Preview opened in Chrome at http://localhost:8083/\n");
}

// Preview Figma layers in browser using ImGui WebAssembly
void PreviewFigmaWebsite() {
    if (g_FigmaProject.layers.empty()) {
        printf("[Preview] ERROR: No layers to preview!\n");
        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Error: No layers to preview! Import a website first.";
        return;
    }

    printf("\n========================================\n");
    printf("[FigmaPreview] Starting preview with %zu layers\n", g_FigmaProject.layers.size());
    printf("========================================\n\n");

    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    std::string tmp = "/tmp/figma_website_preview";
    std::string imguiFolder = tmp + "/imgui";
    std::string backendsFolder = imguiFolder + "/backends";

    // Create directories
    system(("rm -rf \"" + tmp + "\"").c_str());
    mkdir(tmp.c_str(), 0755);
    mkdir(imguiFolder.c_str(), 0755);
    mkdir(backendsFolder.c_str(), 0755);

    // Copy ImGui files
    std::vector<std::string> imguiFiles = {"imgui.cpp", "imgui.h", "imgui_demo.cpp",
        "imgui_draw.cpp", "imgui_internal.h", "imgui_tables.cpp", "imgui_widgets.cpp",
        "imconfig.h", "imstb_rectpack.h", "imstb_textedit.h", "imstb_truetype.h"};
    for (const auto& f : imguiFiles) {
        std::ifstream src(basePath + "imgui/" + f, std::ios::binary);
        std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }
    std::vector<std::string> backendFiles = {"imgui_impl_glfw.cpp", "imgui_impl_glfw.h",
        "imgui_impl_opengl3.cpp", "imgui_impl_opengl3.h", "imgui_impl_opengl3_loader.h"};
    for (const auto& f : backendFiles) {
        std::ifstream src(basePath + "imgui/backends/" + f, std::ios::binary);
        std::ofstream dst(backendsFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }

    // Copy helper files
    {
        std::ifstream src(basePath + "stb_image.h", std::ios::binary);
        std::ofstream dst(tmp + "/stb_image.h", std::ios::binary);
        dst << src.rdbuf();
    }

    // Copy screenshot image
    if (!g_FigmaProject.screenshot_path.empty()) {
        std::string screenshotSrc = g_FigmaProject.screenshot_path;
        // If relative path, prepend base path
        if (screenshotSrc[0] != '/') {
            screenshotSrc = basePath + screenshotSrc;
        }
        std::ifstream src(screenshotSrc, std::ios::binary);
        std::ofstream dst(tmp + "/screenshot.png", std::ios::binary);
        dst << src.rdbuf();
        printf("[FigmaPreview] Copied screenshot from: %s\n", screenshotSrc.c_str());
    }

    // Generate main.cpp
    std::ofstream mainFile(tmp + "/main.cpp");
    mainFile << GenerateFigmaImGuiCPP();
    mainFile.close();

    // Generate build script
    std::ofstream buildScript(tmp + "/build_web.sh");
    buildScript << "#!/bin/bash\n";
    buildScript << "source ~/emsdk/emsdk_env.sh 2>/dev/null || source /opt/emsdk/emsdk_env.sh 2>/dev/null\n";
    buildScript << "em++ -O2 -o index.html main.cpp \\\n";
    buildScript << "    imgui/imgui.cpp imgui/imgui_draw.cpp imgui/imgui_tables.cpp imgui/imgui_widgets.cpp \\\n";
    buildScript << "    imgui/backends/imgui_impl_glfw.cpp imgui/backends/imgui_impl_opengl3.cpp \\\n";
    buildScript << "    -I. -Iimgui -Iimgui/backends \\\n";
    buildScript << "    -s USE_GLFW=3 -s USE_WEBGL2=1 -s FULL_ES3=1 \\\n";
    buildScript << "    -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 \\\n";
    buildScript << "    -s EXPORTED_FUNCTIONS='[\"_main\",\"_js_scroll\"]' \\\n";
    buildScript << "    -s EXPORTED_RUNTIME_METHODS='[\"ccall\",\"cwrap\"]' \\\n";
    buildScript << "    --preload-file screenshot.png \\\n";
    buildScript << "    --shell-file shell.html\n";
    buildScript.close();
    chmod((tmp + "/build_web.sh").c_str(), 0755);

    // Generate shell.html with Mac trackpad scroll support
    std::ofstream shellFile(tmp + "/shell.html");
    shellFile << "<!DOCTYPE html>\n<html>\n<head>\n";
    shellFile << "<meta charset=\"utf-8\">\n";
    shellFile << "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    shellFile << "<title>Website Preview</title>\n";
    shellFile << "<style>\n";
    shellFile << "* { margin: 0; padding: 0; box-sizing: border-box; }\n";
    shellFile << "html, body { width: 100%; height: 100%; overflow: hidden; background: #fff; }\n";
    shellFile << "canvas { display: block; width: 100vw !important; height: 100vh !important; }\n";
    shellFile << "</style>\n";
    shellFile << "</head>\n<body>\n";
    shellFile << "<canvas id=\"canvas\" oncontextmenu=\"event.preventDefault()\"></canvas>\n";
    shellFile << "<script>\n";
    shellFile << "var Module = {\n";
    shellFile << "    canvas: document.getElementById('canvas'),\n";
    shellFile << "    onRuntimeInitialized: function() {\n";
    shellFile << "        console.log('Ready!');\n";
    shellFile << "        // Mac trackpad scroll support\n";
    shellFile << "        document.getElementById('canvas').addEventListener('wheel', function(e) {\n";
    shellFile << "            e.preventDefault();\n";
    shellFile << "            if (Module._js_scroll) {\n";
    shellFile << "                Module._js_scroll(e.deltaY);\n";
    shellFile << "            }\n";
    shellFile << "        }, { passive: false });\n";
    shellFile << "    }\n";
    shellFile << "};\n";
    shellFile << "</script>\n";
    shellFile << "{{{ SCRIPT }}}\n";
    shellFile << "</body>\n</html>\n";
    shellFile.close();

    // Build
    printf("[FigmaPreview] Building WebAssembly...\n");
    std::string buildCmd = "cd \"" + tmp + "\" && ./build_web.sh 2>&1";
    int result = system(buildCmd.c_str());

    if (result == 0) {
        printf("[FigmaPreview] Build successful! Starting server...\n");

        // Kill existing server
        system("lsof -ti:8081 | xargs kill -9 2>/dev/null");
        sleep(1);

        // Start server
        std::string serveCmd = "cd \"" + tmp + "\" && python3 -m http.server 8081 > /dev/null 2>&1 &";
        system(serveCmd.c_str());
        sleep(2);

        // Open in Chrome
        system("open -na 'Google Chrome' --args --incognito 'http://localhost:8081/index.html'");

        printf("\n========================================\n");
        printf("Preview opened in Chrome!\n");
        printf("========================================\n\n");

        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Preview opened in Chrome!";
    } else {
        printf("[FigmaPreview] ERROR: Build failed with code %d\n", result);
        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Error: Build failed! Check console.";
    }
}

void PreviewImGuiWebsite() {
    // First, save current page sections back to g_NormalPages
    if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
        g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
    }

    // Check if we have any pages to preview
    if (g_NormalPages.empty() || (g_NormalPages.size() == 1 && g_Sections.empty())) {
        printf("[Preview] ERROR: No sections to preview!\n");
        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Error: No sections to preview! Create or load a template first.";
        return;
    }

    printf("\n========================================\n");
    printf("[Preview] Starting MULTI-PAGE preview with %zu pages\n", g_NormalPages.size());
    for (size_t p = 0; p < g_NormalPages.size(); p++) {
        printf("  Page %zu: %s (%zu sections)\n", p+1, g_NormalPages[p].name.c_str(), g_NormalPages[p].sections.size());
    }
    printf("========================================\n\n");

    std::string basePath = "/Users/imaging/Desktop/Website-Builder-v2.0/";
    std::string tmp = "/tmp/imgui_website_preview";
    std::string imguiFolder = tmp + "/imgui";
    std::string backendsFolder = imguiFolder + "/backends";
    mkdir(tmp.c_str(), 0755);
    mkdir(imguiFolder.c_str(), 0755);
    mkdir(backendsFolder.c_str(), 0755);

    // Copy ImGui files
    std::vector<std::string> imguiFiles = {"imgui.cpp", "imgui.h", "imgui_demo.cpp",
        "imgui_draw.cpp", "imgui_internal.h", "imgui_tables.cpp", "imgui_widgets.cpp",
        "imconfig.h", "imstb_rectpack.h", "imstb_textedit.h", "imstb_truetype.h"};
    for (const auto& f : imguiFiles) {
        std::ifstream src(basePath + "imgui/" + f, std::ios::binary);
        std::ofstream dst(imguiFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }
    std::vector<std::string> backendFiles = {"imgui_impl_glfw.cpp", "imgui_impl_glfw.h",
        "imgui_impl_opengl3.cpp", "imgui_impl_opengl3.h", "imgui_impl_opengl3_loader.h"};
    for (const auto& f : backendFiles) {
        std::ifstream src(basePath + "imgui/backends/" + f, std::ios::binary);
        std::ofstream dst(backendsFolder + "/" + f, std::ios::binary);
        dst << src.rdbuf();
    }

    std::ofstream(tmp + "/main.cpp") << GenerateImGuiCPP();
    std::ofstream(tmp + "/build_web.sh") << GenerateBuildScript();
    std::ofstream(tmp + "/shell.html") << GenerateShellHTML();
    chmod((tmp + "/build_web.sh").c_str(), 0755);

    // Copy Inter font header
    {
        std::ifstream src(basePath + "inter_font.h", std::ios::binary);
        std::ofstream dst(tmp + "/inter_font.h", std::ios::binary);
        dst << src.rdbuf();
    }

    // Copy stb_image.h for image loading
    {
        std::ifstream src(basePath + "stb_image.h", std::ios::binary);
        std::ofstream dst(tmp + "/stb_image.h", std::ios::binary);
        dst << src.rdbuf();
    }

    // Create images directory and copy all section images from ALL PAGES
    std::string imagesFolder = tmp + "/images";
    mkdir(imagesFolder.c_str(), 0755);

    std::set<std::string> imagesToCopy;
    printf("[Preview] Collecting images from ALL %zu pages...\n", g_NormalPages.size());

    // Collect images from ALL pages
    for (const auto& page : g_NormalPages) {
        for (const auto& sec : page.sections) {
            // Collect background image
            if (!sec.background_image.empty() && sec.background_image != "none") {
                imagesToCopy.insert(sec.background_image);
            }

            // Collect hero animation images
            for (const auto& img : sec.hero_animation_images) {
                if (!img.empty()) {
                    imagesToCopy.insert(img);
                }
            }

            // Collect gallery images
            for (const auto& img : sec.gallery_images) {
                if (!img.empty()) {
                    imagesToCopy.insert(img);
                }
            }

            // Collect section image
            if (!sec.section_image.empty() && sec.section_image != "none") {
                imagesToCopy.insert(sec.section_image);
            }

            // Collect logo image
            if (!sec.logo_path.empty() && sec.logo_path != "none") {
                imagesToCopy.insert(sec.logo_path);
            }
        }
    }

    printf("[Preview] Copying %zu unique images...\n", imagesToCopy.size());
    int copiedCount = 0;
    for (const auto& imgPath : imagesToCopy) {
        // Extract filename from path
        size_t lastSlash = imgPath.find_last_of("/\\");
        std::string filename = (lastSlash != std::string::npos) ? imgPath.substr(lastSlash + 1) : imgPath;

        // Determine source path - check if imgPath is absolute
        std::string srcPath;
        if (!imgPath.empty() && imgPath[0] == '/') {
            // Absolute path - use as-is
            srcPath = imgPath;
        } else {
            // Relative path - prepend basePath
            srcPath = basePath + imgPath;
        }
        std::string dstPath = imagesFolder + "/" + filename;

        std::ifstream src(srcPath, std::ios::binary);
        if (src.good()) {
            std::ofstream dst(dstPath, std::ios::binary);
            dst << src.rdbuf();
            copiedCount++;
        } else {
            printf("[Preview] WARNING: Could not find image: %s\n", srcPath.c_str());
        }
    }
    printf("[Preview] Copied %d images to preview directory\n", copiedCount);

    // Build and serve
    printf("[Preview] Building WebAssembly...\n");
    std::string buildCmd = "cd \"" + tmp + "\" && ./build_web.sh 2>&1";
    int result = system(buildCmd.c_str());

    if (result == 0) {
        printf("[Preview] Build successful! Starting server...\n");
        // Kill any existing server on 8080
        system("lsof -ti:8080 | xargs kill -9 2>/dev/null");
        sleep(1);  // Wait for port to be freed

        // Create custom HTTP server with no-cache headers
        std::ofstream serverScript(tmp + "/server.py");
        serverScript << "#!/usr/bin/env python3\n";
        serverScript << "import http.server\n";
        serverScript << "import socketserver\n";
        serverScript << "class NoCacheHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n";
        serverScript << "    def end_headers(self):\n";
        serverScript << "        self.send_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n";
        serverScript << "        self.send_header('Pragma', 'no-cache')\n";
        serverScript << "        self.send_header('Expires', '0')\n";
        serverScript << "        super().end_headers()\n";
        serverScript << "PORT = 8080\n";
        serverScript << "with socketserver.TCPServer(('', PORT), NoCacheHTTPRequestHandler) as httpd:\n";
        serverScript << "    httpd.serve_forever()\n";
        serverScript.close();
        chmod((tmp + "/server.py").c_str(), 0755);

        // Start custom server with no-cache headers
        std::string serveCmd = "cd \"" + tmp + "\" && python3 server.py > /dev/null 2>&1 &";
        system(serveCmd.c_str());
        sleep(2);  // Wait for server to start

        // Close any existing browser tabs with localhost:8080 to clear cache
        system("osascript -e 'tell application \"Google Chrome\" to close (every tab of every window whose URL contains \"localhost:8080\")' 2>/dev/null");
        system("osascript -e 'tell application \"Safari\" to close (every tab of every window whose URL contains \"localhost:8080\")' 2>/dev/null");
        sleep(1);

        // Clear Chrome cache for localhost
        system("osascript -e 'tell application \"Google Chrome\" to tell the active tab of window 1 to execute javascript \"window.location.reload(true)\"' 2>/dev/null");

        // Open in private/incognito mode to bypass cache completely
        std::string url = "http://localhost:8080/index.html";
        system(("open -na 'Google Chrome' --args --incognito \"" + url + "\"").c_str());

        printf("\n========================================\n");
        printf("‚úÖ Preview opened in browser!\n");
        printf("‚ö†Ô∏è  If you see old/wrong content:\n");
        printf("   Press: Cmd+Shift+R (Mac) to force refresh\n");
        printf("========================================\n\n");

        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Preview opened! Press Cmd+Shift+R if you see old content.";
    } else {
        printf("[Preview] ERROR: Build failed with code %d\n", result);
        g_ShowExportSuccess = true;
        g_ExportSuccessTimer = 3.0f;
        g_ExportPath = "Error: Build failed! Check console for details.";
    }
}

// ============================================================================
// PREVIEW HELPER FUNCTIONS
// ============================================================================
// Enhanced glass card for preview (configurable border and highlight)
void DrawGlassCardEnhanced(ImDrawList* dl, float x, float y, float w, float h, float opacity, ImU32 tintColor,
    float rounding, float borderWidth, ImU32 borderColor, bool showHighlight, float highlightOpacity) {
    // Outer glow/shadow for depth
    dl->AddRectFilled(ImVec2(x-1, y+6), ImVec2(x+w+1, y+h+8), IM_COL32(0,0,0,20), rounding+2);

    // Glass background with transparency
    int tintR = (tintColor >> 0) & 0xFF;
    int tintG = (tintColor >> 8) & 0xFF;
    int tintB = (tintColor >> 16) & 0xFF;
    int alpha = (int)(opacity * 255);
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(tintR, tintG, tintB, alpha), rounding);

    // Frosted/blur simulation - multiple translucent layers
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x+w, y+h), IM_COL32(255, 255, 255, 12), rounding);
    dl->AddRectFilled(ImVec2(x+2, y+2), ImVec2(x+w-2, y+h-2), IM_COL32(200, 200, 255, 6), rounding > 2 ? rounding-2 : 1);

    // Top highlight (glass shine) - configurable
    if (showHighlight) {
        int hlAlpha = (int)(highlightOpacity * 255 * 0.5f);
        dl->AddRectFilledMultiColor(
            ImVec2(x+3, y+3), ImVec2(x+w-3, y + h*0.4f),
            IM_COL32(255, 255, 255, hlAlpha), IM_COL32(255, 255, 255, hlAlpha),
            IM_COL32(255, 255, 255, 0), IM_COL32(255, 255, 255, 0)
        );
    }

    // Glass border - configurable
    if (borderWidth > 0) {
        dl->AddRect(ImVec2(x, y), ImVec2(x+w, y+h), borderColor, rounding, 0, borderWidth);
        // Inner border for extra depth
        int br = (borderColor >> 0) & 0xFF;
        int bg = (borderColor >> 8) & 0xFF;
        int bb = (borderColor >> 16) & 0xFF;
        int ba = ((borderColor >> 24) & 0xFF) / 2;
        dl->AddRect(ImVec2(x+1, y+1), ImVec2(x+w-1, y+h-1), IM_COL32(br, bg, bb, ba), rounding > 1 ? rounding-1 : 1, 0, borderWidth * 0.5f);
    }
}

// Forward declarations for modern card renderers (defined before main)
void DrawModernServiceCard(ImDrawList* dl, float x, float y, float w, float h,
                          const std::string& title, const std::string& subtitle,
                          const std::vector<std::string>& bullets, const std::string& icon_emoji,
                          ImVec4 icon_color, ImVec4 text_color, float anim_progress);

void DrawModernPortfolioCard(ImDrawList* dl, float x, float y, float w, float h,
                             const std::string& title, const std::string& subtitle,
                             const std::vector<std::string>& tech_tags, const std::string& badge_text,
                             GLuint thumbnail_id, ImVec4 text_color, float anim_progress);

// ============================================================================
// ACTION SETTINGS HELPER - Renders action type combo and target input
// ============================================================================
const char* g_ActionTypeNames[] = {
    "None",
    "Scroll to Section",
    "Link to Page",
    "External URL",
    "Open Popup",
    "Download File",
    "Send Email",
    "Call Phone"
};

// Helper to render action settings UI - returns true if changed
bool RenderActionSettings(const char* label, int* actionType, char* actionTarget, size_t targetSize, const std::vector<WebSection>& sections) {
    bool changed = false;
    ImGui::PushID(label);

    ImGui::Text("Action:");
    ImGui::PushItemWidth(150);
    if (ImGui::Combo("##actionType", actionType, g_ActionTypeNames, IM_ARRAYSIZE(g_ActionTypeNames))) {
        changed = true;
    }
    ImGui::PopItemWidth();

    // Show appropriate target input based on action type
    if (*actionType == ACTION_SCROLL_TO_SECTION) {
        ImGui::Text("Target Section:");
        // Show dropdown of available sections
        ImGui::PushItemWidth(150);
        if (ImGui::BeginCombo("##targetSection", actionTarget[0] ? actionTarget : "Select...")) {
            for (size_t i = 0; i < sections.size(); i++) {
                bool isSelected = (strcmp(actionTarget, sections[i].name.c_str()) == 0);
                if (ImGui::Selectable(sections[i].name.c_str(), isSelected)) {
                    strncpy(actionTarget, sections[i].name.c_str(), targetSize - 1);
                    actionTarget[targetSize - 1] = '\0';
                    changed = true;
                }
            }
            ImGui::EndCombo();
        }
        ImGui::PopItemWidth();
    }
    else if (*actionType == ACTION_LINK_TO_PAGE) {
        ImGui::Text("Select Page:");
        ImGui::PushItemWidth(150);
        // Show dropdown of available pages
        if (ImGui::BeginCombo("##targetPage", actionTarget[0] ? actionTarget : "Select Page...")) {
            for (size_t i = 0; i < g_NormalPages.size(); i++) {
                bool isSelected = (strcmp(actionTarget, g_NormalPages[i].name.c_str()) == 0);
                if (ImGui::Selectable(g_NormalPages[i].name.c_str(), isSelected)) {
                    strncpy(actionTarget, g_NormalPages[i].name.c_str(), targetSize - 1);
                    actionTarget[targetSize - 1] = '\0';
                    changed = true;
                }
            }
            ImGui::EndCombo();
        }
        ImGui::PopItemWidth();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Or enter custom: about.html");
        ImGui::PushItemWidth(150);
        if (ImGui::InputText("##customPage", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
    }
    else if (*actionType == ACTION_EXTERNAL_URL) {
        ImGui::Text("URL:");
        ImGui::PushItemWidth(200);
        if (ImGui::InputText("##url", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "e.g., https://example.com");
    }
    else if (*actionType == ACTION_OPEN_POPUP) {
        ImGui::Text("Popup ID:");
        ImGui::PushItemWidth(150);
        if (ImGui::InputText("##popupId", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
    }
    else if (*actionType == ACTION_DOWNLOAD) {
        ImGui::Text("File Path:");
        ImGui::PushItemWidth(200);
        if (ImGui::InputText("##filePath", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
    }
    else if (*actionType == ACTION_EMAIL) {
        ImGui::Text("Email:");
        ImGui::PushItemWidth(200);
        if (ImGui::InputText("##email", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "e.g., info@company.com");
    }
    else if (*actionType == ACTION_PHONE) {
        ImGui::Text("Phone:");
        ImGui::PushItemWidth(150);
        if (ImGui::InputText("##phone", actionTarget, targetSize)) {
            changed = true;
        }
        ImGui::PopItemWidth();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "e.g., +1-234-567-8900");
    }

    ImGui::PopID();
    return changed;
}

// ============================================================================
// RENDER SECTION PREVIEW (Same as Website Builder V1)
// ============================================================================
void RenderSectionPreview(ImDrawList* dl, WebSection& sec, ImVec2 pos, float w, float yOff) {
    // Apply width and horizontal alignment (for ALL sections)
    float canvasW = w;  // Original canvas width
    float sectionW = canvasW * (sec.section_width_percent / 100.0f);
    float sectionX = pos.x;

    // Apply horizontal alignment
    if (sec.horizontal_align == 1) {  // Center
        sectionX = pos.x + (canvasW - sectionW) / 2;
    } else if (sec.horizontal_align == 2) {  // Right
        sectionX = pos.x + canvasW - sectionW;
    }
    // else: Left (default, sectionX = pos.x)

    // Use adjusted width and x position for rendering
    float x = sectionX, y = pos.y + yOff, h = sec.height * g_Zoom;
    ImVec2 mn(x, y), mx(x + sectionW, y + h);
    float cx = x + sectionW / 2;

    // Helper lambda to ensure valid font sizes
    auto ValidFontSize = [](float size) { return (size > 0.0f) ? size : 16.0f; };

    // Draw section box shadow FIRST (behind the section)
    if (sec.section_box_shadow != "none" && !sec.section_box_shadow.empty()) {
        // Simple box shadow: draw darker rectangles offset and larger
        float shadowOffset = 6.0f;
        ImVec4 shadowColor = ImVec4(0, 0, 0, 0.1f);

        // Draw 3 layers for blur effect
        for (int i = 0; i < 3; i++) {
            float alpha = shadowColor.w * (1.0f - i * 0.25f);
            ImVec4 layerColor = ImVec4(shadowColor.x, shadowColor.y, shadowColor.z, alpha);
            float spread = i * 3.0f;
            float offset = shadowOffset + i;
            dl->AddRectFilled(
                ImVec2(mn.x - spread, mn.y + offset - spread),
                ImVec2(mx.x + spread, mx.y + offset + spread),
                ImGui::ColorConvertFloat4ToU32(layerColor),
                sec.section_border_radius + spread
            );
        }
    }

    // Background with Animation Support (with border radius)
    if (sec.enable_hero_animation && !sec.hero_animation_texture_ids.empty()) {
        // Hero Animation: Update timer and cycle through images
        sec.animation_timer += ImGui::GetIO().DeltaTime;
        if (sec.animation_timer >= sec.hero_animation_speed) {
            sec.animation_timer = 0.0f;
            sec.current_animation_frame++;
            if (sec.current_animation_frame >= (int)sec.hero_animation_texture_ids.size()) {
                sec.current_animation_frame = 0;
            }
        }

        // Render current animation frame with background-size: cover
        GLuint animTexId = sec.hero_animation_texture_ids[sec.current_animation_frame];

        // Parse background-position
        float bgPosX = 0.5f, bgPosY = 0.5f;
        ParseBackgroundPosition(sec.background_position, bgPosX, bgPosY);

        // Get texture dimensions
        GLint texW = 0, texH = 0;
        GLuint oldTex;
        glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint*)&oldTex);
        glBindTexture(GL_TEXTURE_2D, animTexId);
        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &texW);
        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &texH);
        glBindTexture(GL_TEXTURE_2D, oldTex);

        // Calculate UV for cover
        ImVec2 uv0, uv1;
        if (texW > 0 && texH > 0) {
            CalculateCoverUV(sectionW, h, (float)texW, (float)texH, bgPosX, bgPosY, uv0, uv1);
        } else {
            uv0 = ImVec2(0, 0);
            uv1 = ImVec2(1, 1);
        }

        dl->AddImageRounded((ImTextureID)(intptr_t)animTexId, mn, mx, uv0, uv1,
                           IM_COL32(255,255,255,255), sec.section_border_radius);
        // Only draw overlay if opacity > 0
        if (sec.bg_overlay_opacity > 0.01f) {
            dl->AddRectFilled(mn, mx, ImGui::ColorConvertFloat4ToU32(ImVec4(0, 0, 0, sec.bg_overlay_opacity)), sec.section_border_radius);
        }
    } else if (sec.use_bg_image && sec.bg_texture_id) {
        // Static background image with background-size: cover support
        // Parse background-position for proper alignment
        float bgPosX = 0.5f, bgPosY = 0.5f;  // Default: center
        ParseBackgroundPosition(sec.background_position, bgPosX, bgPosY);

        // Get texture dimensions to calculate proper UV coordinates
        GLint texW = 0, texH = 0;
        GLuint oldTex;
        glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint*)&oldTex);
        glBindTexture(GL_TEXTURE_2D, sec.bg_texture_id);
        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &texW);
        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &texH);
        glBindTexture(GL_TEXTURE_2D, oldTex);

        // Calculate UV coordinates for background-size: cover
        ImVec2 uv0, uv1;
        float containerW = sectionW;
        float containerH = h;
        if (texW > 0 && texH > 0) {
            CalculateCoverUV(containerW, containerH, (float)texW, (float)texH, bgPosX, bgPosY, uv0, uv1);
        } else {
            // Fallback if texture dimensions unavailable
            uv0 = ImVec2(0, 0);
            uv1 = ImVec2(1, 1);
        }

        // Render with calculated UV coordinates (background-size: cover effect)
        dl->AddImageRounded((ImTextureID)(intptr_t)sec.bg_texture_id, mn, mx, uv0, uv1,
                           IM_COL32(255,255,255,255), sec.section_border_radius);
        // Only draw overlay if opacity > 0
        if (sec.bg_overlay_opacity > 0.01f) {
            dl->AddRectFilled(mn, mx, ImGui::ColorConvertFloat4ToU32(ImVec4(0, 0, 0, sec.bg_overlay_opacity)), sec.section_border_radius);
        }
    } else {
        // Check for CSS gradient first
        if (sec.has_gradient && sec.gradient_colors.size() >= 2) {
            // Render CSS gradient background
            ImVec4 color1 = sec.gradient_colors[0];
            ImVec4 color2 = sec.gradient_colors[sec.gradient_colors.size() - 1];

            // Apply opacity
            color1.w *= sec.section_opacity;
            color2.w *= sec.section_opacity;

            // For now, support simple linear gradients (top-to-bottom or left-to-right)
            // Direction based on CSS gradient angle (simplified)
            if (sec.gradient_is_radial) {
                // Radial gradient: draw from center outward (simplified as vertical gradient)
                ImU32 col1 = ImGui::ColorConvertFloat4ToU32(color1);
                ImU32 col2 = ImGui::ColorConvertFloat4ToU32(color2);
                dl->AddRectFilledMultiColor(mn, mx, col1, col1, col2, col2);
            } else {
                // Linear gradient
                // Most common: top-to-bottom or left-to-right
                ImU32 col1 = ImGui::ColorConvertFloat4ToU32(color1);
                ImU32 col2 = ImGui::ColorConvertFloat4ToU32(color2);

                // Determine direction from gradient string
                if (sec.background_image_css.find("to right") != std::string::npos) {
                    // Left to right gradient
                    dl->AddRectFilledMultiColor(mn, mx, col1, col2, col2, col1);
                } else if (sec.background_image_css.find("to left") != std::string::npos) {
                    // Right to left gradient
                    dl->AddRectFilledMultiColor(mn, mx, col2, col1, col1, col2);
                } else if (sec.background_image_css.find("to top") != std::string::npos) {
                    // Bottom to top gradient
                    dl->AddRectFilledMultiColor(mn, mx, col2, col2, col1, col1);
                } else {
                    // Default: top to bottom gradient
                    dl->AddRectFilledMultiColor(mn, mx, col1, col1, col2, col2);
                }
            }

            // If section has border radius, we need to clip (simplified - just note it)
            // Full implementation would need stencil buffer or custom shader
        } else {
            // Solid color background (with border radius and opacity)
            ImVec4 bgColor = sec.bg_color;
            bgColor.w *= sec.section_opacity;  // Apply section opacity
            dl->AddRectFilled(mn, mx, ImGui::ColorConvertFloat4ToU32(bgColor), sec.section_border_radius);
        }
    }

    // === RENDER SECTION BORDER (from CSS) ===
    if (sec.section_border != "none" && !sec.section_border.empty()) {
        // Parse border: "1px solid rgb(200,200,200)" or similar
        // For now, simple implementation: just draw a border
        ImU32 borderColor = IM_COL32(200, 200, 200, 255); // Default gray
        float borderWidth = 1.0f;

        // Try to parse border width
        if (sec.section_border.find("2px") != std::string::npos) borderWidth = 2.0f;
        else if (sec.section_border.find("3px") != std::string::npos) borderWidth = 3.0f;

        dl->AddRect(mn, mx, borderColor, sec.section_border_radius, 0, borderWidth);
    }

    if (sec.selected) dl->AddRect(mn, mx, ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.6f, 1.0f, 1.0f)), 0, 0, 3.0f);

    dl->AddRectFilled(ImVec2(x + 5, y + 5), ImVec2(x + 80, y + 22), ImGui::ColorConvertFloat4ToU32(ImVec4(0, 0, 0, 0.4f)), 3.0f);
    dl->AddText(ImVec2(x + 10, y + 6), IM_COL32(255, 255, 255, 200), sec.name.c_str());

    // Render glass panels for this section
    for (auto& gp : sec.glass_panels) {
        float gpX = x + gp.x * g_Zoom * 0.4f;
        float gpY = y + gp.y * g_Zoom * 0.4f;
        float gpW = gp.width * g_Zoom * 0.4f;
        float gpH = gp.height * g_Zoom * 0.4f;
        float gpR = gp.border_radius * g_Zoom * 0.4f;
        // Glass background
        ImU32 tintColor = ImGui::ColorConvertFloat4ToU32(gp.tint);
        int tintR = (tintColor >> 0) & 0xFF;
        int tintG = (tintColor >> 8) & 0xFF;
        int tintB = (tintColor >> 16) & 0xFF;
        int alpha = (int)(gp.opacity * 255);
        dl->AddRectFilled(ImVec2(gpX, gpY), ImVec2(gpX + gpW, gpY + gpH), IM_COL32(tintR, tintG, tintB, alpha), gpR);
        dl->AddRectFilled(ImVec2(gpX, gpY), ImVec2(gpX + gpW, gpY + gpH), IM_COL32(255, 255, 255, 15), gpR);
        // Top highlight
        dl->AddRectFilledMultiColor(ImVec2(gpX + 2, gpY + 2), ImVec2(gpX + gpW - 2, gpY + gpH * 0.35f),
            IM_COL32(255, 255, 255, 30), IM_COL32(255, 255, 255, 30),
            IM_COL32(255, 255, 255, 5), IM_COL32(255, 255, 255, 5));
        // Glass border
        dl->AddRect(ImVec2(gpX, gpY), ImVec2(gpX + gpW, gpY + gpH), IM_COL32(255, 255, 255, 40), gpR, 0, 1.0f);
        // Text
        if (!gp.text.empty()) {
            ImVec2 textSize = ImGui::CalcTextSize(gp.text.c_str());
            float textX = gpX + (gpW - textSize.x) / 2;
            float textY = gpY + (gpH - textSize.y) / 2;
            dl->AddText(ImVec2(textX, textY), ImGui::ColorConvertFloat4ToU32(gp.text_color), gp.text.c_str());
        }
        // Selection border
        if (gp.selected) {
            dl->AddRect(ImVec2(gpX - 2, gpY - 2), ImVec2(gpX + gpW + 2, gpY + gpH + 2), IM_COL32(100, 150, 255, 255), gpR + 2, 0, 2.0f);
        }
    }

    // Navbar
    if (sec.type == SEC_NAVBAR) {
        // Check for gradient on navbar
        if (sec.has_gradient && sec.gradient_colors.size() >= 2) {
            ImVec4 color1 = sec.gradient_colors[0];
            ImVec4 color2 = sec.gradient_colors[sec.gradient_colors.size() - 1];
            ImU32 col1 = ImGui::ColorConvertFloat4ToU32(color1);
            ImU32 col2 = ImGui::ColorConvertFloat4ToU32(color2);

            if (sec.background_image_css.find("to right") != std::string::npos) {
                dl->AddRectFilledMultiColor(mn, mx, col1, col2, col2, col1);
            } else {
                dl->AddRectFilledMultiColor(mn, mx, col1, col1, col2, col2);
            }
        } else {
            dl->AddRectFilled(mn, mx, ImGui::ColorConvertFloat4ToU32(sec.nav_bg_color));
        }

        // Logo + Brand/Title with font properties
        ImFont* font = ImGui::GetFont();
        float titleFS = ValidFontSize(sec.title_font_size);
        ImVec2 brandSize = font->CalcTextSizeA(titleFS, FLT_MAX, 0.0f, sec.title.c_str());

        float startX = x + 25;
        float centerY = y + h / 2;

        // Render Logo if exists
        if (sec.logo_texture_id != 0) {
            float logoH = sec.logo_size;
            float logoW = sec.logo_size; // Square aspect, can be adjusted

            if (sec.brand_text_position == 0) {
                // SIDE: Logo on left, text on right
                float logoY = centerY - logoH / 2;
                dl->AddImage((ImTextureID)(intptr_t)sec.logo_texture_id,
                    ImVec2(startX, logoY),
                    ImVec2(startX + logoW, logoY + logoH));
                startX += logoW + 15; // Move text right after logo
            } else if (sec.brand_text_position == 1) {
                // ABOVE: Text above logo
                float logoY = centerY;
                dl->AddImage((ImTextureID)(intptr_t)sec.logo_texture_id,
                    ImVec2(startX, logoY),
                    ImVec2(startX + logoW, logoY + logoH));
                centerY = logoY - brandSize.y - 8; // Move text above logo
            } else if (sec.brand_text_position == 2) {
                // BELOW: Text below logo
                float logoY = centerY - logoH - brandSize.y / 2 - 8;
                dl->AddImage((ImTextureID)(intptr_t)sec.logo_texture_id,
                    ImVec2(startX, logoY),
                    ImVec2(startX + logoW, logoY + logoH));
                centerY = logoY + logoH + 8; // Move text below logo
            }
        }

        // Boldness layers for brand text
        int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
        float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

        float textY = centerY - brandSize.y / 2;
        if (titleLayers > 1) {
            for (int layer = 0; layer < titleLayers; layer++) {
                float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                dl->AddText(font, titleFS, ImVec2(startX + offsetX, textY + offsetY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }
        } else {
            dl->AddText(font, titleFS, ImVec2(startX, textY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
        }

        // Navigation items with individual font properties
        float nx = x + sectionW - 30;
        for (int i = (int)sec.nav_items.size() - 1; i >= 0; i--) {
            float itemFS = ValidFontSize(sec.nav_items[i].font_size);
            ImVec2 itemSize = font->CalcTextSizeA(itemFS, FLT_MAX, 0.0f, sec.nav_items[i].label.c_str());
            nx -= itemSize.x + 30;

            int itemLayers = (sec.nav_items[i].font_weight >= 800.0f) ? 9 : ((sec.nav_items[i].font_weight >= 500.0f) ? 4 : 1);
            float itemBoldStrength = (sec.nav_items[i].font_weight >= 800.0f) ? 1.0f : ((sec.nav_items[i].font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (itemLayers > 1) {
                for (int layer = 0; layer < itemLayers; layer++) {
                    float offsetX = (layer % 3) * itemBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * itemBoldStrength * 0.5f;
                    dl->AddText(font, itemFS, ImVec2(nx + offsetX, y + h / 2 - itemSize.y / 2 + offsetY), ImGui::ColorConvertFloat4ToU32(sec.nav_items[i].text_color), sec.nav_items[i].label.c_str());
                }
            } else {
                dl->AddText(font, itemFS, ImVec2(nx, y + h / 2 - itemSize.y / 2), ImGui::ColorConvertFloat4ToU32(sec.nav_items[i].text_color), sec.nav_items[i].label.c_str());
            }
        }
        return;
    }

    // Hero/CTA
    if (sec.type == SEC_HERO || sec.type == SEC_CTA) {
        // === RENDER SECTION IMAGE FIRST (if exists) ===
        float imageEndY = y + sec.padding_top;
        if (sec.img_texture_id != 0) {
            // Render image (debug logging removed to prevent spam)

            float imageW = sectionW * 0.8f;  // 80% of section width
            float imageH = h * 0.5f;         // 50% of section height
            float imageX = x + (sectionW - imageW) / 2;
            float imageY = y + sec.padding_top;

            // Render image
            dl->AddImage((ImTextureID)(intptr_t)sec.img_texture_id,
                         ImVec2(imageX, imageY),
                         ImVec2(imageX + imageW, imageY + imageH));

            // Add border around image
            dl->AddRect(ImVec2(imageX, imageY),
                       ImVec2(imageX + imageW, imageY + imageH),
                       IM_COL32(255, 255, 255, 60), 4.0f, 0, 1.5f);

            imageEndY = imageY + imageH + 30;  // Space after image
        }

        // Use 4-sided padding for proper spacing
        float contentY = imageEndY;
        float textMaxWidth = sectionW - sec.padding_left - sec.padding_right;
        float textStartX = x + sec.padding_left;
        bool centerText = (sec.text_align == 1);

        // Parse line-height and letter-spacing from CSS
        float titleLineHeight = ParseLineHeight(sec.section_line_height, sec.title_font_size);
        float subtitleLineHeight = ParseLineHeight(sec.section_line_height, sec.subtitle_font_size);
        float letterSpacing = ParseLetterSpacing(sec.section_letter_spacing, sec.title_font_size);

        // Apply flexbox justify-content for vertical alignment
        if (sec.justify_content == "center") {
            // Center content vertically - calculate total height and offset
            float totalContentHeight = 0;
            if (!sec.title.empty()) {
                ImFont* font = ImGui::GetFont();
                ImVec2 titleSize = font->CalcTextSizeA(sec.title_font_size, FLT_MAX, textMaxWidth, sec.title.c_str());
                totalContentHeight += titleSize.y * titleLineHeight + 10;
            }
            if (!sec.subtitle.empty()) {
                ImFont* font = ImGui::GetFont();
                ImVec2 subtitleSize = font->CalcTextSizeA(sec.subtitle_font_size, FLT_MAX, textMaxWidth, sec.subtitle.c_str());
                totalContentHeight += subtitleSize.y * subtitleLineHeight + 20;
            }
            if (!sec.button_text.empty()) {
                totalContentHeight += 32;  // Button height
            }

            // Center vertically based on available height
            float availableHeight = h - sec.padding_top - sec.padding_bottom;
            if (totalContentHeight < availableHeight) {
                contentY = y + sec.padding_top + (availableHeight - totalContentHeight) / 2;
            }
        }

        if (!sec.title.empty()) {
            float titleHeight = DrawWrappedText(dl, sec.title, textStartX, contentY, textMaxWidth, ImGui::ColorConvertFloat4ToU32(sec.title_color), centerText, sec.title_font_size, sec.title_font_weight, titleLineHeight, letterSpacing);
            contentY += titleHeight + 10;
        }
        if (!sec.subtitle.empty()) {
            float subHeight = DrawWrappedText(dl, sec.subtitle, textStartX, contentY, textMaxWidth, ImGui::ColorConvertFloat4ToU32(sec.subtitle_color), centerText, sec.subtitle_font_size, sec.subtitle_font_weight, subtitleLineHeight, letterSpacing);
            contentY += subHeight + 20;
        }
        if (!sec.button_text.empty()) {
            // Calculate button size with font
            ImFont* font = ImGui::GetFont();
            ImVec2 btnSize = font->CalcTextSizeA(ValidFontSize(sec.button_font_size), FLT_MAX, 0.0f, sec.button_text.c_str());

            float btnW = btnSize.x + 50, btnH = 32;
            float btnX = centerText ? (x + w/2 - btnW/2) : textStartX;

            // Draw button box shadow (if not "none")
            if (sec.button_box_shadow != "none" && !sec.button_box_shadow.empty()) {
                // Simple box shadow: draw a darker rectangle offset below the button
                float shadowOffset = 4.0f;
                float shadowBlur = 8.0f;
                ImVec4 shadowColor = ImVec4(0, 0, 0, 0.15f);

                // Draw multiple shadow layers for blur effect
                for (int i = 0; i < 3; i++) {
                    float alpha = shadowColor.w * (1.0f - i * 0.3f);
                    ImVec4 layerColor = ImVec4(shadowColor.x, shadowColor.y, shadowColor.z, alpha);
                    float offset = shadowOffset + i * 2.0f;
                    dl->AddRectFilled(
                        ImVec2(btnX - i, contentY + offset - i),
                        ImVec2(btnX + btnW + i, contentY + btnH + offset + i),
                        ImGui::ColorConvertFloat4ToU32(layerColor),
                        sec.button_border_radius + i
                    );
                }
            }

            // Draw button with border radius from CSS
            dl->AddRectFilled(ImVec2(btnX, contentY), ImVec2(btnX + btnW, contentY + btnH), ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), sec.button_border_radius);

            // Draw button border if specified
            if (sec.button_border_width > 0) {
                dl->AddRect(ImVec2(btnX, contentY), ImVec2(btnX + btnW, contentY + btnH),
                           ImGui::ColorConvertFloat4ToU32(sec.button_border_color),
                           sec.button_border_radius, 0, sec.button_border_width);
            }

            // Draw button text with font size and weight
            int btnLayers = (sec.button_font_weight >= 800.0f) ? 9 : ((sec.button_font_weight >= 500.0f) ? 4 : 1);
            float btnBoldStrength = (sec.button_font_weight >= 800.0f) ? 1.0f : ((sec.button_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (btnLayers > 1) {
                for (int layer = 0; layer < btnLayers; layer++) {
                    float offsetX = (layer % 3) * btnBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * btnBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.button_font_size), ImVec2(btnX + 25 + offsetX, contentY + 8 + offsetY), ImGui::ColorConvertFloat4ToU32(sec.button_text_color), sec.button_text.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.button_font_size), ImVec2(btnX + 25, contentY + 8), ImGui::ColorConvertFloat4ToU32(sec.button_text_color), sec.button_text.c_str());
            }
        }
        return;
    }

    // Cards sections (also render if section has image but no cards - for imported templates)
    if ((sec.type == SEC_CARDS || sec.type == SEC_SERVICES || sec.type == SEC_FEATURES ||
         sec.type == SEC_TEAM || sec.type == SEC_PRICING || sec.type == SEC_TESTIMONIALS || sec.type == SEC_GALLERY) && (!sec.items.empty() || sec.img_texture_id != 0)) {
        float titleY = y + 40;
        if (!sec.title.empty()) {
            ImFont* font = ImGui::GetFont();
            ImVec2 titleSize = font->CalcTextSizeA(ValidFontSize(sec.title_font_size), FLT_MAX, 0.0f, sec.title.c_str());

            int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
            float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (titleLayers > 1) {
                for (int layer = 0; layer < titleLayers; layer++) {
                    float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2 + offsetX, titleY + offsetY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2, titleY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }
        }

        // Show section image if it exists (for imported templates with images)
        float imageY = y + 40;
        if (sec.img_texture_id != 0) {
            float imageH = h * 0.4f;  // Use 40% of section height for image
            float imageW = sectionW * 0.9f;  // Use 90% of section width
            float imageX = x + (sectionW - imageW) / 2;
            imageY = y + 50;

            // Render image
            dl->AddImage((ImTextureID)(intptr_t)sec.img_texture_id,
                         ImVec2(imageX, imageY),
                         ImVec2(imageX + imageW, imageY + imageH));

            // Add subtle border around image
            dl->AddRect(ImVec2(imageX, imageY), ImVec2(imageX + imageW, imageY + imageH),
                       IM_COL32(255, 255, 255, 40), 4.0f, 0, 1.0f);

            imageY += imageH + 30;  // Update Y position for title/cards below image
        }

        // Only render cards if there are items
        if (!sec.items.empty()) {
            int cardsPerRow = std::max(1, std::min(sec.cards_per_row, 6));
            int showCards = std::min((int)sec.items.size(), cardsPerRow * 2);

            // Use fixed card dimensions from section settings (properly scaled for preview)
            float previewScale = 0.35f;  // Fixed scale for consistent preview
            float cardW = sec.card_width * previewScale;
            float cardH = sec.card_height * previewScale;
            // Use flexbox gap if specified, otherwise use card_spacing
            float cardSpacing = (sec.gap > 0) ? (sec.gap * previewScale) : (sec.card_spacing * previewScale);

            // Make sure cards fit within available space (use 4-sided padding)
            float availableWidth = sectionW - sec.padding_left - sec.padding_right;
            float totalGridWidth = cardsPerRow * cardW + (cardsPerRow - 1) * cardSpacing;

            // If cards don't fit, scale them down
            if (totalGridWidth > availableWidth) {
                float scaleDown = availableWidth / totalGridWidth;
                cardW *= scaleDown;
                cardH *= scaleDown;
                cardSpacing *= scaleDown;
                totalGridWidth = availableWidth;
            }

            // Use padding_left for left alignment or center if needed
            float startX = x + sec.padding_left + (availableWidth - totalGridWidth) / 2;
            // Position cards below image if image exists, otherwise use padding_top
            float cardY = (sec.img_texture_id != 0) ? imageY : (y + sec.padding_top + sec.heading_to_cards_spacing);

        // Special rendering for Gallery - show image boxes with strong borders
        if (sec.type == SEC_GALLERY) {
            // Render 4 image placeholders (or use items)
            int numImages = std::max(4, (int)sec.items.size());
            for (int i = 0; i < std::min(numImages, showCards); i++) {
                int row = i / cardsPerRow;
                int col = i % cardsPerRow;
                float cardX = startX + col * (cardW + cardSpacing);
                float thisCardY = cardY + row * (cardH + cardSpacing);
                if (thisCardY + cardH > y + h - 10) continue;

                // Check if we have uploaded gallery image
                bool hasGalleryImage = (i < (int)sec.gallery_texture_ids.size() && sec.gallery_texture_ids[i] != 0);

                if (hasGalleryImage) {
                    // Render uploaded image
                    dl->AddImage((ImTextureID)(intptr_t)sec.gallery_texture_ids[i],
                                ImVec2(cardX, thisCardY),
                                ImVec2(cardX + cardW, thisCardY + cardH));
                } else {
                    // Render placeholder box
                    dl->AddRectFilled(ImVec2(cardX, thisCardY), ImVec2(cardX + cardW, thisCardY + cardH),
                                     IM_COL32(240, 242, 245, 255), 4.0f);
                }

                // Add strong border for Gallery images
                dl->AddRect(ImVec2(cardX, thisCardY), ImVec2(cardX + cardW, thisCardY + cardH),
                           IM_COL32(180, 185, 195, 255), 4.0f, 0, 2.0f);

                // Add label if no image uploaded
                if (!hasGalleryImage && i < (int)sec.items.size()) {
                    ImFont* font = ImGui::GetFont();
                    const char* label = sec.items[i].title.c_str();
                    ImVec2 labelSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, label);
                    float labelX = cardX + (cardW - labelSize.x) / 2;
                    float labelY = thisCardY + (cardH - labelSize.y) / 2;
                    dl->AddText(font, 14.0f, ImVec2(labelX, labelY),
                               IM_COL32(120, 130, 140, 255), label);
                }
            }
        } else {
            // Regular card rendering for non-Gallery sections
            // === USE LAYOUT ENGINE FOR PROPER CSS POSITIONING ===
            std::vector<LayoutRect> cardBoxes;

            // Check if section uses Flexbox or Grid
            if (sec.display == "flex") {
                // === FLEXBOX LAYOUT ===
                printf("üé® Using FLEXBOX: justify=%s, align=%s, gap=%.0f\n",
                       sec.justify_content.c_str(), sec.align_items.c_str(), sec.gap);

                FlexboxLayout flexProps;
                flexProps.flex_direction = sec.flex_direction.empty() ? "row" : sec.flex_direction;
                flexProps.justify_content = sec.justify_content.empty() ? "flex-start" : sec.justify_content;
                flexProps.align_items = sec.align_items.empty() ? "flex-start" : sec.align_items;
                flexProps.gap = cardSpacing;

                // Prepare item sizes
                std::vector<float> itemWidths, itemHeights;
                for (int i = 0; i < showCards; i++) {
                    itemWidths.push_back(cardW);
                    itemHeights.push_back(cardH);
                }

                // Calculate positions using Flexbox engine
                cardBoxes = FlexboxEngine::CalculateLayout(
                    startX, cardY, availableWidth, h - cardY - y,
                    flexProps, itemWidths, itemHeights
                );
            }
            else if (sec.display == "grid") {
                // === GRID LAYOUT ===
                printf("üìê Using GRID: columns=%s, gap=%.0f\n",
                       sec.grid_template_columns.c_str(), sec.gap);

                GridLayout gridProps;
                gridProps.grid_template_columns = sec.grid_template_columns;
                gridProps.grid_template_rows = sec.grid_template_rows;
                gridProps.column_gap = cardSpacing;
                gridProps.row_gap = cardSpacing;

                // Calculate positions using Grid engine
                cardBoxes = GridEngine::CalculateLayout(
                    startX, cardY, availableWidth, h - cardY - y,
                    gridProps, showCards
                );
            }
            else {
                // === FALLBACK: Manual positioning (old way) ===
                for (int i = 0; i < showCards; i++) {
                    int row = i / cardsPerRow;
                    int col = i % cardsPerRow;
                    float cardX = startX + col * (cardW + cardSpacing);
                    float thisCardY = cardY + row * (cardH + cardSpacing);
                    cardBoxes.push_back(LayoutRect(cardX, thisCardY, cardW, cardH));
                }
            }

            // === CAROUSEL ANIMATION ===
            float carouselScrollOffset = 0.0f;
            float totalCardsWidth = 0.0f;
            bool isCarousel = (sec.animation_type == ANIM_CAROUSEL && showCards > 0);

            if (isCarousel) {
                // Calculate total width of carousel (all cards + gaps)
                for (int j = 0; j < showCards && j < (int)cardBoxes.size(); j++) {
                    totalCardsWidth += cardBoxes[j].width + cardSpacing;
                }

                // Continuous animation
                AnimationState& carouselAnim = AnimationEngine::UpdateAnimation(
                    sec.id, ANIM_CAROUSEL,
                    sec.animation_duration > 0 ? sec.animation_duration : 5.0f,
                    0.0f, true, ImGui::GetIO().DeltaTime
                );

                // Seamless scroll offset with modulo for perfect loop
                carouselScrollOffset = -fmod(carouselAnim.progress * totalCardsWidth, totalCardsWidth);

                // CRITICAL: Push clip rect ONCE for entire carousel
                // This keeps ALL cards INSIDE the section boundaries
                float sectionLeft = x + sec.padding_left;
                float sectionRight = x + w - sec.padding_right;
                float sectionTop = y + sec.padding_top;
                float sectionBottom = y + h - sec.padding_bottom;

                dl->PushClipRect(ImVec2(sectionLeft, sectionTop),
                                ImVec2(sectionRight, sectionBottom),
                                true);
            }

            // === RENDER CARDS ===
        for (int i = 0; i < showCards && i < (int)cardBoxes.size(); i++) {
            const auto& item = sec.items[i];
            float cardX = cardBoxes[i].x;
            float thisCardY = cardBoxes[i].y;
            float thisCardW = cardBoxes[i].width;
            float thisCardH = cardBoxes[i].height;
            float animOpacity = 1.0f;

            // Different handling for carousel vs other animations
            if (sec.animation_type == ANIM_CAROUSEL) {
                // CAROUSEL: Render at wrapped positions for seamless loop
                float sectionLeft = x + sec.padding_left;
                float sectionRight = x + w - sec.padding_right;

                // Each card can appear at multiple positions (wrapping)
                for (int wrapOffset = -1; wrapOffset <= 1; wrapOffset++) {
                    float cardX = cardBoxes[i].x + carouselScrollOffset + (wrapOffset * totalCardsWidth);

                    // Skip if not visible
                    if (cardX + thisCardW < sectionLeft || cardX > sectionRight) continue;

                    // RENDER THIS CARD (carousel visible copy)
                    if (item.card_style == 1) {
                        DrawModernServiceCard(dl, cardX, thisCardY, thisCardW, thisCardH,
                                             item.title, item.description, item.bullet_points,
                                             item.icon_emoji, item.icon_color, item.title_color,
                                             item.anim_progress);
                    } else if (item.card_style == 2) {
                        DrawModernPortfolioCard(dl, cardX, thisCardY, thisCardW, thisCardH,
                                               item.title, item.description, item.tech_tags,
                                               item.category_badge, item.thumbnail_texture_id,
                                               item.title_color, item.anim_progress);
                    } else {
                        // Classic card rendering
                        ImVec4 cardBgColor = item.bg_color;
                        dl->AddRectFilled(ImVec2(cardX, thisCardY),
                                        ImVec2(cardX + thisCardW, thisCardY + thisCardH),
                                        ImGui::ColorConvertFloat4ToU32(cardBgColor), 8.0f);

                        // Card content
                        float contentX = cardX + sec.card_padding;
                        float contentY = thisCardY + sec.card_padding;
                        float contentW = thisCardW - 2 * sec.card_padding;

                        if (!item.icon_emoji.empty()) {
                            dl->AddText(ImGui::GetFont(), 32,
                                      ImVec2(contentX, contentY),
                                      IM_COL32(255, 255, 255, 255),
                                      item.icon_emoji.c_str());
                            contentY += 45;
                        }

                        ImVec4 titleCol = item.title_color;
                        dl->AddText(ImGui::GetFont(), 20,
                                  ImVec2(contentX, contentY),
                                  ImGui::ColorConvertFloat4ToU32(titleCol),
                                  item.title.c_str());
                        contentY += 28;

                        if (!item.description.empty()) {
                            ImVec4 descCol = item.desc_color;
                            dl->AddText(ImGui::GetFont(), 14,
                                      ImVec2(contentX, contentY),
                                      ImGui::ColorConvertFloat4ToU32(descCol),
                                      item.description.c_str());
                        }
                    }
                }

                // Continue to next card (carousel rendering done)
                continue;
            }
            else if (sec.animation_type != ANIM_NONE) {
                // STAGGERED ANIMATION (original behavior for other types)
                // Calculate stagger delay for smooth continuous animation
                // Each card starts after previous card (based on card index)
                float staggerDelay = i * sec.card_stagger_delay;  // User-configurable stagger

                // For continuous loop: use modulo to cycle smoothly
                float totalCycleTime = sec.animation_duration + (showCards * sec.card_stagger_delay);

                // Update animation for this card (always repeat for continuous effect)
                AnimationState& anim = AnimationEngine::UpdateAnimation(
                    sec.id * 1000 + i,           // Unique ID per card
                    sec.animation_type,
                    sec.animation_duration,      // User's custom duration
                    staggerDelay,                // Staggered start
                    true,                        // Always repeat for continuous
                    ImGui::GetIO().DeltaTime
                );

                // Apply animation transform
                LayoutRect animatedBox(cardX, thisCardY, thisCardW, thisCardH);
                animatedBox = AnimationEngine::ApplyAnimationTransform(animatedBox, anim);
                cardX = animatedBox.x;
                thisCardY = animatedBox.y;
                thisCardW = animatedBox.width;
                thisCardH = animatedBox.height;

                // Get opacity for fade effects
                animOpacity = anim.opacity;
            }

            if (thisCardY + thisCardH > y + h - 10) continue;

            // Check card style and use appropriate renderer
            if (item.card_style == 1) {
                // Modern service card (Screenshot 1 style)
                DrawModernServiceCard(dl, cardX, thisCardY, thisCardW, thisCardH,
                                     item.title, item.description,
                                     item.bullet_points, item.icon_emoji,
                                     item.icon_color, item.title_color,
                                     item.anim_progress);
            } else if (item.card_style == 2) {
                // Modern portfolio card (Screenshot 2 style)
                DrawModernPortfolioCard(dl, cardX, thisCardY, thisCardW, thisCardH,
                                       item.title, item.description,
                                       item.tech_tags, item.category_badge,
                                       item.thumbnail_texture_id, item.title_color,
                                       item.anim_progress);
            } else {
                // Old/classic card style (style 0 or default)
                if (item.glass_effect) {
                    // Use enhanced glass card effect
                    ImU32 tintCol = ImGui::ColorConvertFloat4ToU32(item.glass_tint);
                    ImU32 borderCol = ImGui::ColorConvertFloat4ToU32(item.glass_border_color);
                    DrawGlassCardEnhanced(dl, cardX, thisCardY, thisCardW, thisCardH,
                        item.glass_opacity, tintCol, item.glass_border_radius,
                        item.glass_border_width, borderCol, item.glass_highlight, item.glass_highlight_opacity);
                } else {
                    // Apply animation opacity to card background
                    ImVec4 cardBgColor = item.bg_color;
                    cardBgColor.w *= animOpacity;  // Apply fade animation

                    dl->AddRectFilled(ImVec2(cardX, thisCardY), ImVec2(cardX + thisCardW, thisCardY + thisCardH),
                                     ImGui::ColorConvertFloat4ToU32(cardBgColor), 8.0f);

                    // Border with animation opacity
                    ImU32 borderColor = IM_COL32(0, 0, 0, (int)(30 * animOpacity));
                    dl->AddRect(ImVec2(cardX, thisCardY), ImVec2(cardX + thisCardW, thisCardY + thisCardH),
                               borderColor, 8.0f);
                }

                // Clip text to card bounds to prevent overflow
                dl->PushClipRect(ImVec2(cardX, thisCardY), ImVec2(cardX + thisCardW, thisCardY + thisCardH), true);

                float textPadding = 12;  // Increased from 8 to 12 for better spacing
                float textMaxWidth = thisCardW - textPadding * 2;
                float contentStartY = thisCardY + textPadding;
                float availableHeight = thisCardH - textPadding * 2;

                if (!item.title.empty()) {
                    float titleHeight = DrawWrappedText(dl, item.title, cardX + textPadding, contentStartY, textMaxWidth, ImGui::ColorConvertFloat4ToU32(item.title_color), true, item.title_font_size, item.title_font_weight);
                    contentStartY += titleHeight + 6;  // Increased spacing between title and description
                    availableHeight -= (titleHeight + 6);
                }
                if (!item.description.empty() && availableHeight > 20) {
                    // Only draw description if there's enough space left
                    DrawWrappedText(dl, item.description, cardX + textPadding, contentStartY, textMaxWidth, ImGui::ColorConvertFloat4ToU32(item.desc_color), true, item.desc_font_size, item.desc_font_weight);
                }

                dl->PopClipRect();  // Remove clipping
            }
        }

        // Pop carousel clipping if it was active
        if (isCarousel) {
            dl->PopClipRect();
        }

        }  // End of else (non-Gallery sections)
        }  // End of if (!sec.items.empty())

        // If no cards but has paragraphs, render them below title
        if (sec.items.empty() && !sec.paragraphs.empty()) {
            float paraY = (sec.img_texture_id != 0) ? imageY : (y + sec.padding_top + 80);
            float paraMaxWidth = sectionW - sec.padding_left - sec.padding_right;
            float paraX = x + sec.padding_left;

            for (const auto& para : sec.paragraphs) {
                if (para.text.empty()) continue;

                // Render wrapped paragraph text
                float paraHeight = DrawWrappedText(dl, para.text, paraX, paraY, paraMaxWidth,
                                                   ImGui::ColorConvertFloat4ToU32(para.color),
                                                   true, para.font_size, para.font_weight);
                paraY += paraHeight + 16;  // Add spacing between paragraphs

                // Stop if we run out of space
                if (paraY > y + h - 20) break;
            }
        }

        return;
    }

    // Stats
    if (sec.type == SEC_STATS && !sec.items.empty()) {
        int n = (int)sec.items.size();
        float sw = (w - 60) / n;
        for (int i = 0; i < n; i++) {
            float ssx = x + 30 + i * sw;
            float centerX = ssx + sw / 2;

            // Title/Number with font properties
            ImFont* font = ImGui::GetFont();
            ImVec2 numSize = font->CalcTextSizeA(ValidFontSize(sec.items[i].title_font_size), FLT_MAX, 0.0f, sec.items[i].title.c_str());

            int titleLayers = (sec.items[i].title_font_weight >= 800.0f) ? 9 : ((sec.items[i].title_font_weight >= 500.0f) ? 4 : 1);
            float titleBoldStrength = (sec.items[i].title_font_weight >= 800.0f) ? 1.0f : ((sec.items[i].title_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (titleLayers > 1) {
                for (int layer = 0; layer < titleLayers; layer++) {
                    float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.items[i].title_font_size), ImVec2(centerX - numSize.x / 2 + offsetX, y + h / 2 - 20 + offsetY), ImGui::ColorConvertFloat4ToU32(sec.items[i].title_color), sec.items[i].title.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.items[i].title_font_size), ImVec2(centerX - numSize.x / 2, y + h / 2 - 20), ImGui::ColorConvertFloat4ToU32(sec.items[i].title_color), sec.items[i].title.c_str());
            }

            // Description/Label with font properties
            ImVec2 lblSize = font->CalcTextSizeA(ValidFontSize(sec.items[i].desc_font_size), FLT_MAX, 0.0f, sec.items[i].description.c_str());

            int descLayers = (sec.items[i].desc_font_weight >= 800.0f) ? 9 : ((sec.items[i].desc_font_weight >= 500.0f) ? 4 : 1);
            float descBoldStrength = (sec.items[i].desc_font_weight >= 800.0f) ? 1.0f : ((sec.items[i].desc_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (descLayers > 1) {
                for (int layer = 0; layer < descLayers; layer++) {
                    float offsetX = (layer % 3) * descBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * descBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.items[i].desc_font_size), ImVec2(centerX - lblSize.x / 2 + offsetX, y + h / 2 + 10 + offsetY), ImGui::ColorConvertFloat4ToU32(sec.items[i].desc_color), sec.items[i].description.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.items[i].desc_font_size), ImVec2(centerX - lblSize.x / 2, y + h / 2 + 10), ImGui::ColorConvertFloat4ToU32(sec.items[i].desc_color), sec.items[i].description.c_str());
            }
        }
        return;
    }

    // Contact - Different layouts based on layout_style
    if (sec.type == SEC_CONTACT) {
        // Clip contact section content to prevent overlap during scrolling
        dl->PushClipRect(mn, mx, true);

        float contentY = y + 50;

        // Render title (common to all layouts)
        if (!sec.title.empty()) {
            ImFont* font = ImGui::GetFont();
            ImVec2 titleSize = font->CalcTextSizeA(ValidFontSize(sec.title_font_size), FLT_MAX, 0.0f, sec.title.c_str());
            int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
            float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (titleLayers > 1) {
                for (int layer = 0; layer < titleLayers; layer++) {
                    float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2 + offsetX, contentY + offsetY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2, contentY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }
            contentY += titleSize.y + 25;
        }

        // Render different layouts based on layout_style
        if (sec.layout_style == 0) {
            // LAYOUT 0: CENTERED CARD
            float cardW = sectionW * 0.45f;
            float cardH = 180;
            float cardX = x + (sectionW - cardW) / 2;
            float cardY = contentY + 20;

            // Card background with glass effect
            dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.15f, 0.2f, 1.0f)), 8.0f);
            dl->AddRect(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                ImGui::ColorConvertFloat4ToU32(sec.title_color), 8.0f, 0, 2.0f);

            // Form fields with labels (using user-controlled sizes)
            float fieldY = cardY + 15;
            const char* labels[] = {"Name", "Email", "Message"};
            float inputW = cardW * (sec.contact_input_width / 100.0f);
            float inputH = sec.contact_input_height;
            float fieldSpacing = sec.contact_field_spacing;
            float inputX = cardX + (cardW - inputW) / 2;

            for (int f = 0; f < 3; f++) {
                dl->AddRectFilled(ImVec2(inputX, fieldY), ImVec2(inputX + inputW, fieldY + inputH),
                    IM_COL32(255, 255, 255, 30), 4.0f);
                dl->AddRect(ImVec2(inputX, fieldY), ImVec2(inputX + inputW, fieldY + inputH),
                    ImGui::ColorConvertFloat4ToU32(sec.title_color), 4.0f, 0, 1.5f);
                // Label text
                dl->AddText(ImVec2(inputX + 10, fieldY + (inputH - 14) / 2), IM_COL32(200, 200, 200, 180), labels[f]);
                fieldY += fieldSpacing;
            }

            // Button with text (using user-controlled sizes)
            float btnW = cardW * (sec.contact_button_width / 100.0f);
            float btnH = sec.contact_button_height;
            float btnX = cardX + (cardW - btnW) / 2;
            dl->AddRectFilled(ImVec2(btnX, fieldY + 10), ImVec2(btnX + btnW, fieldY + 10 + btnH),
                ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), 15.0f);
            dl->AddText(ImVec2(btnX + btnW/2 - 20, fieldY + 10 + (btnH - 14) / 2), IM_COL32(255, 255, 255, 255), "SEND");

        } else if (sec.layout_style == 1) {
            // LAYOUT 1: SPLIT SCREEN (Left image/info panel, Right form)
            float panelW = sectionW * 0.35f;
            float formW = sectionW * 0.4f;
            float leftX = x + sectionW * 0.1f;
            float rightX = x + sectionW * 0.55f;
            float panelH = 180;
            float panelY = contentY + 20;

            // LEFT PANEL - Show image if uploaded, else blue background
            if (sec.img_texture_id != 0) {
                // Render uploaded image filling the left panel
                dl->AddImage((ImTextureID)(intptr_t)sec.img_texture_id,
                    ImVec2(leftX, panelY),
                    ImVec2(leftX + panelW, panelY + panelH),
                    ImVec2(0,0), ImVec2(1,1));
                // Optional: border around image
                dl->AddRect(ImVec2(leftX, panelY), ImVec2(leftX + panelW, panelY + panelH),
                    IM_COL32(200, 200, 200, 100), 4.0f, 0, 1.5f);
            } else {
                // Default: Blue background with placeholder
                dl->AddRectFilled(ImVec2(leftX, panelY), ImVec2(leftX + panelW, panelY + panelH),
                    ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.4f, 0.8f, 1.0f)), 4.0f);

                // Icon/placeholder circle in left panel
                float circleR = 25;
                float circleX = leftX + panelW / 2;
                float circleY = panelY + 40;
                dl->AddCircleFilled(ImVec2(circleX, circleY), circleR, IM_COL32(255, 255, 255, 60));

                // Info lines in left panel
                for (int ln = 0; ln < 3; ln++) {
                    float lineY = circleY + 35 + (ln * 15);
                    dl->AddRectFilled(ImVec2(leftX + 15, lineY), ImVec2(leftX + panelW - 15, lineY + 6),
                        IM_COL32(255, 255, 255, 180), 2.0f);
                }
            }

            // RIGHT PANEL (Form area) - White
            dl->AddRectFilled(ImVec2(rightX, panelY), ImVec2(rightX + formW, panelY + panelH),
                IM_COL32(255, 255, 255, 255), 4.0f);
            dl->AddRect(ImVec2(rightX, panelY), ImVec2(rightX + formW, panelY + panelH),
                IM_COL32(200, 200, 200, 255), 4.0f, 0, 1.0f);

            // Form fields in right panel with labels (using user-controlled sizes)
            float fieldY = panelY + 20;
            const char* labels2[] = {"Name", "Email", "Message"};
            float inputW2 = formW * (sec.contact_input_width / 100.0f);
            float inputH2 = sec.contact_input_height;
            float fieldSpacing2 = sec.contact_field_spacing;
            float inputX2 = rightX + (formW - inputW2) / 2;

            for (int f = 0; f < 3; f++) {
                dl->AddRectFilled(ImVec2(inputX2, fieldY), ImVec2(inputX2 + inputW2, fieldY + inputH2),
                    IM_COL32(245, 245, 245, 255), 3.0f);
                dl->AddRect(ImVec2(inputX2, fieldY), ImVec2(inputX2 + inputW2, fieldY + inputH2),
                    IM_COL32(180, 180, 180, 255), 3.0f, 0, 1.0f);
                // Label text
                dl->AddText(ImVec2(inputX2 + 8, fieldY + (inputH2 - 14) / 2), IM_COL32(120, 120, 120, 255), labels2[f]);
                fieldY += fieldSpacing2;
            }

            // Button in right panel with text (using user-controlled sizes)
            float btnW2 = formW * (sec.contact_button_width / 100.0f);
            float btnH2 = sec.contact_button_height;
            float btnX2 = rightX + (formW - btnW2) / 2;
            dl->AddRectFilled(ImVec2(btnX2, fieldY + 10), ImVec2(btnX2 + btnW2, fieldY + 10 + btnH2),
                ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.4f, 0.8f, 1.0f)), 12.0f);
            dl->AddText(ImVec2(btnX2 + btnW2/2 - 20, fieldY + 10 + (btnH2 - 14) / 2), IM_COL32(255, 255, 255, 255), "SEND");

        } else if (sec.layout_style == 2) {
            // LAYOUT 2: TWO COLUMN GRID
            float boxW = sectionW * 0.55f;
            float boxH = 180;
            float boxX = x + (sectionW - boxW) / 2;
            float boxY = contentY + 20;

            // Container box
            dl->AddRectFilled(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                IM_COL32(255, 255, 255, 255), 6.0f);
            dl->AddRect(ImVec2(boxX, boxY), ImVec2(boxX + boxW, boxY + boxH),
                ImGui::ColorConvertFloat4ToU32(sec.title_color), 6.0f, 0, 2.0f);

            // Title bar inside
            float headerY = boxY + 15;
            dl->AddRectFilled(ImVec2(boxX + 20, headerY), ImVec2(boxX + boxW - 20, headerY + 8),
                ImGui::ColorConvertFloat4ToU32(sec.title_color), 2.0f);

            // Two column fields (using user-controlled sizes)
            float inputH3 = sec.contact_input_height;
            float fieldSpacing3 = sec.contact_field_spacing;
            float colW = (boxW - 50) / 2;
            float leftColX = boxX + 15;
            float rightColX = boxX + 15 + colW + 20;
            float rowY = headerY + 25;

            // Row 1: Name | Email
            const char* row1Labels[] = {"Name", "Email"};
            for (int col = 0; col < 2; col++) {
                float fieldX = (col == 0) ? leftColX : rightColX;
                dl->AddRectFilled(ImVec2(fieldX, rowY), ImVec2(fieldX + colW, rowY + inputH3),
                    IM_COL32(245, 245, 245, 255), 3.0f);
                dl->AddRect(ImVec2(fieldX, rowY), ImVec2(fieldX + colW, rowY + inputH3),
                    ImGui::ColorConvertFloat4ToU32(sec.title_color), 3.0f, 0, 1.0f);
                // Label text
                dl->AddText(ImVec2(fieldX + 8, rowY + (inputH3 - 14) / 2), IM_COL32(100, 100, 100, 255), row1Labels[col]);
            }

            // Row 2: Phone | Company
            rowY += fieldSpacing3;
            const char* row2Labels[] = {"Phone", "Company"};
            for (int col = 0; col < 2; col++) {
                float fieldX = (col == 0) ? leftColX : rightColX;
                dl->AddRectFilled(ImVec2(fieldX, rowY), ImVec2(fieldX + colW, rowY + inputH3),
                    IM_COL32(245, 245, 245, 255), 3.0f);
                dl->AddRect(ImVec2(fieldX, rowY), ImVec2(fieldX + colW, rowY + inputH3),
                    ImGui::ColorConvertFloat4ToU32(sec.title_color), 3.0f, 0, 1.0f);
                // Label text
                dl->AddText(ImVec2(fieldX + 8, rowY + (inputH3 - 14) / 2), IM_COL32(100, 100, 100, 255), row2Labels[col]);
            }

            // Full width message field
            rowY += fieldSpacing3;
            dl->AddRectFilled(ImVec2(leftColX, rowY), ImVec2(rightColX + colW, rowY + inputH3),
                IM_COL32(245, 245, 245, 255), 3.0f);
            dl->AddRect(ImVec2(leftColX, rowY), ImVec2(rightColX + colW, rowY + inputH3),
                ImGui::ColorConvertFloat4ToU32(sec.title_color), 3.0f, 0, 1.0f);
            // Message label
            dl->AddText(ImVec2(leftColX + 8, rowY + (inputH3 - 14) / 2), IM_COL32(100, 100, 100, 255), "Message");

            // Button with text (using user-controlled sizes)
            rowY += fieldSpacing3;
            float btnW3 = (rightColX + colW - leftColX) * (sec.contact_button_width / 100.0f);
            float btnH3 = sec.contact_button_height;
            float btnX3 = leftColX + ((rightColX + colW - leftColX) - btnW3) / 2;
            dl->AddRectFilled(ImVec2(btnX3, rowY), ImVec2(btnX3 + btnW3, rowY + btnH3),
                ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), 15.0f);
            float btnTextX = btnX3 + btnW3/2 - 25;
            dl->AddText(ImVec2(btnTextX, rowY + (btnH3 - 14) / 2), IM_COL32(255, 255, 255, 255), "SUBMIT");

        } else if (sec.layout_style == 3) {
            // LAYOUT 3: HORIZONTAL WIDE with top decorative area
            float containerW = sectionW * 0.6f;
            float containerX = x + (sectionW - containerW) / 2;
            float containerY = contentY + 20;

            // Top decorative image area
            float topH = 50;
            dl->AddRectFilled(ImVec2(containerX, containerY), ImVec2(containerX + containerW, containerY + topH),
                ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.15f, 0.4f, 1.0f)), 8.0f);

            // Circles in decorative area
            for (int c = 0; c < 4; c++) {
                float circleX = containerX + 60 + (c * (containerW - 120) / 3);
                dl->AddCircleFilled(ImVec2(circleX, containerY + topH/2), 15, IM_COL32(255, 150, 200, 80));
            }

            // Form area below
            float formY = containerY + topH + 10;
            float formH = 100;
            dl->AddRectFilled(ImVec2(containerX, formY), ImVec2(containerX + containerW, formY + formH),
                IM_COL32(255, 255, 255, 255), 8.0f);

            // Horizontal fields in rows with labels (using user-controlled sizes)
            float inputH4 = sec.contact_input_height;
            float fieldSpacing4 = sec.contact_field_spacing;
            float fieldW = (containerW - 40) / 3;
            float fieldY = formY + 15;

            const char* horizLabels[] = {"Name", "Email", "Phone", "Company", "Subject", "City"};
            for (int row = 0; row < 2; row++) {
                for (int col = 0; col < 3; col++) {
                    float fieldX = containerX + 10 + (col * (fieldW + 5));
                    dl->AddRectFilled(ImVec2(fieldX, fieldY), ImVec2(fieldX + fieldW, fieldY + inputH4),
                        IM_COL32(245, 240, 245, 255), 4.0f);
                    dl->AddRect(ImVec2(fieldX, fieldY), ImVec2(fieldX + fieldW, fieldY + inputH4),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.3f, 0.5f, 0.6f)), 4.0f, 0, 1.5f);
                    // Label text
                    int labelIdx = row * 3 + col;
                    dl->AddText(ImVec2(fieldX + 6, fieldY + (inputH4 - 14) / 2), IM_COL32(120, 80, 120, 255), horizLabels[labelIdx]);
                }
                fieldY += fieldSpacing4;
            }

            // Wide button with text (using user-controlled sizes)
            fieldY += 10;
            float btnW4 = (containerW - 20) * (sec.contact_button_width / 100.0f);
            float btnH4 = sec.contact_button_height;
            float btnX4 = containerX + (containerW - btnW4) / 2;
            dl->AddRectFilled(ImVec2(btnX4, fieldY), ImVec2(btnX4 + btnW4, fieldY + btnH4),
                ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), 15.0f);
            float sendBtnX = btnX4 + btnW4/2 - 25;
            dl->AddText(ImVec2(sendBtnX, fieldY + (btnH4 - 14) / 2), IM_COL32(255, 255, 255, 255), "SEND");

        } else {
            // LAYOUT 4: ELEGANT DARK CARD with shadow
            float cardW = sectionW * 0.4f;
            float cardH = 160;
            float cardX = x + (sectionW - cardW) / 2;
            float cardY = contentY + 20;

            // Back shadow
            dl->AddRectFilled(ImVec2(cardX + 8, cardY + 8), ImVec2(cardX + cardW + 8, cardY + cardH + 8),
                IM_COL32(10, 10, 15, 150), 10.0f);

            // Main card
            dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                ImGui::ColorConvertFloat4ToU32(ImVec4(0.18f, 0.18f, 0.24f, 1.0f)), 10.0f);
            dl->AddRect(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                IM_COL32(230, 230, 230, 50), 10.0f, 0, 1.5f);

            // Title bar inside card
            float inCardY = cardY + 20;
            dl->AddRectFilled(ImVec2(cardX + 20, inCardY), ImVec2(cardX + cardW - 20, inCardY + 10),
                IM_COL32(230, 230, 230, 255), 2.0f);

            // Form fields with elegant borders and labels (using user-controlled sizes)
            float inputW5 = cardW * (sec.contact_input_width / 100.0f);
            float inputH5 = sec.contact_input_height;
            float fieldSpacing5 = sec.contact_field_spacing;
            float fieldY = inCardY + 25;
            float inputX5 = cardX + (cardW - inputW5) / 2;
            const char* darkLabels[] = {"Name", "Email", "Message"};
            for (int f = 0; f < 3; f++) {
                dl->AddRectFilled(ImVec2(inputX5, fieldY), ImVec2(inputX5 + inputW5, fieldY + inputH5),
                    ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.15f, 0.2f, 1.0f)), 4.0f);
                dl->AddRect(ImVec2(inputX5, fieldY), ImVec2(inputX5 + inputW5, fieldY + inputH5),
                    IM_COL32(230, 230, 230, 80), 4.0f, 0, 1.0f);
                // Label text (light colored for dark background)
                dl->AddText(ImVec2(inputX5 + 8, fieldY + (inputH5 - 14) / 2), IM_COL32(200, 200, 200, 200), darkLabels[f]);
                fieldY += fieldSpacing5;
            }

            // Elegant button with text (using user-controlled sizes)
            fieldY += 10;
            float btnW5 = cardW * (sec.contact_button_width / 100.0f);
            float btnH5 = sec.contact_button_height;
            float btnX5 = cardX + (cardW - btnW5) / 2;
            dl->AddRectFilled(ImVec2(btnX5, fieldY), ImVec2(btnX5 + btnW5, fieldY + btnH5),
                ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), 15.0f);
            float elegantBtnX = btnX5 + btnW5/2 - 25;
            dl->AddText(ImVec2(elegantBtnX, fieldY + (btnH5 - 14) / 2), IM_COL32(20, 20, 20, 255), "SEND");
        }

        // Remove clipping for contact section
        dl->PopClipRect();

        return;
    }

    // Footer
    if (sec.type == SEC_FOOTER) {
        ImFont* font = ImGui::GetFont();
        if (!sec.title.empty()) {
            ImVec2 titleSize = font->CalcTextSizeA(ValidFontSize(sec.title_font_size), FLT_MAX, 0.0f, sec.title.c_str());

            int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
            float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (titleLayers > 1) {
                for (int layer = 0; layer < titleLayers; layer++) {
                    float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2 + offsetX, y + h * 0.3f + offsetY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2, y + h * 0.3f), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }
        }
        if (!sec.content.empty()) {
            std::string copyright = "¬© " + sec.content;
            ImVec2 cSize = font->CalcTextSizeA(ValidFontSize(sec.content_font_size), FLT_MAX, 0.0f, copyright.c_str());

            int contentLayers = (sec.content_font_weight >= 800.0f) ? 9 : ((sec.content_font_weight >= 500.0f) ? 4 : 1);
            float contentBoldStrength = (sec.content_font_weight >= 800.0f) ? 1.0f : ((sec.content_font_weight >= 500.0f) ? 0.5f : 0.0f);

            if (contentLayers > 1) {
                for (int layer = 0; layer < contentLayers; layer++) {
                    float offsetX = (layer % 3) * contentBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * contentBoldStrength * 0.5f;
                    dl->AddText(font, ValidFontSize(sec.content_font_size), ImVec2(cx - cSize.x / 2 + offsetX, y + h * 0.75f + offsetY), ImGui::ColorConvertFloat4ToU32(sec.content_color), copyright.c_str());
                }
            } else {
                dl->AddText(font, ValidFontSize(sec.content_font_size), ImVec2(cx - cSize.x / 2, y + h * 0.75f), ImGui::ColorConvertFloat4ToU32(sec.content_color), copyright.c_str());
            }
        }
        return;
    }

    // Image Section - Standalone moveable image with width control
    if (sec.type == SEC_IMAGE) {
        // Width and alignment already calculated at top of function
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        if (sec.img_texture_id != 0) {
            // Render the image filling the section area (works for both file and database images)
            dl->AddImage((ImTextureID)(intptr_t)sec.img_texture_id, section_min, section_max);

            // Show "Image" label
            dl->AddRectFilled(ImVec2(x + 5, y + 5), ImVec2(x + 60, y + 22),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.7f, 0.9f, 0.8f)), 3.0f);
            dl->AddText(ImVec2(x + 10, y + 6), IM_COL32(255, 255, 255, 255), "IMAGE");
        } else {
            // No image uploaded yet - show placeholder
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(ImVec4(0.15f, 0.15f, 0.15f, 1.0f)));
            dl->AddRect(section_min, section_max, ImGui::ColorConvertFloat4ToU32(ImVec4(0.4f, 0.4f, 0.4f, 1.0f)), 0, 0, 2.0f);

            // Centered text
            const char* placeholder_text = "Upload Image";
            ImFont* font = ImGui::GetFont();
            ImVec2 textSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, placeholder_text);
            float textX = x + (sectionW - textSize.x) / 2;
            float textY = y + (h - textSize.y) / 2;
            dl->AddText(font, 14.0f, ImVec2(textX, textY),
                       ImGui::ColorConvertFloat4ToU32(ImVec4(0.6f, 0.6f, 0.6f, 1.0f)), placeholder_text);

            // Show "Image" label
            dl->AddRectFilled(ImVec2(x + 5, y + 5), ImVec2(x + 60, y + 22),
                            ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.7f, 0.9f, 0.8f)), 3.0f);
            dl->AddText(ImVec2(x + 10, y + 6), IM_COL32(255, 255, 255, 255), "IMAGE");
        }

        // Show width indicator border
        dl->AddRect(section_min, section_max, IM_COL32(100, 200, 255, 150), 0, 0, 1.0f);

        return;
    }

    // Text Box Section - Standalone text area with width control
    if (sec.type == SEC_TEXTBOX) {
        // Width and alignment already calculated at top of function
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background color
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Clip content to section bounds
        dl->PushClipRect(section_min, section_max, true);

        ImFont* font = ImGui::GetFont();
        // Use 4-sided padding for proper spacing
        float padLeft = sec.padding_left;
        float padRight = sec.padding_right;
        float padTop = sec.padding_top;
        float padBottom = sec.padding_bottom;

        float contentX = x + padLeft;
        float currentY = y + padTop;
        float sectionCenterX = x + sectionW / 2;

        // Helper for text alignment (within this section)
        auto GetAlignedX = [&](float textWidth) {
            if (sec.text_align == 1) return sectionCenterX - textWidth / 2;  // Center
            if (sec.text_align == 2) return x + sectionW - padRight - textWidth;  // Right
            return contentX;  // Left (default)
        };

        // Render Title
        if (!sec.title.empty()) {
            float titleFS = ValidFontSize(sec.title_font_size);
            ImVec2 titleSize = font->CalcTextSizeA(titleFS, FLT_MAX, 0.0f, sec.title.c_str());

            int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
            float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

            float titleX = GetAlignedX(titleSize.x);

            if (titleLayers > 1) {
                for (int layer = 0; layer < titleLayers; layer++) {
                    float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                    dl->AddText(font, titleFS, ImVec2(titleX + offsetX, currentY + offsetY),
                               ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
                }
            } else {
                dl->AddText(font, titleFS, ImVec2(titleX, currentY),
                           ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }

            currentY += titleSize.y + 15;
        }

        // Render Subtitle
        if (!sec.subtitle.empty()) {
            float subtitleFS = ValidFontSize(sec.subtitle_font_size);
            ImVec2 subtitleSize = font->CalcTextSizeA(subtitleFS, FLT_MAX, 0.0f, sec.subtitle.c_str());

            int subtitleLayers = (sec.subtitle_font_weight >= 800.0f) ? 9 : ((sec.subtitle_font_weight >= 500.0f) ? 4 : 1);
            float subtitleBoldStrength = (sec.subtitle_font_weight >= 800.0f) ? 1.0f : ((sec.subtitle_font_weight >= 500.0f) ? 0.5f : 0.0f);

            float subtitleX = GetAlignedX(subtitleSize.x);

            if (subtitleLayers > 1) {
                for (int layer = 0; layer < subtitleLayers; layer++) {
                    float offsetX = (layer % 3) * subtitleBoldStrength * 0.5f;
                    float offsetY = (layer / 3) * subtitleBoldStrength * 0.5f;
                    dl->AddText(font, subtitleFS, ImVec2(subtitleX + offsetX, currentY + offsetY),
                               ImGui::ColorConvertFloat4ToU32(sec.subtitle_color), sec.subtitle.c_str());
                }
            } else {
                dl->AddText(font, subtitleFS, ImVec2(subtitleX, currentY),
                           ImGui::ColorConvertFloat4ToU32(sec.subtitle_color), sec.subtitle.c_str());
            }

            currentY += subtitleSize.y + 10;
        }

        // Render Content (with word wrap)
        if (!sec.content.empty()) {
            float contentFS = ValidFontSize(sec.content_font_size);
            float wrapWidth = sectionW - padLeft - padRight;

            int contentLayers = (sec.content_font_weight >= 800.0f) ? 9 : ((sec.content_font_weight >= 500.0f) ? 4 : 1);
            float contentBoldStrength = (sec.content_font_weight >= 800.0f) ? 1.0f : ((sec.content_font_weight >= 500.0f) ? 0.5f : 0.0f);

            // Simple word wrap implementation
            std::string text = sec.content;
            std::string line;
            float lineY = currentY;

            std::istringstream words(text);
            std::string word;
            while (words >> word) {
                std::string testLine = line.empty() ? word : line + " " + word;
                ImVec2 testSize = font->CalcTextSizeA(contentFS, FLT_MAX, 0.0f, testLine.c_str());

                if (testSize.x > wrapWidth && !line.empty()) {
                    // Draw current line
                    float lineX = GetAlignedX(font->CalcTextSizeA(contentFS, FLT_MAX, 0.0f, line.c_str()).x);

                    if (contentLayers > 1) {
                        for (int layer = 0; layer < contentLayers; layer++) {
                            float offsetX = (layer % 3) * contentBoldStrength * 0.5f;
                            float offsetY = (layer / 3) * contentBoldStrength * 0.5f;
                            dl->AddText(font, contentFS, ImVec2(lineX + offsetX, lineY + offsetY),
                                       ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                        }
                    } else {
                        dl->AddText(font, contentFS, ImVec2(lineX, lineY),
                                   ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                    }

                    lineY += contentFS + 5;
                    line = word;
                } else {
                    line = testLine;
                }
            }

            // Draw last line
            if (!line.empty()) {
                float lineX = GetAlignedX(font->CalcTextSizeA(contentFS, FLT_MAX, 0.0f, line.c_str()).x);

                if (contentLayers > 1) {
                    for (int layer = 0; layer < contentLayers; layer++) {
                        float offsetX = (layer % 3) * contentBoldStrength * 0.5f;
                        float offsetY = (layer / 3) * contentBoldStrength * 0.5f;
                        dl->AddText(font, contentFS, ImVec2(lineX + offsetX, lineY + offsetY),
                                   ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                    }
                } else {
                    dl->AddText(font, contentFS, ImVec2(lineX, lineY),
                               ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                }
            }
        }

        // Pop clip rect before drawing UI elements
        dl->PopClipRect();

        // Show "TEXT BOX" label
        dl->AddRectFilled(ImVec2(x + 5, y + 5), ImVec2(x + 80, y + 22),
                        ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.6f, 0.2f, 0.8f)), 3.0f);
        dl->AddText(ImVec2(x + 10, y + 6), IM_COL32(255, 255, 255, 255), "TEXT BOX");

        // Show width indicator border
        dl->AddRect(section_min, section_max, IM_COL32(255, 180, 80, 150), 0, 0, 1.0f);

        return;
    }

    // ==================== BASIC ELEMENTS (Free Design Mode) ====================

    // Logo Element
    if (sec.type == SEC_LOGO) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        if (sec.bg_color.w > 0.01f) {
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color), 6.0f);
        }

        // If logo image is loaded, show image
        if (sec.logo_texture_id > 0) {
            // Calculate image size to fit within bounds while maintaining aspect ratio
            float padding = 4.0f;
            float availW = sectionW - padding * 2;
            float availH = h - padding * 2;
            float imgX = x + padding;
            float imgY = y + padding;

            // Draw the logo image
            dl->AddImage((ImTextureID)(intptr_t)sec.logo_texture_id,
                        ImVec2(imgX, imgY),
                        ImVec2(imgX + availW, imgY + availH),
                        ImVec2(0, 0), ImVec2(1, 1),
                        IM_COL32(255, 255, 255, 255));
        } else {
            // Show placeholder text if no image
            ImFont* font = ImGui::GetFont();
            float logoFS = 24.0f;
            const char* displayText = sec.title.empty() ? "[Logo Image]" : sec.title.c_str();
            ImVec2 logoSize = font->CalcTextSizeA(logoFS, FLT_MAX, 0.0f, displayText);
            float logoX = x + (sectionW - logoSize.x) / 2;
            float logoY = y + (h - logoSize.y) / 2;
            dl->AddText(font, logoFS, ImVec2(logoX, logoY), ImGui::ColorConvertFloat4ToU32(sec.text_color), displayText);
        }

        // Border
        dl->AddRect(section_min, section_max, IM_COL32(100, 200, 255, 150), 6.0f, 0, 1.0f);
        return;
    }

    // Heading Element
    if (sec.type == SEC_HEADING) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background (transparent by default)
        if (sec.bg_color.w > 0.01f) {
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));
        }

        // Heading text
        ImFont* font = ImGui::GetFont();
        float headingFS = ValidFontSize(sec.title_font_size);
        ImVec2 headingSize = font->CalcTextSizeA(headingFS, FLT_MAX, 0.0f, sec.title.c_str());
        float headingX = x + 10;
        float headingY = y + (h - headingSize.y) / 2;

        // Bold rendering for heavy weights
        int layers = (sec.title_font_weight >= 700.0f) ? 4 : 1;
        for (int layer = 0; layer < layers; layer++) {
            float offsetX = (layer % 2) * 0.5f;
            float offsetY = (layer / 2) * 0.5f;
            dl->AddText(font, headingFS, ImVec2(headingX + offsetX, headingY + offsetY),
                       ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
        }

        // Selection border
        dl->AddRect(section_min, section_max, IM_COL32(100, 200, 100, 100), 0, 0, 1.0f);
        return;
    }

    // Text Element with word wrap
    if (sec.type == SEC_TEXT_ELEMENT) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Clip content to section bounds
        dl->PushClipRect(section_min, section_max, true);

        // Background (transparent by default)
        if (sec.bg_color.w > 0.01f) {
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));
        }

        // Text content with word wrap (using margins)
        ImFont* font = ImGui::GetFont();
        float textFS = ValidFontSize(sec.content_font_size);
        float maxWidth = sectionW - sec.margin_left - sec.margin_right;
        float textX = x + sec.margin_left;
        float textY = y + sec.margin_top;

        // Word wrap the text
        std::string text = sec.content;
        std::string line;
        std::string word;
        float lineHeight = textFS * 1.2f;

        for (size_t i = 0; i <= text.length(); i++) {
            char c = (i < text.length()) ? text[i] : ' ';

            if (c == ' ' || c == '\n' || i == text.length()) {
                if (!word.empty()) {
                    std::string testLine = line.empty() ? word : line + " " + word;
                    ImVec2 testSize = font->CalcTextSizeA(textFS, FLT_MAX, 0.0f, testLine.c_str());

                    if (testSize.x > maxWidth && !line.empty()) {
                        // Draw current line and start new one
                        dl->AddText(font, textFS, ImVec2(textX, textY),
                                   ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                        textY += lineHeight;
                        line = word;
                    } else {
                        line = testLine;
                    }
                    word.clear();
                }

                if (c == '\n') {
                    // Draw line and force new line
                    if (!line.empty()) {
                        dl->AddText(font, textFS, ImVec2(textX, textY),
                                   ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
                        textY += lineHeight;
                        line.clear();
                    }
                }
            } else {
                word += c;
            }
        }

        // Draw remaining line
        if (!line.empty()) {
            dl->AddText(font, textFS, ImVec2(textX, textY),
                       ImGui::ColorConvertFloat4ToU32(sec.content_color), line.c_str());
        }

        dl->PopClipRect();

        // Selection border
        dl->AddRect(section_min, section_max, IM_COL32(150, 150, 150, 100), 0, 0, 1.0f);
        return;
    }

    // Button Element (with action)
    if (sec.type == SEC_BUTTON_ELEMENT) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Button background with rounded corners
        float radius = sec.button_border_radius > 0 ? sec.button_border_radius : 6.0f;
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.button_bg_color), radius);

        // Button text centered
        ImFont* font = ImGui::GetFont();
        float btnFS = ValidFontSize(sec.button_font_size);
        ImVec2 btnTextSize = font->CalcTextSizeA(btnFS, FLT_MAX, 0.0f, sec.button_text.c_str());
        float btnTextX = x + (sectionW - btnTextSize.x) / 2;
        float btnTextY = y + (h - btnTextSize.y) / 2;
        dl->AddText(font, btnFS, ImVec2(btnTextX, btnTextY),
                   ImGui::ColorConvertFloat4ToU32(sec.button_text_color), sec.button_text.c_str());

        // Border
        if (sec.button_border_width > 0) {
            dl->AddRect(section_min, section_max,
                       ImGui::ColorConvertFloat4ToU32(sec.button_border_color), radius, 0, sec.button_border_width);
        }

        // Hover indicator (shown in edit mode)
        dl->AddRect(section_min, section_max, IM_COL32(100, 200, 255, 100), radius, 0, 1.0f);
        return;
    }

    // ==================== CONNECTOR SECTIONS ====================

    // Text Block Connector with word wrap
    if (sec.type == SEC_TEXT_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Clip content to section bounds
        dl->PushClipRect(section_min, section_max, true);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Render text blocks with word wrap (using margins)
        float textY = y + sec.margin_top + sec.text_padding;
        // Use section width minus margins and padding if content width exceeds it
        float availableWidth = sectionW - sec.margin_left - sec.margin_right - (sec.text_padding * 2);
        float maxWidth = (sec.text_content_width < availableWidth) ? sec.text_content_width : availableWidth;
        float textX = x + sec.margin_left + (sectionW - sec.margin_left - sec.margin_right - maxWidth) / 2;

        for (const auto& block : sec.text_blocks) {
            ImFont* font = ImGui::GetFont();
            float fs = block.fontSize;
            float lineHeight = fs * block.lineSpacing;

            // Combine all segments into one string for word wrapping
            std::string fullText;
            std::vector<std::pair<size_t, size_t>> boldRanges;  // start, end positions of bold text

            for (const auto& seg : block.segments) {
                if (seg.isBold) {
                    boldRanges.push_back({fullText.length(), fullText.length() + seg.text.length()});
                }
                fullText += seg.text;
            }

            // Word wrap the combined text
            std::string line;
            std::string word;
            float lineX = textX;
            size_t charPos = 0;
            size_t lineStartPos = 0;

            auto isBoldAt = [&](size_t pos) -> bool {
                for (const auto& range : boldRanges) {
                    if (pos >= range.first && pos < range.second) return true;
                }
                return false;
            };

            auto drawLine = [&](const std::string& lineText, size_t startPos) {
                float drawX = textX;
                for (size_t i = 0; i < lineText.length(); i++) {
                    // Find run of same style
                    bool bold = isBoldAt(startPos + i);
                    size_t runStart = i;
                    while (i < lineText.length() && isBoldAt(startPos + i) == bold) {
                        i++;
                    }
                    i--;  // Back up one since loop will increment

                    std::string run = lineText.substr(runStart, i - runStart + 1);
                    ImVec4 color = bold ? block.boldColor : block.textColor;
                    ImVec2 runSize = font->CalcTextSizeA(fs, FLT_MAX, 0.0f, run.c_str());

                    if (bold) {
                        for (int pass = 0; pass < 3; pass++) {
                            dl->AddText(font, fs, ImVec2(drawX + pass * 0.4f, textY),
                                       ImGui::ColorConvertFloat4ToU32(color), run.c_str());
                        }
                    } else {
                        dl->AddText(font, fs, ImVec2(drawX, textY),
                                   ImGui::ColorConvertFloat4ToU32(color), run.c_str());
                    }
                    drawX += runSize.x;
                }
                textY += lineHeight;
            };

            for (size_t i = 0; i <= fullText.length(); i++) {
                char c = (i < fullText.length()) ? fullText[i] : ' ';

                if (c == ' ' || c == '\n' || i == fullText.length()) {
                    if (!word.empty()) {
                        std::string testLine = line.empty() ? word : line + " " + word;
                        ImVec2 testSize = font->CalcTextSizeA(fs, FLT_MAX, 0.0f, testLine.c_str());

                        if (testSize.x > maxWidth && !line.empty()) {
                            // Draw current line and start new one
                            drawLine(line, lineStartPos);
                            lineStartPos = charPos - word.length();
                            line = word;
                        } else {
                            line = testLine;
                        }
                        word.clear();
                    }

                    if (c == '\n') {
                        if (!line.empty()) {
                            drawLine(line, lineStartPos);
                            line.clear();
                        } else {
                            textY += lineHeight;  // Empty line
                        }
                        lineStartPos = i + 1;
                    }

                    charPos = i + 1;
                } else {
                    word += c;
                    charPos = i + 1;
                }
            }

            // Draw remaining line
            if (!line.empty()) {
                drawLine(line, lineStartPos);
            }
        }

        dl->PopClipRect();

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // Bar Heading Connector
    if (sec.type == SEC_BAR_CONNECTOR) {
        // Draw section background
        dl->AddRectFilled(ImVec2(x, y), ImVec2(x + sectionW, y + h),
                         ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        for (size_t i = 0; i < sec.bar_items.size(); i++) {
            const BarItem& bar = sec.bar_items[i];
            float barY = y + i * (bar.barHeight + 10);
            float barX = x + (sectionW - bar.barWidth) / 2;

            // Draw bar background
            dl->AddRectFilled(ImVec2(barX, barY),
                             ImVec2(barX + bar.barWidth, barY + bar.barHeight),
                             ImGui::ColorConvertFloat4ToU32(bar.barColor));

            // Draw heading text with boldness
            ImFont* font = ImGui::GetFont();
            float fs = 18.0f * bar.headingSize;
            ImVec2 textSize = font->CalcTextSizeA(fs, FLT_MAX, 0.0f, bar.heading);
            float textY = barY + (bar.barHeight - textSize.y) / 2;

            // Bold effect with multiple passes
            int passes = (int)(bar.headingBoldness * 2) + 1;
            for (int p = 0; p < passes; p++) {
                dl->AddText(font, fs, ImVec2(barX + bar.paddingLeft + p * 0.4f, textY),
                           ImGui::ColorConvertFloat4ToU32(bar.headingColor), bar.heading);
            }
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(ImVec2(x, y), ImVec2(x + sectionW, y + h), IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // Footer Columns Connector
    if (sec.type == SEC_FOOTER_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Calculate column layout
        int numCols = (int)sec.footer_columns.size();
        if (numCols == 0) numCols = 1;
        float colWidth = sec.footer_column_width;
        float totalWidth = numCols * colWidth;
        float startX = x + (sectionW - totalWidth) / 2;
        float startY = y + 30;

        ImFont* font = ImGui::GetFont();

        for (int i = 0; i < (int)sec.footer_columns.size(); i++) {
            const FooterColumn& col = sec.footer_columns[i];
            float colX = startX + i * colWidth;
            float colY = startY;

            // Draw column heading with boldness
            float headingFS = 18.0f * sec.footer_heading_size;
            int headingPasses = (int)(sec.footer_heading_boldness * 2) + 1;
            for (int p = 0; p < headingPasses; p++) {
                dl->AddText(font, headingFS, ImVec2(colX + p * 0.4f, colY),
                           ImGui::ColorConvertFloat4ToU32(sec.footer_heading_color), col.heading);
            }
            colY += headingFS + 15;

            // Draw subitems
            float subFS = 16.0f * sec.footer_subheading_size;
            for (const auto& item : col.items) {
                dl->AddText(font, subFS, ImVec2(colX, colY),
                           ImGui::ColorConvertFloat4ToU32(sec.footer_subheading_color), item.c_str());
                colY += subFS + sec.footer_item_spacing;
            }
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // Thumbnail Cards Connector
    if (sec.type == SEC_CARD_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Clip content to section bounds (but not resize handles)
        dl->PushClipRect(section_min, section_max, true);

        // Calculate card layout
        int numCards = (int)sec.connector_cards.size();
        int cardsPerRow = sec.connector_cards_per_row > 0 ? sec.connector_cards_per_row : 3;
        float spacing = sec.connector_card_spacing;
        float padding = sec.connector_card_padding;  // Use section's padding setting

        ImFont* font = ImGui::GetFont();

        // Simple layout: use card's own dimensions, start from padding
        float startX = x + padding;
        float startY = y + padding;
        float currentY = startY;

        for (int i = 0; i < numCards; i++) {
            const ThumbnailCard& card = sec.connector_cards[i];
            int col = i % cardsPerRow;
            int row = i / cardsPerRow;

            // Use card's actual dimensions from sliders
            float cardW = card.cardWidth;
            float cardH = card.cardHeight;

            // Calculate X position - sum widths of previous cards in this row
            float cardX = startX;
            for (int c = 0; c < col; c++) {
                int prevIdx = row * cardsPerRow + c;
                if (prevIdx < numCards) {
                    cardX += sec.connector_cards[prevIdx].cardWidth + spacing;
                }
            }

            // Calculate Y position - sum heights of previous rows
            float cardY = startY;
            for (int r = 0; r < row; r++) {
                // Find max height in that row
                float rowMaxH = 0;
                for (int c = 0; c < cardsPerRow; c++) {
                    int idx = r * cardsPerRow + c;
                    if (idx < numCards) {
                        rowMaxH = std::max(rowMaxH, sec.connector_cards[idx].cardHeight);
                    }
                }
                cardY += rowMaxH + spacing;
            }

            // Move to next row tracking (for currentY compatibility)
            if (col == cardsPerRow - 1 && i < numCards - 1) {
                float rowMaxH = 0;
                for (int c = 0; c < cardsPerRow; c++) {
                    int idx = row * cardsPerRow + c;
                    if (idx < numCards) {
                        rowMaxH = std::max(rowMaxH, sec.connector_cards[idx].cardHeight);
                    }
                }
                currentY = cardY + rowMaxH + spacing;
            }

            // Calculate scale for this specific card (relative to default 280x320)
            float scaleW = cardW / 280.0f;
            float scaleH = cardH / 320.0f;
            float scale = (scaleW < scaleH) ? scaleW : scaleH;
            if (scale > 1.5f) scale = 1.5f;  // Cap max scale
            if (scale < 0.3f) scale = 0.3f;  // Cap min scale (allow smaller for many cards per row)

            // Article-style card rendering
            float accentWidth = 4.0f;  // Left accent border width
            float cardPadding = 10.0f * scale;
            ImVec4 orangeAccent(0.91f, 0.40f, 0.10f, 1.0f);  // Orange accent color

            // Check if this is a simple card (no description, no READ MORE)
            bool hasDescription = strlen(card.description) > 0;
            bool isSimpleCard = !hasDescription && !card.showReadMore;

            // Draw shadow (slightly offset dark rectangle)
            dl->AddRectFilled(ImVec2(cardX + 3, cardY + 3), ImVec2(cardX + cardW + 3, cardY + cardH + 3),
                             IM_COL32(0, 0, 0, 40), card.cardBorderRadius);

            // Draw card background (with border radius)
            dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                             ImGui::ColorConvertFloat4ToU32(card.cardColor), card.cardBorderRadius);

            // Draw left accent border (orange line)
            dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + accentWidth, cardY + cardH),
                             ImGui::ColorConvertFloat4ToU32(orangeAccent));

            // Calculate heading size first to determine image height
            float headingFS = 16.0f * card.headingSize * scale;
            if (headingFS < 8) headingFS = 8;
            float headingSpace = headingFS + cardPadding * 2;

            // Use image height percentage from card settings
            float imgH = cardH * (card.imageHeightPercent / 100.0f);
            // Ensure minimum image height
            if (imgH < 10) imgH = 10;
            // Ensure image doesn't take entire card (leave room for heading)
            if (imgH > cardH - headingSpace) imgH = cardH - headingSpace;

            float contentX = cardX + accentWidth + cardPadding;
            float contentWidth = cardW - accentWidth - cardPadding * 2;

            // Draw image or placeholder
            if (card.textureID != 0) {
                dl->AddImageRounded((ImTextureID)(intptr_t)card.textureID,
                                   ImVec2(cardX + accentWidth, cardY), ImVec2(cardX + cardW, cardY + imgH),
                                   ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255), card.cardBorderRadius);
            } else {
                // Placeholder
                dl->AddRectFilled(ImVec2(cardX + accentWidth + 5, cardY + 5), ImVec2(cardX + cardW - 5, cardY + imgH - 5),
                                 IM_COL32(220, 220, 225, 255), card.cardBorderRadius);
                if (cardW > 80 && imgH > 30) {
                    dl->AddText(ImVec2(cardX + cardW/2 - 20 * scale, cardY + imgH/2 - 6), IM_COL32(150, 150, 160, 255), "Image");
                }
            }

            // Draw heading with boldness (use card.headingColor)
            float headingY = cardY + imgH + cardPadding;
            int passes = (int)(card.headingBoldness * 2) + 1;
            for (int p = 0; p < passes; p++) {
                dl->AddText(font, headingFS, ImVec2(contentX + p * 0.4f, headingY),
                           ImGui::ColorConvertFloat4ToU32(card.headingColor), card.heading);
            }

            // Only draw description if it has content
            if (hasDescription) {
                float descY = headingY + headingFS + 8 * scale;
                float descFS = 12.0f * card.descriptionSize * scale;
                if (descFS < 6) descFS = 6;

                // Simple word wrap for description
                std::string descText = card.description;
                float descMaxWidth = contentWidth;
                float currentLineX = contentX;
                float lineY = descY;
                std::string word;
                std::istringstream stream(descText);

                float bottomLimit = card.showReadMore ? (cardY + cardH - 25 * scale) : (cardY + cardH - cardPadding);

                while (stream >> word && lineY < bottomLimit) {
                    ImVec2 wordSize = font->CalcTextSizeA(descFS, FLT_MAX, 0.0f, word.c_str());
                    if (currentLineX + wordSize.x > contentX + descMaxWidth && currentLineX > contentX) {
                        currentLineX = contentX;
                        lineY += descFS + 2;
                    }
                    if (lineY < bottomLimit) {
                        dl->AddText(font, descFS, ImVec2(currentLineX, lineY),
                                   ImGui::ColorConvertFloat4ToU32(card.descriptionColor), word.c_str());
                        currentLineX += wordSize.x + font->CalcTextSizeA(descFS, FLT_MAX, 0.0f, " ").x;
                    }
                }
            }

            // Draw READ MORE link at bottom (if enabled)
            if (card.showReadMore) {
                float readMoreFS = 11.0f * scale;
                if (readMoreFS < 6) readMoreFS = 6;
                float readMoreY = cardY + cardH - cardPadding - readMoreFS;
                // Bold READ MORE
                for (int b = 0; b < 3; b++) {
                    dl->AddText(font, readMoreFS, ImVec2(contentX + b * 0.3f, readMoreY),
                               IM_COL32(50, 50, 50, 255), "READ MORE");
                }
            }
        }

        // Pop clip rect
        dl->PopClipRect();

        // Selection border (outside clip rect so it's always visible)
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // Vertical Layout Connector
    if (sec.type == SEC_VERTICAL_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Use margins for content positioning
        float availableWidth = sectionW - sec.margin_left - sec.margin_right;
        float contentWidth = (sec.vertical_content_width < availableWidth) ? sec.vertical_content_width : availableWidth;
        float contentX = x + sec.margin_left + (availableWidth - contentWidth) / 2;
        float contentY = y + sec.margin_top + sec.vertical_spacing;
        float maxContentY = y + h - sec.margin_bottom;
        ImFont* font = ImGui::GetFont();

        for (const auto& block : sec.vertical_blocks) {
            if (contentY >= maxContentY) break;  // Stop if we've exceeded content area

            if (block.type == 0) {  // Heading
                float fs = 24.0f * sec.vertical_heading_size;
                int passes = (int)(sec.vertical_heading_boldness * 2) + 1;
                for (int p = 0; p < passes; p++) {
                    dl->AddText(font, fs, ImVec2(contentX + p * 0.4f, contentY),
                               ImGui::ColorConvertFloat4ToU32(sec.vertical_heading_color), block.text);
                }
                contentY += fs + sec.vertical_spacing;
            } else if (block.type == 1) {  // Description
                float fs = 16.0f * sec.vertical_desc_size;
                // Wrap text manually using content width with margins
                float maxWidth = contentWidth;
                // Convert boldness (0-3) to fontWeight (400-1000)
                float descWeight = 400.0f + sec.vertical_desc_boldness * 200.0f;
                DrawWrappedText(dl, block.text, contentX, contentY, maxWidth,
                               ImGui::ColorConvertFloat4ToU32(sec.vertical_desc_color), false, fs, descWeight, 1.5f, 0);
                ImVec2 textSize = font->CalcTextSizeA(fs, FLT_MAX, maxWidth, block.text);
                contentY += textSize.y + sec.vertical_spacing;
            }
        }

        // Render images separately with drag interaction (like original vertical_connector)
        ImGuiIO& io = ImGui::GetIO();
        for (int i = 0; i < (int)sec.vertical_blocks.size(); i++) {
            VerticalBlock& block = sec.vertical_blocks[i];
            if (block.type == 2) {  // Image
                float imgW = block.displayWidth;
                float imgH = (block.imageWidth > 0 && block.imageHeight > 0)
                    ? imgW * ((float)block.imageHeight / (float)block.imageWidth)
                    : imgW * 0.75f;
                float imgX = x + block.posX;
                float imgY = y + block.posY;

                if (block.textureID != 0) {
                    dl->AddImage((ImTextureID)(intptr_t)block.textureID,
                                ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH));
                } else {
                    // Placeholder
                    dl->AddRectFilled(ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH),
                                     IM_COL32(200, 200, 210, 255), 4.0f);
                    dl->AddText(ImVec2(imgX + imgW/2 - 25, imgY + imgH/2 - 8), IM_COL32(100, 100, 110, 255), "Image");
                }

                // Check if mouse is over this image for dragging
                ImVec2 mousePos = io.MousePos;
                bool isHovered = (mousePos.x >= imgX && mousePos.x <= imgX + imgW &&
                                 mousePos.y >= imgY && mousePos.y <= imgY + imgH);

                if (isHovered) {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);
                    // Draw highlight border
                    dl->AddRect(ImVec2(imgX, imgY), ImVec2(imgX + imgW, imgY + imgH),
                               IM_COL32(0, 150, 255, 255), 0, 0, 2.0f);

                    // Handle dragging
                    if (ImGui::IsMouseDragging(ImGuiMouseButton_Left, 0.0f)) {
                        block.posX += io.MouseDelta.x;
                        block.posY += io.MouseDelta.y;

                        // Clamp to section bounds
                        if (block.posX < 0) block.posX = 0;
                        if (block.posY < 0) block.posY = 0;
                        if (block.posX > sectionW - imgW) block.posX = sectionW - imgW;
                        if (block.posY > h - imgH) block.posY = h - imgH;

                        // Select this block
                        g_SelectedVertBlockIndex = i;
                    }

                    // Click to select
                    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
                        g_SelectedVertBlockIndex = i;
                    }
                }

                // Draw selection border if this is the selected block
                if (g_SelectedVertBlockIndex == i) {
                    dl->AddRect(ImVec2(imgX - 2, imgY - 2), ImVec2(imgX + imgW + 2, imgY + imgH + 2),
                               IM_COL32(0, 120, 255, 255), 0, 0, 3.0f);
                }
            }
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ==================== NAVBAR CONNECTOR ====================
    if (sec.type == SEC_NAVBAR_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + sec.navbar_height);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.navbar_bg_color));

        float menuX = x + sec.navbar_padding_x;
        float menuY = y + sec.navbar_padding_y;
        ImFont* font = ImGui::GetFont();
        float fontSize = 18.0f * sec.navbar_font_scale;

        // Track active menu for dropdown
        static int navbar_active_menu = -1;
        static int navbar_hovered_parent = -1;
        bool parent_hovered = false;

        // Store menu button rects for dropdown positioning
        std::vector<ImVec4> menuRects;  // x, y, w, h

        // Draw menu items
        for (int i = 0; i < (int)sec.navbar_items.size(); i++) {
            const NavbarMenuItem& item = sec.navbar_items[i];
            ImVec2 textSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, item.label);
            float btnW = textSize.x + 20.0f;
            float btnH = textSize.y + 10.0f;

            ImVec2 btnMin(menuX, menuY);
            ImVec2 btnMax(menuX + btnW, menuY + btnH);
            menuRects.push_back(ImVec4(menuX, menuY, btnW, btnH));

            // Check hover
            ImGuiIO& io = ImGui::GetIO();
            bool isHovered = (io.MousePos.x >= btnMin.x && io.MousePos.x <= btnMax.x &&
                             io.MousePos.y >= btnMin.y && io.MousePos.y <= btnMax.y);

            if (isHovered) {
                parent_hovered = true;
                navbar_hovered_parent = i;
            }

            // Draw hover background
            if (isHovered || navbar_active_menu == i) {
                dl->AddRectFilled(btnMin, btnMax, ImGui::ColorConvertFloat4ToU32(sec.navbar_hover_color),
                                 sec.navbar_rounded ? sec.navbar_rounding : 0.0f);
            }

            // Draw text with boldness
            int textPasses = (int)(sec.navbar_font_boldness * 2) + 1;
            for (int p = 0; p < textPasses; p++) {
                dl->AddText(font, fontSize, ImVec2(menuX + 10.0f + p * 0.4f, menuY + 5.0f),
                           ImGui::ColorConvertFloat4ToU32(sec.navbar_text_color), item.label);
            }

            menuX += btnW + sec.navbar_spacing;
        }

        // Open dropdown on parent hover
        if (parent_hovered && navbar_hovered_parent >= 0 && navbar_hovered_parent < (int)sec.navbar_items.size()) {
            if (!sec.navbar_items[navbar_hovered_parent].children.empty()) {
                navbar_active_menu = navbar_hovered_parent;
            }
        }

        // Draw dropdown if active
        bool dropdown_hovered = false;
        if (navbar_active_menu >= 0 && navbar_active_menu < (int)sec.navbar_items.size() &&
            !sec.navbar_items[navbar_active_menu].children.empty()) {

            ImVec4 parentRect = menuRects[navbar_active_menu];
            float dropX = parentRect.x;
            float dropY = parentRect.y + parentRect.w + 2;  // Below the button

            const auto& children = sec.navbar_items[navbar_active_menu].children;
            float dropW = 150.0f;
            float dropH = children.size() * 30.0f + 16.0f;

            // Find max width
            for (const auto& child : children) {
                ImVec2 sz = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, child.c_str());
                if (sz.x + 20.0f > dropW) dropW = sz.x + 20.0f;
            }

            ImVec2 dropMin(dropX, dropY);
            ImVec2 dropMax(dropX + dropW, dropY + dropH);

            // Check dropdown hover
            ImGuiIO& io = ImGui::GetIO();
            dropdown_hovered = (io.MousePos.x >= dropMin.x && io.MousePos.x <= dropMax.x &&
                               io.MousePos.y >= dropMin.y && io.MousePos.y <= dropMax.y);

            // Draw dropdown background
            dl->AddRectFilled(dropMin, dropMax, ImGui::ColorConvertFloat4ToU32(sec.navbar_dropdown_color),
                             sec.navbar_rounded ? sec.navbar_rounding : 0.0f);

            // Draw dropdown items
            float itemY = dropY + 8.0f;
            for (const auto& child : children) {
                ImVec2 itemMin(dropX, itemY);
                ImVec2 itemMax(dropX + dropW, itemY + 26.0f);

                bool itemHovered = (io.MousePos.x >= itemMin.x && io.MousePos.x <= itemMax.x &&
                                   io.MousePos.y >= itemMin.y && io.MousePos.y <= itemMax.y);

                if (itemHovered) {
                    dl->AddRectFilled(ImVec2(dropX + 4, itemY), ImVec2(dropX + dropW - 4, itemY + 26.0f),
                                     ImGui::ColorConvertFloat4ToU32(sec.navbar_hover_color), 3.0f);
                }

                // Draw dropdown text with boldness
                int dropTextPasses = (int)(sec.navbar_font_boldness * 2) + 1;
                for (int p = 0; p < dropTextPasses; p++) {
                    dl->AddText(font, fontSize, ImVec2(dropX + 10.0f + p * 0.4f, itemY + 4.0f),
                               ImGui::ColorConvertFloat4ToU32(sec.navbar_text_color), child.c_str());
                }
                itemY += 30.0f;
            }
        }

        // Close menu when not hovering parent or dropdown
        if (!parent_hovered && !dropdown_hovered) {
            navbar_active_menu = -1;
        }

        // Hand cursor when hovering
        if (parent_hovered || dropdown_hovered) {
            ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ==================== COPYRIGHT CONNECTOR ====================
    if (sec.type == SEC_COPYRIGHT_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background with controllable opacity
        if (sec.copyright_bg_opacity > 0.0f) {
            ImVec4 bgWithOpacity = sec.copyright_bg_color;
            bgWithOpacity.w = sec.copyright_bg_opacity;
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(bgWithOpacity));
        }

        ImFont* font = ImGui::GetFont();
        float padding = sec.copyright_padding;
        float textY = y + padding;

        // Main copyright text line
        if (strlen(sec.copyright_text) > 0) {
            ImVec2 textSize = font->CalcTextSizeA(sec.copyright_font_size, FLT_MAX, 0.0f, sec.copyright_text);
            float textX = x + padding;
            dl->AddText(font, sec.copyright_font_size, ImVec2(textX, textY),
                       ImGui::ColorConvertFloat4ToU32(sec.copyright_text_color), sec.copyright_text);
            textY += textSize.y + 6.0f;
        }

        // Subtext with links
        float linkX = x + padding;
        if (strlen(sec.copyright_subtext) > 0) {
            ImVec2 subtextSize = font->CalcTextSizeA(sec.copyright_subtext_size, FLT_MAX, 0.0f, sec.copyright_subtext);
            dl->AddText(font, sec.copyright_subtext_size, ImVec2(linkX, textY),
                       ImGui::ColorConvertFloat4ToU32(sec.copyright_text_color), sec.copyright_subtext);
            linkX += subtextSize.x;
        }

        // Add links
        for (int i = 0; i < (int)sec.copyright_links.size(); i++) {
            const CopyrightLink& link = sec.copyright_links[i];

            // Add separator
            if (i == 0 && strlen(sec.copyright_subtext) > 0) {
                ImVec2 sepSize = font->CalcTextSizeA(sec.copyright_subtext_size, FLT_MAX, 0.0f, " | ");
                dl->AddText(font, sec.copyright_subtext_size, ImVec2(linkX, textY),
                           ImGui::ColorConvertFloat4ToU32(sec.copyright_text_color), " | ");
                linkX += sepSize.x;
            } else if (i > 0) {
                ImVec2 sepSize = font->CalcTextSizeA(sec.copyright_subtext_size, FLT_MAX, 0.0f, " | ");
                dl->AddText(font, sec.copyright_subtext_size, ImVec2(linkX, textY),
                           ImGui::ColorConvertFloat4ToU32(sec.copyright_text_color), " | ");
                linkX += sepSize.x;
            }

            // Draw link text
            ImVec2 linkSize = font->CalcTextSizeA(sec.copyright_subtext_size, FLT_MAX, 0.0f, link.text);

            // Bold effect for links
            if (link.isBold) {
                for (int b = 0; b < 3; b++) {
                    dl->AddText(font, sec.copyright_subtext_size, ImVec2(linkX + b * 0.4f, textY),
                               ImGui::ColorConvertFloat4ToU32(sec.copyright_link_color), link.text);
                }
            } else {
                dl->AddText(font, sec.copyright_subtext_size, ImVec2(linkX, textY),
                           ImGui::ColorConvertFloat4ToU32(sec.copyright_link_color), link.text);
            }
            linkX += linkSize.x;
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_ARTICLE_CONNECTOR - Blog/News style article cards
    // ========================================================================
    if (sec.type == SEC_ARTICLE_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Clip content to section bounds
        dl->PushClipRect(section_min, section_max, true);

        ImFont* font = ImGui::GetFont();
        float padding = 20.0f;
        int cardsPerRow = sec.article_cards_per_row > 0 ? sec.article_cards_per_row : 2;
        float spacing = sec.article_card_spacing;
        int numCards = (int)sec.article_cards.size();

        // Calculate available space
        float availableWidth = sectionW - padding * 2;
        float availableHeight = h - padding * 2;

        // Calculate card width to fit within section
        float totalSpacing = (cardsPerRow - 1) * spacing;
        float defaultCardW = numCards > 0 ? sec.article_cards[0].cardWidth : 500;
        float fittedCardW = (availableWidth - totalSpacing) / cardsPerRow;
        float actualCardW = (fittedCardW < defaultCardW) ? fittedCardW : defaultCardW;
        if (actualCardW < 150) actualCardW = 150;

        // Calculate card height to fit within section
        int numRows = (numCards + cardsPerRow - 1) / cardsPerRow;
        float totalRowSpacing = (numRows - 1) * spacing;
        float defaultCardH = numCards > 0 ? sec.article_cards[0].cardHeight : 180;
        float fittedCardH = numRows > 0 ? (availableHeight - totalRowSpacing) / numRows : defaultCardH;
        float actualCardH = (fittedCardH < defaultCardH) ? fittedCardH : defaultCardH;
        if (actualCardH < 100) actualCardH = 100;

        // Scale factor for text
        float scaleW = actualCardW / defaultCardW;
        float scaleH = actualCardH / defaultCardH;
        float scale = (scaleW < scaleH) ? scaleW : scaleH;
        if (scale > 1.0f) scale = 1.0f;

        // Calculate starting position (centered)
        float totalRowWidth = cardsPerRow * actualCardW + totalSpacing;
        float startX = x + (sectionW - totalRowWidth) / 2;
        if (startX < x + padding) startX = x + padding;
        float startY = y + padding;

        for (int i = 0; i < numCards; i++) {
            const ArticleCard& card = sec.article_cards[i];
            int row = i / cardsPerRow;
            int col = i % cardsPerRow;

            float cardX = startX + col * (actualCardW + spacing);
            float cardY = startY + row * (actualCardH + spacing);

            // Skip if card would be outside section bounds
            if (cardY + actualCardH > y + h - 5) continue;

            // Card background
            ImVec2 cardMin(cardX, cardY);
            ImVec2 cardMax(cardX + actualCardW, cardY + actualCardH);
            dl->AddRectFilled(cardMin, cardMax, ImGui::ColorConvertFloat4ToU32(card.cardBgColor));

            // Orange left accent border
            float accentW = card.accentWidth * scale;
            if (accentW < 3) accentW = 3;
            dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + accentW, cardY + actualCardH),
                             ImGui::ColorConvertFloat4ToU32(card.accentColor));

            // Content area (after accent)
            float cardPad = card.cardPadding * scale;
            if (cardPad < 10) cardPad = 10;
            float contentX = cardX + accentW + cardPad;
            float contentY = cardY + cardPad;
            float contentWidth = actualCardW - accentW - cardPad * 2;

            // Heading (clickable, orange)
            float headingFontSize = ValidFontSize(18.0f * card.headingSize * scale);
            if (headingFontSize < 10) headingFontSize = 10;
            ImVec2 headingSize = font->CalcTextSizeA(headingFontSize, FLT_MAX, 0.0f, card.heading);
            dl->AddText(font, headingFontSize, ImVec2(contentX, contentY),
                       ImGui::ColorConvertFloat4ToU32(card.headingColor), card.heading);
            contentY += headingSize.y + 6 * scale;

            // Date (smaller, gray)
            float dateFontSize = ValidFontSize(14.0f * card.dateSize * scale);
            if (dateFontSize < 8) dateFontSize = 8;
            ImVec2 dateSize = font->CalcTextSizeA(dateFontSize, FLT_MAX, 0.0f, card.date);
            dl->AddText(font, dateFontSize, ImVec2(contentX, contentY),
                       ImGui::ColorConvertFloat4ToU32(card.dateColor), card.date);
            contentY += dateSize.y + 8 * scale;

            // Description (wrapped text)
            float descFontSize = ValidFontSize(14.0f * card.descriptionSize * scale);
            if (descFontSize < 8) descFontSize = 8;
            float descY = contentY;
            std::string descText = card.description;
            float maxDescY = cardY + actualCardH - cardPad - 20 * scale;

            // Simple word wrap for description
            float currentX = contentX;
            std::string word;
            std::istringstream stream(descText);
            while (stream >> word && descY < maxDescY) {
                ImVec2 wordSize = font->CalcTextSizeA(descFontSize, FLT_MAX, 0.0f, word.c_str());
                if (currentX + wordSize.x > contentX + contentWidth && currentX > contentX) {
                    currentX = contentX;
                    descY += descFontSize + 2;
                }
                if (descY < maxDescY) {
                    dl->AddText(font, descFontSize, ImVec2(currentX, descY),
                               ImGui::ColorConvertFloat4ToU32(card.descriptionColor), word.c_str());
                    currentX += wordSize.x + font->CalcTextSizeA(descFontSize, FLT_MAX, 0.0f, " ").x;
                }
            }

            // READ MORE button (clickable)
            float rmFontSize = ValidFontSize(12.0f * card.readMoreSize * scale);
            if (rmFontSize < 8) rmFontSize = 8;
            ImVec2 rmSize = font->CalcTextSizeA(rmFontSize, FLT_MAX, 0.0f, card.readMoreText);
            float rmY = cardY + actualCardH - cardPad - rmSize.y;

            // Bold effect for READ MORE
            for (int b = 0; b < 3; b++) {
                dl->AddText(font, rmFontSize, ImVec2(contentX + b * 0.4f, rmY),
                           ImGui::ColorConvertFloat4ToU32(card.readMoreColor), card.readMoreText);
            }
        }

        // Pop clip rect
        dl->PopClipRect();

        // Selection border (outside clip rect)
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_CONTACT_FORM_CONNECTOR - Contact form with input fields
    // ========================================================================
    if (sec.type == SEC_CONTACT_FORM_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float padding = sec.padding_left > 0 ? sec.padding_left : 30.0f;
        float currentY = y + (sec.padding_top > 0 ? sec.padding_top : 30.0f);
        float formWidth = sectionW - padding * 2;

        // Title "Contact Us"
        float titleFontSize = ValidFontSize(24.0f * sec.contact_form_title_size);
        ImVec2 titleSize = font->CalcTextSizeA(titleFontSize, FLT_MAX, 0.0f, sec.contact_form_title);
        // Bold effect for title
        for (int b = 0; b < 4; b++) {
            dl->AddText(font, titleFontSize, ImVec2(x + padding + b * 0.5f, currentY),
                       ImGui::ColorConvertFloat4ToU32(sec.contact_form_title_color), sec.contact_form_title);
        }
        currentY += titleSize.y + sec.contact_form_spacing;

        // Render form fields
        float fieldX = x + padding;
        float halfWidth = (formWidth - sec.contact_form_spacing) / 2;
        int fieldInRow = 0;
        float rowStartY = currentY;

        for (int i = 0; i < (int)sec.contact_form_fields.size(); i++) {
            const ContactFormField& field = sec.contact_form_fields[i];
            float fieldWidth = (field.width >= 1.0f) ? formWidth : halfWidth;
            float fieldHeight = (field.fieldType == 3) ? sec.contact_form_textarea_height : sec.contact_form_input_height;

            // If full width or we need to start new row
            if (field.width >= 1.0f || fieldInRow >= 2) {
                if (fieldInRow > 0) {
                    currentY = rowStartY + sec.contact_form_input_height + sec.contact_form_spacing;
                }
                fieldX = x + padding;
                fieldInRow = 0;
                rowStartY = currentY;
            }

            // Draw input field background
            ImVec2 fieldMin(fieldX, currentY);
            ImVec2 fieldMax(fieldX + fieldWidth, currentY + fieldHeight);
            dl->AddRectFilled(fieldMin, fieldMax, ImGui::ColorConvertFloat4ToU32(sec.contact_form_input_bg), 4.0f);

            // Draw placeholder text
            float placeholderFontSize = ValidFontSize(14.0f);
            float textY = currentY + (field.fieldType == 3 ? 12 : (fieldHeight - placeholderFontSize) / 2);
            dl->AddText(font, placeholderFontSize, ImVec2(fieldX + 15, textY),
                       ImGui::ColorConvertFloat4ToU32(sec.contact_form_input_text), field.placeholder);

            // Move to next position
            if (field.width < 1.0f) {
                fieldX += fieldWidth + sec.contact_form_spacing;
                fieldInRow++;
            } else {
                currentY += fieldHeight + sec.contact_form_spacing;
                fieldInRow = 0;
            }
        }

        // Update currentY after last row if needed
        if (fieldInRow > 0) {
            currentY = rowStartY + sec.contact_form_input_height + sec.contact_form_spacing;
        }

        // Submit button (right-aligned)
        float btnWidth = sec.contact_form_button_width;
        float btnHeight = sec.contact_form_button_height;
        float btnX = x + padding + formWidth - btnWidth;
        float btnY = currentY + 10;

        // Button background with border
        ImVec2 btnMin(btnX, btnY);
        ImVec2 btnMax(btnX + btnWidth, btnY + btnHeight);
        dl->AddRectFilled(btnMin, btnMax, ImGui::ColorConvertFloat4ToU32(sec.contact_form_button_bg), 4.0f);
        dl->AddRect(btnMin, btnMax, ImGui::ColorConvertFloat4ToU32(sec.contact_form_button_border), 4.0f, 0, 1.5f);

        // Button text
        float btnFontSize = ValidFontSize(14.0f);
        ImVec2 btnTextSize = font->CalcTextSizeA(btnFontSize, FLT_MAX, 0.0f, sec.contact_form_submit_text);
        float btnTextX = btnX + (btnWidth - btnTextSize.x) / 2;
        float btnTextY = btnY + (btnHeight - btnTextSize.y) / 2;
        dl->AddText(font, btnFontSize, ImVec2(btnTextX, btnTextY),
                   ImGui::ColorConvertFloat4ToU32(sec.contact_form_button_text), sec.contact_form_submit_text);

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_SEARCH_CONNECTOR - Search bar with input and button
    // ========================================================================
    if (sec.type == SEC_SEARCH_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();

        // Center the search bar
        float totalWidth = sec.search_input_width + sec.search_button_width;
        float startX = x + (sectionW - totalWidth) / 2;
        float centerY = y + (h - sec.search_input_height) / 2;

        // Input field background with border
        ImVec2 inputMin(startX, centerY);
        ImVec2 inputMax(startX + sec.search_input_width, centerY + sec.search_input_height);
        dl->AddRectFilled(inputMin, inputMax, ImGui::ColorConvertFloat4ToU32(sec.search_input_bg), sec.search_border_radius);
        dl->AddRect(inputMin, inputMax, ImGui::ColorConvertFloat4ToU32(sec.search_input_border), sec.search_border_radius, 0, 1.0f);

        // Placeholder text
        float placeholderFontSize = ValidFontSize(14.0f);
        dl->AddText(font, placeholderFontSize, ImVec2(startX + 15, centerY + (sec.search_input_height - placeholderFontSize) / 2),
                   ImGui::ColorConvertFloat4ToU32(ImVec4(0.6f, 0.6f, 0.6f, 1.0f)), sec.search_placeholder);

        // Search button
        ImVec2 btnMin(startX + sec.search_input_width, centerY);
        ImVec2 btnMax(startX + sec.search_input_width + sec.search_button_width, centerY + sec.search_input_height);
        dl->AddRectFilled(btnMin, btnMax, ImGui::ColorConvertFloat4ToU32(sec.search_button_bg), sec.search_border_radius);

        // Button text
        float btnFontSize = ValidFontSize(14.0f);
        ImVec2 btnTextSize = font->CalcTextSizeA(btnFontSize, FLT_MAX, 0.0f, sec.search_button_text);
        float btnTextX = btnMin.x + (sec.search_button_width - btnTextSize.x) / 2;
        float btnTextY = centerY + (sec.search_input_height - btnTextSize.y) / 2;
        dl->AddText(font, btnFontSize, ImVec2(btnTextX, btnTextY),
                   ImGui::ColorConvertFloat4ToU32(sec.search_button_text_color), sec.search_button_text);

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_LOGO_CONNECTOR - Logo image with size and alignment controls
    // ========================================================================
    if (sec.type == SEC_LOGO_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background (if set)
        if (sec.logo_bg_color.w > 0.01f) {
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.logo_bg_color));
        }

        // Calculate logo dimensions maintaining aspect ratio if needed
        float logoW = sec.logo_width;
        float logoH = sec.logo_height;

        if (sec.logo_connector_texture != 0 && sec.logo_maintain_aspect && sec.logo_image_width > 0 && sec.logo_image_height > 0) {
            float aspect = (float)sec.logo_image_width / (float)sec.logo_image_height;
            // Fit within the specified size while maintaining aspect
            if (logoW / logoH > aspect) {
                logoW = logoH * aspect;
            } else {
                logoH = logoW / aspect;
            }
        }

        // Calculate position based on alignment
        float logoX;
        if (sec.logo_alignment == 0) {  // Left
            logoX = x + sec.logo_padding;
        } else if (sec.logo_alignment == 2) {  // Right
            logoX = x + sectionW - logoW - sec.logo_padding;
        } else {  // Center
            logoX = x + (sectionW - logoW) / 2;
        }
        float logoY = y + (h - logoH) / 2;

        // Draw logo image or placeholder
        if (sec.logo_connector_texture != 0) {
            // Draw the actual logo image
            ImVec2 imgMin(logoX, logoY);
            ImVec2 imgMax(logoX + logoW, logoY + logoH);
            dl->AddImage((ImTextureID)(intptr_t)sec.logo_connector_texture, imgMin, imgMax);
        } else {
            // Draw placeholder
            ImVec2 placeholderMin(logoX, logoY);
            ImVec2 placeholderMax(logoX + logoW, logoY + logoH);
            dl->AddRectFilled(placeholderMin, placeholderMax, IM_COL32(80, 80, 80, 255), 8.0f);
            dl->AddRect(placeholderMin, placeholderMax, IM_COL32(120, 120, 120, 255), 8.0f, 0, 2.0f);

            // Placeholder text
            ImFont* font = ImGui::GetFont();
            const char* text = "LOGO";
            float fontSize = ValidFontSize(18.0f);
            ImVec2 textSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, text);
            float textX = logoX + (logoW - textSize.x) / 2;
            float textY = logoY + (logoH - textSize.y) / 2;
            dl->AddText(font, fontSize, ImVec2(textX, textY), IM_COL32(180, 180, 180, 255), text);
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_BULLET_CONNECTOR - Bullet point columns with heading and subheadings
    // ========================================================================
    if (sec.type == SEC_BULLET_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float padding = 40.0f;
        float contentStartY = y + sec.margin_top + padding;

        // Draw main heading
        float mainHeadingFS = ValidFontSize(20.0f * sec.bullet_heading_size);
        int headingPasses = (int)(sec.bullet_heading_boldness * 2) + 1;
        ImVec2 headingSize = font->CalcTextSizeA(mainHeadingFS, FLT_MAX, 0.0f, sec.bullet_main_heading);
        float headingX = x + (sectionW - headingSize.x) / 2;

        for (int p = 0; p < headingPasses; p++) {
            dl->AddText(font, mainHeadingFS, ImVec2(headingX + p * 0.4f, contentStartY),
                       ImGui::ColorConvertFloat4ToU32(sec.bullet_heading_color), sec.bullet_main_heading);
        }
        contentStartY += headingSize.y + 30;

        // Draw columns
        int numCols = (int)sec.bullet_columns.size();
        if (numCols > 0) {
            float totalColumnsWidth = sectionW - padding * 2 - sec.bullet_column_spacing * (numCols - 1);
            float colWidth = totalColumnsWidth / numCols;
            float colStartX = x + padding;

            for (int ci = 0; ci < numCols; ci++) {
                const BulletColumn& col = sec.bullet_columns[ci];
                float colX = colStartX + ci * (colWidth + sec.bullet_column_spacing);
                float colY = contentStartY;

                // Draw column subheading
                float subheadingFS = ValidFontSize(18.0f * col.subheadingSize);
                int subPasses = (int)(col.subheadingBoldness * 2) + 1;
                for (int p = 0; p < subPasses; p++) {
                    dl->AddText(font, subheadingFS, ImVec2(colX + p * 0.4f, colY),
                               ImGui::ColorConvertFloat4ToU32(col.subheadingColor), col.subheading);
                }
                colY += subheadingFS + 15;

                // Draw bullet items
                float itemFS = ValidFontSize(14.0f * sec.bullet_item_size);
                for (const auto& item : col.bullet_items) {
                    // Draw bullet point (circle)
                    float bulletRadius = 3.0f;
                    dl->AddCircleFilled(ImVec2(colX + bulletRadius, colY + itemFS / 2),
                                       bulletRadius, ImGui::ColorConvertFloat4ToU32(sec.bullet_item_color));

                    // Draw item text
                    dl->AddText(font, itemFS, ImVec2(colX + bulletRadius * 2 + 8, colY),
                               ImGui::ColorConvertFloat4ToU32(sec.bullet_item_color), item.c_str());
                    colY += itemFS + 8;
                }
            }
        }

        // Draw footer text if present
        if (strlen(sec.bullet_footer_text) > 0) {
            float footerFS = ValidFontSize(14.0f * sec.bullet_item_size);
            ImVec2 footerSize = font->CalcTextSizeA(footerFS, FLT_MAX, 0.0f, sec.bullet_footer_text);
            float footerX = x + (sectionW - footerSize.x) / 2;
            float footerY = y + h - padding - footerSize.y;
            dl->AddText(font, footerFS, ImVec2(footerX, footerY),
                       ImGui::ColorConvertFloat4ToU32(sec.bullet_item_color), sec.bullet_footer_text);
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_ICON - Icon element with selectable icons
    // ========================================================================
    if (sec.type == SEC_ICON) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        // Draw the icon centered in the section
        float centerX = x + sectionW / 2;
        float centerY = y + h / 2;
        ImU32 iconCol = ImGui::ColorConvertFloat4ToU32(sec.icon_color);
        DrawIcon(dl, sec.icon_type, centerX, centerY, sec.icon_size, iconCol, sec.icon_stroke_width);

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_SERVICE_CARD_CONNECTOR - Service cards with badge tags
    // ========================================================================
    if (sec.type == SEC_SERVICE_CARD_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        int cardsPerRow = sec.service_cards_per_row;
        float spacing = sec.service_card_spacing;
        float padding = 30.0f;

        if (!sec.service_cards.empty()) {
            float totalSpacing = spacing * (cardsPerRow - 1);
            float availWidth = sectionW - padding * 2 - totalSpacing;
            float cardW = availWidth / cardsPerRow;
            float cardH = 220.0f;

            for (size_t i = 0; i < sec.service_cards.size(); i++) {
                const ServiceCard& card = sec.service_cards[i];
                int row = (int)i / cardsPerRow;
                int col = (int)i % cardsPerRow;

                float cardX = x + padding + col * (cardW + spacing);
                float cardY = y + padding + row * (cardH + spacing);

                // Card background with shadow
                dl->AddRectFilled(ImVec2(cardX + 2, cardY + 4), ImVec2(cardX + cardW + 2, cardY + cardH + 4),
                                 IM_COL32(0, 0, 0, 20), card.borderRadius);
                dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH),
                                 ImGui::ColorConvertFloat4ToU32(card.cardBgColor), card.borderRadius);

                // Image area (top 65% of card)
                float imageH = cardH * 0.65f;
                if (card.textureID > 0) {
                    dl->AddImageRounded((ImTextureID)(uintptr_t)card.textureID,
                                       ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + imageH),
                                       ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255),
                                       card.borderRadius, ImDrawFlags_RoundCornersTop);
                } else {
                    // Placeholder gradient
                    dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + imageH),
                                     IM_COL32(200, 200, 210, 255), card.borderRadius, ImDrawFlags_RoundCornersTop);
                }

                // Badge tag
                float badgeFontSize = ValidFontSize(11.0f);
                ImVec2 badgeTextSize = font->CalcTextSizeA(badgeFontSize, FLT_MAX, 0.0f, card.badgeText);
                float badgePadX = 10.0f, badgePadY = 5.0f;
                float badgeW = badgeTextSize.x + badgePadX * 2;
                float badgeH = badgeTextSize.y + badgePadY * 2;
                float badgeX = cardX + 12;
                float badgeY = cardY + 12;

                dl->AddRectFilled(ImVec2(badgeX, badgeY), ImVec2(badgeX + badgeW, badgeY + badgeH),
                                 ImGui::ColorConvertFloat4ToU32(card.badgeColor), 4.0f);
                dl->AddText(font, badgeFontSize, ImVec2(badgeX + badgePadX, badgeY + badgePadY),
                           ImGui::ColorConvertFloat4ToU32(card.badgeTextColor), card.badgeText);

                // Title below image
                float titleFontSize = ValidFontSize(15.0f);
                ImVec2 titleSize = font->CalcTextSizeA(titleFontSize, FLT_MAX, 0.0f, card.title);
                float titleX = cardX + (cardW - titleSize.x) / 2;
                float titleY = cardY + imageH + (cardH - imageH - titleSize.y) / 2;
                dl->AddText(font, titleFontSize, ImVec2(titleX, titleY),
                           ImGui::ColorConvertFloat4ToU32(card.titleColor), card.title);
            }
        }

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_GLASS_BAR_CONNECTOR - Glass effect text bar
    // ========================================================================
    if (sec.type == SEC_GLASS_BAR_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Transparent section background
        if (sec.bg_color.w > 0.01f) {
            dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));
        }

        ImFont* font = ImGui::GetFont();
        float padding = sec.glass_bar_padding;
        float fontSize = ValidFontSize(16.0f);

        // Calculate text sizes
        ImVec2 textSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, sec.glass_bar_text);
        ImVec2 highlightSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, sec.glass_bar_highlight);
        float totalTextW = textSize.x + 10 + highlightSize.x;

        // Glass bar dimensions - use section width when manually positioned (resize handles)
        float minBarW = totalTextW + padding * 2;  // Minimum to fit text
        float barW = sec.use_manual_position ? (sectionW - 10) : minBarW;  // Use section width in free design
        if (barW < minBarW) barW = minBarW;  // Ensure text fits
        float barH = h - 10;
        float barX = x + (sectionW - barW) / 2;
        float barY = y + 5;

        // Glass effect background
        int alpha = (int)(sec.glass_bar_opacity * 255);
        ImU32 bgColor = IM_COL32(
            (int)(sec.glass_bar_bg_color.x * 255),
            (int)(sec.glass_bar_bg_color.y * 255),
            (int)(sec.glass_bar_bg_color.z * 255),
            alpha
        );
        dl->AddRectFilled(ImVec2(barX, barY), ImVec2(barX + barW, barY + barH),
                         bgColor, sec.glass_bar_border_radius);

        // Subtle border
        dl->AddRect(ImVec2(barX, barY), ImVec2(barX + barW, barY + barH),
                   IM_COL32(255, 255, 255, 100), sec.glass_bar_border_radius, 0, 1.0f);

        // Text
        float textX = barX + padding;
        float textY = barY + (barH - textSize.y) / 2;

        // Main text
        dl->AddText(font, fontSize, ImVec2(textX, textY),
                   ImGui::ColorConvertFloat4ToU32(sec.glass_bar_text_color), sec.glass_bar_text);

        // Highlighted text
        dl->AddText(font, fontSize, ImVec2(textX + textSize.x + 10, textY),
                   ImGui::ColorConvertFloat4ToU32(sec.glass_bar_highlight_color), sec.glass_bar_highlight);

        // Selection border
        if (sec.selected) {
            dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        }
        return;
    }

    // ========================================================================
    // SEC_STORY_CONNECTOR - About/Story section with content and stats
    // ========================================================================
    if (sec.type == SEC_STORY_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);

        // Section background
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float leftW = sectionW * 0.55f;  // Left content area
        float rightW = sectionW * 0.4f;  // Right area for stats badge
        float padding = 40.0f;

        // Left side content
        float contentX = x + padding;
        float contentY = y + padding;

        // Section label with line "‚Äî OUR STORY"
        float labelSize = 12.0f;
        ImVec2 labelTextSize = font->CalcTextSizeA(labelSize, FLT_MAX, 0.0f, sec.story_label);
        dl->AddLine(ImVec2(contentX, contentY + labelSize/2), ImVec2(contentX + 30, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.story_label_color), 2.0f);
        dl->AddText(font, labelSize, ImVec2(contentX + 40, contentY),
                   ImGui::ColorConvertFloat4ToU32(sec.story_label_color), sec.story_label);
        contentY += 35;

        // Two-tone heading
        float headingSize = 36.0f;
        ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.story_heading);
        dl->AddText(font, headingSize, ImVec2(contentX, contentY),
                   ImGui::ColorConvertFloat4ToU32(sec.story_heading_color), sec.story_heading);
        dl->AddText(font, headingSize, ImVec2(contentX, contentY + headingSize + 5),
                   ImGui::ColorConvertFloat4ToU32(sec.story_accent_color), sec.story_heading_accent);
        contentY += headingSize * 2 + 30;

        // Paragraphs
        float paraSize = 14.0f;
        float paraWidth = leftW - padding;
        for (int i = 0; i < sec.story_paragraph_count && i < 3; i++) {
            if (sec.story_paragraphs[i][0] != '\0') {
                ImVec2 pSize = font->CalcTextSizeA(paraSize, FLT_MAX, paraWidth, sec.story_paragraphs[i]);
                dl->AddText(font, paraSize, ImVec2(contentX, contentY),
                           ImGui::ColorConvertFloat4ToU32(sec.story_text_color), sec.story_paragraphs[i], nullptr, paraWidth);
                contentY += pSize.y + 15;
            }
        }
        contentY += 10;

        // Feature badges (2x2 grid with colored dots)
        float badgeX = contentX;
        float badgeY = contentY;
        float badgeColW = (leftW - padding) / 2;
        for (size_t i = 0; i < sec.story_badges.size() && i < 4; i++) {
            float bx = badgeX + (i % 2) * badgeColW;
            float by = badgeY + (i / 2) * 28;
            // Colored dot
            dl->AddCircleFilled(ImVec2(bx + 6, by + 8), 6, ImGui::ColorConvertFloat4ToU32(sec.story_badges[i].dotColor));
            // Badge text
            dl->AddText(font, 13.0f, ImVec2(bx + 20, by),
                       ImGui::ColorConvertFloat4ToU32(sec.story_text_color), sec.story_badges[i].text);
        }
        contentY = badgeY + 70;

        // CTA Button
        if (sec.story_button_text[0] != '\0') {
            float btnW = 150, btnH = 40;
            ImVec2 btnMin(contentX, contentY);
            ImVec2 btnMax(contentX + btnW, contentY + btnH);
            dl->AddRectFilled(btnMin, btnMax, ImGui::ColorConvertFloat4ToU32(sec.story_button_bg), 6.0f);
            ImVec2 btnTextSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.story_button_text);
            dl->AddText(font, 14.0f, ImVec2(contentX + (btnW - btnTextSize.x)/2, contentY + (btnH - btnTextSize.y)/2),
                       ImGui::ColorConvertFloat4ToU32(sec.story_button_text_color), sec.story_button_text);
            // Arrow
            float arrowX = contentX + btnW - 25;
            float arrowY = contentY + btnH/2;
            dl->AddLine(ImVec2(arrowX, arrowY), ImVec2(arrowX + 10, arrowY), ImGui::ColorConvertFloat4ToU32(sec.story_button_text_color), 2.0f);
            dl->AddLine(ImVec2(arrowX + 6, arrowY - 4), ImVec2(arrowX + 10, arrowY), ImGui::ColorConvertFloat4ToU32(sec.story_button_text_color), 2.0f);
            dl->AddLine(ImVec2(arrowX + 6, arrowY + 4), ImVec2(arrowX + 10, arrowY), ImGui::ColorConvertFloat4ToU32(sec.story_button_text_color), 2.0f);
        }

        // Right side - Stats badge
        float statsX = x + leftW + 40;
        float statsY = y + h - 120;
        float statsSize = 80;
        dl->AddRectFilled(ImVec2(statsX, statsY), ImVec2(statsX + statsSize, statsY + statsSize),
                         ImGui::ColorConvertFloat4ToU32(sec.story_stats_bg), 8.0f);
        ImVec2 numSize = font->CalcTextSizeA(32.0f, FLT_MAX, 0.0f, sec.story_stats_number);
        dl->AddText(font, 32.0f, ImVec2(statsX + (statsSize - numSize.x)/2, statsY + (statsSize - numSize.y)/2),
                   ImGui::ColorConvertFloat4ToU32(sec.story_stats_text_color), sec.story_stats_number);

        // Image collage (3 images)
        float imgX = x + leftW;
        float imgY = y + 30;
        // Image 1 - tall left image
        float img1W = 150, img1H = 180;
        if (sec.story_image_textures[0] != 0) {
            dl->AddImageRounded((ImTextureID)(intptr_t)sec.story_image_textures[0],
                               ImVec2(imgX, imgY), ImVec2(imgX + img1W, imgY + img1H),
                               ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255), 8.0f);
        } else {
            dl->AddRectFilled(ImVec2(imgX, imgY), ImVec2(imgX + img1W, imgY + img1H), IM_COL32(200, 200, 210, 255), 8.0f);
            dl->AddText(font, 11.0f, ImVec2(imgX + 40, imgY + 85), IM_COL32(150, 150, 150, 255), "Click to add\nImage 1");
        }
        // Image 2 - top right
        float img2X = imgX + 160, img2W = 120, img2H = 120;
        if (sec.story_image_textures[1] != 0) {
            dl->AddImageRounded((ImTextureID)(intptr_t)sec.story_image_textures[1],
                               ImVec2(img2X, imgY), ImVec2(img2X + img2W, imgY + img2H),
                               ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255), 8.0f);
        } else {
            dl->AddRectFilled(ImVec2(img2X, imgY), ImVec2(img2X + img2W, imgY + img2H), IM_COL32(200, 200, 210, 255), 8.0f);
            dl->AddText(font, 11.0f, ImVec2(img2X + 25, imgY + 50), IM_COL32(150, 150, 150, 255), "Click to add\nImage 2");
        }
        // Image 3 - bottom right
        float img3Y = imgY + 130, img3W = 120, img3H = 120;
        if (sec.story_image_textures[2] != 0) {
            dl->AddImageRounded((ImTextureID)(intptr_t)sec.story_image_textures[2],
                               ImVec2(img2X, img3Y), ImVec2(img2X + img3W, img3Y + img3H),
                               ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255), 8.0f);
        } else {
            dl->AddRectFilled(ImVec2(img2X, img3Y), ImVec2(img2X + img3W, img3Y + img3H), IM_COL32(200, 200, 210, 255), 8.0f);
            dl->AddText(font, 11.0f, ImVec2(img2X + 25, img3Y + 50), IM_COL32(150, 150, 150, 255), "Click to add\nImage 3");
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // ========================================================================
    // SEC_SERVICES_SECTION_CONNECTOR - Services with cards
    // ========================================================================
    if (sec.type == SEC_SERVICES_SECTION_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float centerX = x + sectionW / 2;
        float contentY = y + 40;

        // Section label
        float labelSize = 12.0f;
        ImVec2 labelTextSize = font->CalcTextSizeA(labelSize, FLT_MAX, 0.0f, sec.services_label);
        float labelX = centerX - labelTextSize.x/2;
        dl->AddLine(ImVec2(labelX - 35, contentY + labelSize/2), ImVec2(labelX - 5, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.services_label_color), 2.0f);
        dl->AddText(font, labelSize, ImVec2(labelX, contentY), ImGui::ColorConvertFloat4ToU32(sec.services_label_color), sec.services_label);
        dl->AddLine(ImVec2(labelX + labelTextSize.x + 5, contentY + labelSize/2), ImVec2(labelX + labelTextSize.x + 35, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.services_label_color), 2.0f);
        contentY += 30;

        // Two-tone heading
        float headingSize = 32.0f;
        std::string fullHeading = std::string(sec.services_heading) + " " + std::string(sec.services_heading_accent);
        ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.services_heading);
        ImVec2 h2Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.services_heading_accent);
        float totalW = h1Size.x + 10 + h2Size.x;
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.services_heading_color), sec.services_heading);
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2 + h1Size.x + 10, contentY), ImGui::ColorConvertFloat4ToU32(sec.services_accent_color), sec.services_heading_accent);
        contentY += headingSize + 15;

        // Subtitle
        ImVec2 subSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.services_subtitle);
        dl->AddText(font, 14.0f, ImVec2(centerX - subSize.x/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.services_subtitle_color), sec.services_subtitle);
        contentY += 50;

        // Service cards
        int cardsPerRow = sec.services_cards_per_row;
        float spacing = sec.services_card_spacing;
        float cardW = (sectionW - 80 - spacing * (cardsPerRow - 1)) / cardsPerRow;
        float cardH = 320;
        float startX = x + 40;

        for (size_t i = 0; i < sec.services_cards.size(); i++) {
            const auto& card = sec.services_cards[i];
            int col = i % cardsPerRow;
            int row = i / cardsPerRow;
            float cx = startX + col * (cardW + spacing);
            float cy = contentY + row * (cardH + spacing);

            // Card background
            dl->AddRectFilled(ImVec2(cx, cy), ImVec2(cx + cardW, cy + cardH), ImGui::ColorConvertFloat4ToU32(card.cardBgColor), card.borderRadius);
            dl->AddRect(ImVec2(cx, cy), ImVec2(cx + cardW, cy + cardH), IM_COL32(230, 230, 235, 255), card.borderRadius, 0, 1.0f);

            // Image area with number overlay
            float imgH = 140;
            if (card.textureID != 0) {
                // Show uploaded image
                dl->AddImageRounded((ImTextureID)(intptr_t)card.textureID,
                                   ImVec2(cx + 15, cy + 15), ImVec2(cx + cardW - 15, cy + imgH),
                                   ImVec2(0, 0), ImVec2(1, 1), IM_COL32(255, 255, 255, 255), 8.0f);
            } else {
                // Placeholder
                dl->AddRectFilled(ImVec2(cx + 15, cy + 15), ImVec2(cx + cardW - 15, cy + imgH), IM_COL32(220, 220, 225, 255), 8.0f);
            }
            // Number overlay
            char numStr[8]; snprintf(numStr, sizeof(numStr), "%02d", (int)(i + 1));
            ImVec2 numSize = font->CalcTextSizeA(48.0f, FLT_MAX, 0.0f, numStr);
            dl->AddText(font, 48.0f, ImVec2(cx + cardW - 15 - numSize.x - 10, cy + imgH - numSize.y - 5), IM_COL32(200, 200, 205, 180), numStr);

            // Icon badge (top-left overlapping)
            float iconBadgeSize = 44;
            float ibx = cx + 25, iby = cy + imgH - iconBadgeSize/2;
            dl->AddRectFilled(ImVec2(ibx, iby), ImVec2(ibx + iconBadgeSize, iby + iconBadgeSize), ImGui::ColorConvertFloat4ToU32(card.iconBgColor), 10.0f);
            DrawIcon(dl, card.iconType, ibx + iconBadgeSize/2, iby + iconBadgeSize/2, iconBadgeSize * 0.5f, IM_COL32(255, 255, 255, 255), 2.0f);

            float textY = cy + imgH + 20;
            // Title
            dl->AddText(font, 16.0f, ImVec2(cx + 15, textY), ImGui::ColorConvertFloat4ToU32(card.titleColor), card.title);
            textY += 25;
            // Description
            ImVec2 descSize = font->CalcTextSizeA(12.0f, FLT_MAX, cardW - 30, card.description);
            dl->AddText(font, 12.0f, ImVec2(cx + 15, textY), ImGui::ColorConvertFloat4ToU32(card.descColor), card.description, nullptr, cardW - 30);
            textY += descSize.y + 15;

            // Bullet points
            for (int b = 0; b < card.bulletCount && b < 6; b++) {
                if (card.bullets[b][0] != '\0') {
                    // Orange square bullet
                    dl->AddRectFilled(ImVec2(cx + 15, textY + 4), ImVec2(cx + 21, textY + 10), ImGui::ColorConvertFloat4ToU32(card.bulletColor));
                    dl->AddText(font, 12.0f, ImVec2(cx + 28, textY), ImGui::ColorConvertFloat4ToU32(card.descColor), card.bullets[b]);
                    textY += 18;
                }
            }

            // Learn More link
            if (card.linkText[0] != '\0') {
                textY = cy + cardH - 30;
                dl->AddText(font, 13.0f, ImVec2(cx + 15, textY), ImGui::ColorConvertFloat4ToU32(card.linkColor), card.linkText);
                ImVec2 linkSize = font->CalcTextSizeA(13.0f, FLT_MAX, 0.0f, card.linkText);
                // Arrow
                float ax = cx + 15 + linkSize.x + 8;
                dl->AddLine(ImVec2(ax, textY + 7), ImVec2(ax + 8, textY + 7), ImGui::ColorConvertFloat4ToU32(card.linkColor), 1.5f);
                dl->AddLine(ImVec2(ax + 5, textY + 4), ImVec2(ax + 8, textY + 7), ImGui::ColorConvertFloat4ToU32(card.linkColor), 1.5f);
                dl->AddLine(ImVec2(ax + 5, textY + 10), ImVec2(ax + 8, textY + 7), ImGui::ColorConvertFloat4ToU32(card.linkColor), 1.5f);
            }
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // ========================================================================
    // SEC_CLIENTS_GRID_CONNECTOR - Client/Partner logo grid
    // ========================================================================
    if (sec.type == SEC_CLIENTS_GRID_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float centerX = x + sectionW / 2;
        float contentY = y + 40;

        // Section label with lines
        float labelSize = 12.0f;
        ImVec2 labelTextSize = font->CalcTextSizeA(labelSize, FLT_MAX, 0.0f, sec.clients_label);
        float labelX = centerX - labelTextSize.x/2;
        dl->AddLine(ImVec2(labelX - 35, contentY + labelSize/2), ImVec2(labelX - 5, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.clients_label_color), 2.0f);
        dl->AddText(font, labelSize, ImVec2(labelX, contentY), ImGui::ColorConvertFloat4ToU32(sec.clients_label_color), sec.clients_label);
        dl->AddLine(ImVec2(labelX + labelTextSize.x + 5, contentY + labelSize/2), ImVec2(labelX + labelTextSize.x + 35, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.clients_label_color), 2.0f);
        contentY += 30;

        // Two-tone heading
        float headingSize = 32.0f;
        ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.clients_heading);
        ImVec2 h2Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.clients_heading_accent);
        float totalW = h1Size.x + 10 + h2Size.x;
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.clients_heading_color), sec.clients_heading);
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2 + h1Size.x + 10, contentY), ImGui::ColorConvertFloat4ToU32(sec.clients_accent_color), sec.clients_heading_accent);
        contentY += headingSize + 15;

        // Subtitle
        ImVec2 subSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.clients_subtitle);
        dl->AddText(font, 14.0f, ImVec2(centerX - subSize.x/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.clients_subtitle_color), sec.clients_subtitle);
        contentY += 50;

        // Client cards grid
        int perRow = sec.clients_per_row;
        float spacing = sec.clients_card_spacing;
        float cardW = (sectionW - 80 - spacing * (perRow - 1)) / perRow;
        float cardH = 100;
        float startX = x + 40;

        for (size_t i = 0; i < sec.clients_items.size(); i++) {
            const auto& client = sec.clients_items[i];
            int col = i % perRow;
            int row = i / perRow;
            float cx = startX + col * (cardW + spacing);
            float cy = contentY + row * (cardH + spacing);

            // Card background with shadow
            dl->AddRectFilled(ImVec2(cx + 2, cy + 2), ImVec2(cx + cardW + 2, cy + cardH + 2), IM_COL32(0, 0, 0, 20), 8.0f);
            dl->AddRectFilled(ImVec2(cx, cy), ImVec2(cx + cardW, cy + cardH), ImGui::ColorConvertFloat4ToU32(client.cardBgColor), 8.0f);

            // Logo text or placeholder
            if (client.useTextLogo) {
                ImVec2 logoSize = font->CalcTextSizeA(20.0f, FLT_MAX, 0.0f, client.logoText);
                dl->AddText(font, 20.0f, ImVec2(cx + (cardW - logoSize.x)/2, cy + 25), ImGui::ColorConvertFloat4ToU32(client.textColor), client.logoText);
            } else {
                // Image placeholder
                dl->AddRectFilled(ImVec2(cx + cardW/2 - 30, cy + 15), ImVec2(cx + cardW/2 + 30, cy + 55), IM_COL32(220, 220, 225, 255), 4.0f);
            }

            // Company name
            ImVec2 nameSize = font->CalcTextSizeA(11.0f, FLT_MAX, 0.0f, client.name);
            dl->AddText(font, 11.0f, ImVec2(cx + (cardW - nameSize.x)/2, cy + cardH - 25), IM_COL32(120, 120, 130, 255), client.name);
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // ========================================================================
    // SEC_FEATURES_GRID_CONNECTOR - Feature cards with checkmarks
    // ========================================================================
    if (sec.type == SEC_FEATURES_GRID_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.bg_color));

        ImFont* font = ImGui::GetFont();
        float centerX = x + sectionW / 2;
        float contentY = y + 40;

        // Section label with lines
        float labelSize = 12.0f;
        ImVec2 labelTextSize = font->CalcTextSizeA(labelSize, FLT_MAX, 0.0f, sec.features_label);
        float labelX = centerX - labelTextSize.x/2;
        dl->AddLine(ImVec2(labelX - 35, contentY + labelSize/2), ImVec2(labelX - 5, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.features_label_color), 2.0f);
        dl->AddText(font, labelSize, ImVec2(labelX, contentY), ImGui::ColorConvertFloat4ToU32(sec.features_label_color), sec.features_label);
        dl->AddLine(ImVec2(labelX + labelTextSize.x + 5, contentY + labelSize/2), ImVec2(labelX + labelTextSize.x + 35, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.features_label_color), 2.0f);
        contentY += 30;

        // Two-tone heading
        float headingSize = 32.0f;
        ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.features_heading);
        ImVec2 h2Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.features_heading_accent);
        float totalW = h1Size.x + 10 + h2Size.x;
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.features_heading_color), sec.features_heading);
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2 + h1Size.x + 10, contentY), ImGui::ColorConvertFloat4ToU32(sec.features_accent_color), sec.features_heading_accent);
        contentY += headingSize + 15;

        // Subtitle
        ImVec2 subSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.features_subtitle);
        dl->AddText(font, 14.0f, ImVec2(centerX - subSize.x/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.features_subtitle_color), sec.features_subtitle);
        contentY += 50;

        // Feature cards
        int perRow = sec.features_cards_per_row;
        float spacing = sec.features_card_spacing;
        float cardW = (sectionW - 80 - spacing * (perRow - 1)) / perRow;
        float cardH = 200;
        float startX = x + 40;

        for (size_t i = 0; i < sec.features_cards.size(); i++) {
            const auto& card = sec.features_cards[i];
            int col = i % perRow;
            int row = i / perRow;
            float cx = startX + col * (cardW + spacing);
            float cy = contentY + row * (cardH + spacing);

            // Card background
            dl->AddRectFilled(ImVec2(cx + 2, cy + 2), ImVec2(cx + cardW + 2, cy + cardH + 2), IM_COL32(0, 0, 0, 15), card.borderRadius);
            dl->AddRectFilled(ImVec2(cx, cy), ImVec2(cx + cardW, cy + cardH), ImGui::ColorConvertFloat4ToU32(card.cardBgColor), card.borderRadius);

            // Icon badge
            float iconSize = 44;
            float ix = cx + 20, iy = cy + 20;
            dl->AddRectFilled(ImVec2(ix, iy), ImVec2(ix + iconSize, iy + iconSize), ImGui::ColorConvertFloat4ToU32(card.iconBgColor), 10.0f);
            DrawIcon(dl, card.iconType, ix + iconSize/2, iy + iconSize/2, iconSize * 0.5f, IM_COL32(255, 255, 255, 255), 2.0f);

            float textY = cy + 80;
            // Title
            dl->AddText(font, 15.0f, ImVec2(cx + 20, textY), ImGui::ColorConvertFloat4ToU32(card.titleColor), card.title);
            textY += 22;
            // Description
            dl->AddText(font, 12.0f, ImVec2(cx + 20, textY), ImGui::ColorConvertFloat4ToU32(card.descColor), card.description, nullptr, cardW - 40);
            textY += 45;

            // Checkmark items
            for (int c = 0; c < card.checkmarkCount && c < 6; c++) {
                if (card.checkmarks[c][0] != '\0') {
                    // Checkmark icon
                    float chkX = cx + 20, chkY = textY + 2;
                    dl->AddLine(ImVec2(chkX, chkY + 5), ImVec2(chkX + 4, chkY + 9), ImGui::ColorConvertFloat4ToU32(card.checkColor), 2.0f);
                    dl->AddLine(ImVec2(chkX + 4, chkY + 9), ImVec2(chkX + 12, chkY + 1), ImGui::ColorConvertFloat4ToU32(card.checkColor), 2.0f);
                    dl->AddText(font, 11.0f, ImVec2(cx + 38, textY), ImGui::ColorConvertFloat4ToU32(card.descColor), card.checkmarks[c]);
                    textY += 16;
                }
            }
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // ========================================================================
    // SEC_PROCESS_TIMELINE_CONNECTOR - Horizontal process timeline
    // ========================================================================
    if (sec.type == SEC_PROCESS_TIMELINE_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.process_bg_color));

        ImFont* font = ImGui::GetFont();
        float centerX = x + sectionW / 2;
        float contentY = y + 40;

        // Section label with lines
        float labelSize = 12.0f;
        ImVec2 labelTextSize = font->CalcTextSizeA(labelSize, FLT_MAX, 0.0f, sec.process_label);
        float labelX = centerX - labelTextSize.x/2;
        dl->AddLine(ImVec2(labelX - 35, contentY + labelSize/2), ImVec2(labelX - 5, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.process_label_color), 2.0f);
        dl->AddText(font, labelSize, ImVec2(labelX, contentY), ImGui::ColorConvertFloat4ToU32(sec.process_label_color), sec.process_label);
        dl->AddLine(ImVec2(labelX + labelTextSize.x + 5, contentY + labelSize/2), ImVec2(labelX + labelTextSize.x + 35, contentY + labelSize/2),
                   ImGui::ColorConvertFloat4ToU32(sec.process_label_color), 2.0f);
        contentY += 30;

        // Two-tone heading (italic style simulated)
        float headingSize = 36.0f;
        ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.process_heading);
        ImVec2 h2Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.process_heading_accent);
        float totalW = h1Size.x + 10 + h2Size.x;
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.process_heading_color), sec.process_heading);
        dl->AddText(font, headingSize, ImVec2(centerX - totalW/2 + h1Size.x + 10, contentY), ImGui::ColorConvertFloat4ToU32(sec.process_accent_color), sec.process_heading_accent);
        contentY += headingSize + 15;

        // Subtitle
        ImVec2 subSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.process_subtitle);
        dl->AddText(font, 14.0f, ImVec2(centerX - subSize.x/2, contentY), ImGui::ColorConvertFloat4ToU32(sec.process_subtitle_color), sec.process_subtitle);
        contentY += 60;

        // Timeline
        int stepCount = (int)sec.process_steps.size();
        if (stepCount > 0) {
            float timelineW = sectionW - 120;
            float stepW = timelineW / stepCount;
            float startX = x + 60;
            float circleY = contentY + 20;
            float circleR = 20;

            // Connecting line
            dl->AddLine(ImVec2(startX + circleR, circleY), ImVec2(startX + timelineW - circleR, circleY),
                       ImGui::ColorConvertFloat4ToU32(sec.process_line_color), 2.0f);

            // Steps
            for (int i = 0; i < stepCount; i++) {
                const auto& step = sec.process_steps[i];
                float sx = startX + i * stepW + stepW/2;

                // Number circle
                dl->AddCircleFilled(ImVec2(sx, circleY), circleR, ImGui::ColorConvertFloat4ToU32(step.numberBgColor));
                char numStr[8]; snprintf(numStr, sizeof(numStr), "%02d", i + 1);
                ImVec2 numSize = font->CalcTextSizeA(12.0f, FLT_MAX, 0.0f, numStr);
                dl->AddText(font, 12.0f, ImVec2(sx - numSize.x/2, circleY - numSize.y/2), ImGui::ColorConvertFloat4ToU32(step.numberTextColor), numStr);

                // Card below
                float cardW = stepW - 20;
                float cardH = 160;
                float cardX = sx - cardW/2;
                float cardY = circleY + circleR + 20;

                dl->AddRectFilled(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH), ImGui::ColorConvertFloat4ToU32(step.cardBgColor), step.borderRadius);
                dl->AddRect(ImVec2(cardX, cardY), ImVec2(cardX + cardW, cardY + cardH), IM_COL32(255, 255, 255, 30), step.borderRadius, 0, 1.0f);

                // Icon badge
                float iconSize = 40;
                float ix = cardX + (cardW - iconSize)/2, iy = cardY + 15;
                dl->AddRectFilled(ImVec2(ix, iy), ImVec2(ix + iconSize, iy + iconSize), ImGui::ColorConvertFloat4ToU32(step.iconBgColor), 10.0f);
                DrawIcon(dl, step.iconType, ix + iconSize/2, iy + iconSize/2, iconSize * 0.45f, IM_COL32(255, 255, 255, 255), 2.0f);

                // Title (centered)
                ImVec2 titleSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, step.title);
                dl->AddText(font, 14.0f, ImVec2(cardX + (cardW - titleSize.x)/2, cardY + 65), ImGui::ColorConvertFloat4ToU32(step.titleColor), step.title);

                // Description (centered, wrapped)
                float descY = cardY + 90;
                ImVec2 descSize = font->CalcTextSizeA(11.0f, FLT_MAX, cardW - 20, step.description);
                dl->AddText(font, 11.0f, ImVec2(cardX + 10, descY), ImGui::ColorConvertFloat4ToU32(step.descColor), step.description, nullptr, cardW - 20);
            }
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // ========================================================================
    // SEC_HERO_SECTION_CONNECTOR - Full hero section with badge, buttons, stats
    // ========================================================================
    if (sec.type == SEC_HERO_SECTION_CONNECTOR) {
        ImVec2 section_min(x, y);
        ImVec2 section_max(x + sectionW, y + h);
        dl->AddRectFilled(section_min, section_max, ImGui::ColorConvertFloat4ToU32(sec.hero_bg_color));

        ImFont* font = ImGui::GetFont();
        float centerX = x + sectionW / 2;
        float contentY = y + 50;
        float contentW = sectionW * 0.7f;  // 70% width for content
        float contentX = x + (sectionW - contentW) / 2;

        // Glass badge with icons and text
        {
            float badgeH = 36;
            ImVec2 badgeTextSize = font->CalcTextSizeA(12.0f, FLT_MAX, 0.0f, sec.hero_badge_text);
            float badgeW = badgeTextSize.x + 70;  // Extra space for icons
            float badgeX = centerX - badgeW/2;
            float badgeY = contentY;

            // Badge background (glass effect)
            dl->AddRectFilled(ImVec2(badgeX, badgeY), ImVec2(badgeX + badgeW, badgeY + badgeH),
                             ImGui::ColorConvertFloat4ToU32(sec.hero_badge_bg), sec.hero_badge_border_radius);
            dl->AddRect(ImVec2(badgeX, badgeY), ImVec2(badgeX + badgeW, badgeY + badgeH),
                       IM_COL32(200, 200, 200, 80), sec.hero_badge_border_radius, 0, 1.0f);

            // Left icon
            DrawIcon(dl, sec.hero_badge_icon_left, badgeX + 18, badgeY + badgeH/2, 14,
                    ImGui::ColorConvertFloat4ToU32(sec.hero_badge_icon_color), 1.5f);

            // Badge text
            dl->AddText(font, 12.0f, ImVec2(badgeX + 35, badgeY + (badgeH - 12)/2),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_badge_text_color), sec.hero_badge_text);

            // Right icon
            DrawIcon(dl, sec.hero_badge_icon_right, badgeX + badgeW - 18, badgeY + badgeH/2, 14,
                    ImGui::ColorConvertFloat4ToU32(sec.hero_badge_icon_color), 1.5f);

            contentY += badgeH + 30;
        }

        // Two-tone heading
        {
            float headingSize = 48.0f;
            ImVec2 h1Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.hero_heading);
            ImVec2 h2Size = font->CalcTextSizeA(headingSize, FLT_MAX, 0.0f, sec.hero_heading_accent);
            float totalW = h1Size.x + 15 + h2Size.x;
            float headX = centerX - totalW/2;

            dl->AddText(font, headingSize, ImVec2(headX, contentY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_heading_color), sec.hero_heading);
            dl->AddText(font, headingSize, ImVec2(headX + h1Size.x + 15, contentY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_accent_color), sec.hero_heading_accent);

            contentY += headingSize + 20;
        }

        // Description paragraph
        {
            float descW = contentW * 0.8f;
            float descX = centerX - descW/2;
            ImVec2 descSize = font->CalcTextSizeA(16.0f, FLT_MAX, descW, sec.hero_description);
            dl->AddText(font, 16.0f, ImVec2(descX, contentY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_description_color), sec.hero_description, nullptr, descW);
            contentY += descSize.y + 35;
        }

        // Two CTA buttons
        {
            float btnH = 48;
            float btnSpacing = 15;
            float primaryW = 180, secondaryW = 160;
            float totalBtnW = primaryW + btnSpacing + secondaryW;
            float btnStartX = centerX - totalBtnW/2;

            // Primary button (filled)
            dl->AddRectFilled(ImVec2(btnStartX, contentY), ImVec2(btnStartX + primaryW, contentY + btnH),
                             ImGui::ColorConvertFloat4ToU32(sec.hero_btn_primary_bg), sec.hero_btn_border_radius);
            ImVec2 primTxtSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.hero_btn_primary_text);
            dl->AddText(font, 14.0f, ImVec2(btnStartX + (primaryW - primTxtSize.x)/2, contentY + (btnH - 14)/2),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_primary_text_color), sec.hero_btn_primary_text);

            // Secondary button (outline)
            float secBtnX = btnStartX + primaryW + btnSpacing;
            dl->AddRect(ImVec2(secBtnX, contentY), ImVec2(secBtnX + secondaryW, contentY + btnH),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_secondary_border), sec.hero_btn_border_radius, 0, 2.0f);
            ImVec2 secTxtSize = font->CalcTextSizeA(14.0f, FLT_MAX, 0.0f, sec.hero_btn_secondary_text);
            dl->AddText(font, 14.0f, ImVec2(secBtnX + (secondaryW - secTxtSize.x)/2, contentY + (btnH - 14)/2),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_secondary_text_color), sec.hero_btn_secondary_text);

            // Arrow icon in secondary button
            float arrowX = secBtnX + secondaryW - 28;
            float arrowY = contentY + btnH/2;
            dl->AddLine(ImVec2(arrowX, arrowY), ImVec2(arrowX + 10, arrowY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_secondary_text_color), 1.5f);
            dl->AddLine(ImVec2(arrowX + 6, arrowY - 4), ImVec2(arrowX + 10, arrowY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_secondary_text_color), 1.5f);
            dl->AddLine(ImVec2(arrowX + 6, arrowY + 4), ImVec2(arrowX + 10, arrowY),
                       ImGui::ColorConvertFloat4ToU32(sec.hero_btn_secondary_text_color), 1.5f);

            contentY += btnH + 30;
        }

        // Feature badges row (checkmarks with text)
        if (!sec.hero_feature_badges.empty()) {
            int badgeCount = (int)sec.hero_feature_badges.size();
            float badgeSpacing = 30;
            float totalBadgeW = 0;
            std::vector<float> badgeWidths;
            for (const auto& badge : sec.hero_feature_badges) {
                ImVec2 size = font->CalcTextSizeA(12.0f, FLT_MAX, 0.0f, badge.text);
                float w = 24 + size.x;  // checkmark + text
                badgeWidths.push_back(w);
                totalBadgeW += w;
            }
            totalBadgeW += (badgeCount - 1) * badgeSpacing;

            float badgeX = centerX - totalBadgeW/2;
            for (int i = 0; i < badgeCount; i++) {
                const auto& badge = sec.hero_feature_badges[i];
                // Checkmark
                float chkX = badgeX, chkY = contentY + 4;
                dl->AddCircleFilled(ImVec2(chkX + 8, chkY + 6), 10, ImGui::ColorConvertFloat4ToU32(badge.checkColor));
                dl->AddLine(ImVec2(chkX + 4, chkY + 6), ImVec2(chkX + 7, chkY + 9), IM_COL32(255, 255, 255, 255), 2.0f);
                dl->AddLine(ImVec2(chkX + 7, chkY + 9), ImVec2(chkX + 12, chkY + 3), IM_COL32(255, 255, 255, 255), 2.0f);
                // Text
                dl->AddText(font, 12.0f, ImVec2(badgeX + 24, contentY),
                           ImGui::ColorConvertFloat4ToU32(sec.hero_description_color), badge.text);
                badgeX += badgeWidths[i] + badgeSpacing;
            }
            contentY += 35;
        }

        // Stats counter section
        if (!sec.hero_stats.empty()) {
            contentY += 20;
            int statCount = (int)sec.hero_stats.size();
            float statSpacing = 60;
            float statW = 100;
            float totalStatW = statCount * statW + (statCount - 1) * statSpacing;
            float statStartX = centerX - totalStatW/2;

            for (int i = 0; i < statCount; i++) {
                const auto& stat = sec.hero_stats[i];
                float sx = statStartX + i * (statW + statSpacing);

                // Icon
                float iconSize = 28;
                float iconX = sx + statW/2;
                float iconY = contentY + 10;
                dl->AddCircleFilled(ImVec2(iconX, iconY), 22, IM_COL32(255, 240, 230, 255));
                DrawIcon(dl, stat.iconType, iconX, iconY, iconSize * 0.4f,
                        ImGui::ColorConvertFloat4ToU32(stat.iconColor), 2.0f);

                // Number
                float numY = contentY + 45;
                ImVec2 numSize = font->CalcTextSizeA(28.0f, FLT_MAX, 0.0f, stat.number);
                dl->AddText(font, 28.0f, ImVec2(sx + (statW - numSize.x)/2, numY),
                           ImGui::ColorConvertFloat4ToU32(stat.numberColor), stat.number);

                // Label
                float lblY = numY + 32;
                ImVec2 lblSize = font->CalcTextSizeA(11.0f, FLT_MAX, 0.0f, stat.label);
                dl->AddText(font, 11.0f, ImVec2(sx + (statW - lblSize.x)/2, lblY),
                           ImGui::ColorConvertFloat4ToU32(stat.labelColor), stat.label);
            }
        }

        if (sec.selected) dl->AddRect(section_min, section_max, IM_COL32(100, 150, 255, 255), 0, 0, 2.0f);
        return;
    }

    // Default - render title and paragraphs
    float contentY = y + sec.padding_top;

    if (!sec.title.empty()) {
        ImFont* font = ImGui::GetFont();
        ImVec2 titleSize = font->CalcTextSizeA(ValidFontSize(sec.title_font_size), FLT_MAX, 0.0f, sec.title.c_str());

        int titleLayers = (sec.title_font_weight >= 800.0f) ? 9 : ((sec.title_font_weight >= 500.0f) ? 4 : 1);
        float titleBoldStrength = (sec.title_font_weight >= 800.0f) ? 1.0f : ((sec.title_font_weight >= 500.0f) ? 0.5f : 0.0f);

        if (titleLayers > 1) {
            for (int layer = 0; layer < titleLayers; layer++) {
                float offsetX = (layer % 3) * titleBoldStrength * 0.5f;
                float offsetY = (layer / 3) * titleBoldStrength * 0.5f;
                dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2 + offsetX, contentY + offsetY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
            }
        } else {
            dl->AddText(font, ValidFontSize(sec.title_font_size), ImVec2(cx - titleSize.x / 2, contentY), ImGui::ColorConvertFloat4ToU32(sec.title_color), sec.title.c_str());
        }
        contentY += titleSize.y + 30;  // Move down for paragraphs
    }

    // Render paragraphs below title
    if (!sec.paragraphs.empty()) {
        float paraMaxWidth = sectionW - sec.padding_left - sec.padding_right;
        float paraX = x + sec.padding_left;

        for (const auto& para : sec.paragraphs) {
            if (para.text.empty()) continue;

            // Render wrapped paragraph text
            float paraHeight = DrawWrappedText(dl, para.text, paraX, contentY, paraMaxWidth,
                                               ImGui::ColorConvertFloat4ToU32(para.color),
                                               true, para.font_size, para.font_weight);
            contentY += paraHeight + 16;  // Add spacing between paragraphs

            // Stop if we run out of space
            if (contentY > y + h - 20) break;
        }
    }

    // ========================================================================
    // RENDER MOVEABLE IMAGES (on top of all content)
    // ========================================================================
    // MOVEABLE IMAGES RENDERING - DISABLED PER USER REQUEST
    // (Rendering code removed from preview but data structure preserved)

    /* COMMENTED OUT - Moveable Images Feature
    ImVec2 mouse_pos = ImGui::GetMousePos();
    bool mouse_down = ImGui::IsMouseDown(0);
    bool mouse_released = ImGui::IsMouseReleased(0);

    for (auto& img : sec.moveable_images) {
        // ... rendering code removed ...
    }
    */
}

// ============================================================================
// MAIN UI (Same as Website Builder V1)
// ============================================================================
void RenderUI() {
    ImGuiIO& io = ImGui::GetIO();
    ImGuiStyle& style = ImGui::GetStyle();

    style.Colors[ImGuiCol_WindowBg] = ImVec4(0.11f, 0.11f, 0.14f, 1.0f);
    style.Colors[ImGuiCol_ChildBg] = ImVec4(0.14f, 0.14f, 0.17f, 1.0f);
    style.Colors[ImGuiCol_Button] = ImVec4(0.2f, 0.22f, 0.27f, 1.0f);
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.28f, 0.30f, 0.38f, 1.0f);
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.18f, 0.18f, 0.22f, 1.0f);
    style.WindowRounding = 0;
    style.FrameRounding = 5;

    // TOP BAR - Made taller to fit all buttons
    ImGui::SetNextWindowPos(ImVec2(0, 0));
    ImGui::SetNextWindowSize(ImVec2(io.DisplaySize.x, 60));
    ImGui::Begin("##Top", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar);

    // First row - Title and Project Name
    ImGui::SetCursorPosY(8);
    ImGui::TextColored(ImVec4(0.4f, 0.7f, 1.0f, 1.0f), "ImGui Website Designer");
    ImGui::SameLine(200);
    ImGui::SetNextItemWidth(150);
    char pn[128];
    strncpy(pn, g_ProjectName.c_str(), sizeof(pn) - 1);
    pn[sizeof(pn) - 1] = '\0';
    if (ImGui::InputText("##PN", pn, sizeof(pn))) g_ProjectName = pn;

    // Zoom control on first row
    ImGui::SameLine(io.DisplaySize.x - 120);
    ImGui::Text("Zoom:");
    ImGui::SameLine();
    ImGui::SetNextItemWidth(50);
    int zp = (int)(g_Zoom * 100);
    if (ImGui::SliderInt("##Z", &zp, 50, 150, "%d%%")) g_Zoom = zp / 100.0f;

    // Second row - All action buttons
    ImGui::SetCursorPosY(32);
    ImGui::SetCursorPosX(10);
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.3f, 0.5f, 1));
    if (ImGui::Button("Templates", ImVec2(80, 26))) {
        LoadAvailableTemplates();
        g_ShowTemplateGallery = true;
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.7f, 0.4f, 1));
    if (ImGui::Button("New Template", ImVec2(100, 26))) {
        // Clear all sections and start fresh
        g_Sections.clear();
        g_SelectedSectionIndex = -1;
        g_ProjectName = "My Website";
        g_CurrentPage = "Home";
        g_CurrentPageIndex = 0;
        g_FigmaMode = false;  // Exit Figma mode when creating new template
        printf("New template created - starting fresh!\n");
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.9f, 0.5f, 0.2f, 1));
    if (ImGui::Button("Import URL", ImVec2(85, 26))) {
        g_ShowURLImportDialog = true;
        g_URLImportBuffer[0] = '\0';
        g_URLImportStatus = "";
        g_URLImportInProgress = false;
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.5f, 0.3f, 0.8f, 1));
    if (ImGui::Button("Save Template", ImVec2(105, 26))) {
        // Always save as ImGui template
        g_ShowSaveImGuiTemplatePopup = true;
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.5f, 0.2f, 1));
    if (ImGui::Button("Copy Template", ImVec2(105, 26))) {
        g_ShowCopyTemplatePopup = true;
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.3f, 1));
    if (ImGui::Button("Preview", ImVec2(65, 26))) {
        // Check if in Figma mode with layers
        if (g_FigmaMode && !g_FigmaProject.layers.empty()) {
            PreviewFigmaAsHTML();
        } else {
            PreviewImGuiWebsite();
        }
    }
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.5f, 0.8f, 1));
    if (ImGui::Button("Export", ImVec2(65, 26))) ExportImGuiWebsite();
    ImGui::PopStyleColor();

    ImGui::End();

    // LEFT PANEL
    float lpw = 180;
    ImGui::SetNextWindowPos(ImVec2(0, 60));
    ImGui::SetNextWindowSize(ImVec2(lpw, io.DisplaySize.y - 60));
    ImGui::Begin("##Left", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);
    // ==================== PAGE BACKGROUND ====================
    ImGui::TextColored(ImVec4(0.4f, 0.7f, 0.9f, 1), "PAGE BACKGROUND");
    ImGui::Separator();
    ImGui::ColorEdit4("##NormalPageBg", (float*)&g_NormalCanvasBgColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);
    ImGui::SameLine();
    ImGui::Text("Color");
    if (ImGui::Button("W##NBg", ImVec2(22, 20))) g_NormalCanvasBgColor = ImVec4(1, 1, 1, 1);
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("White");
    ImGui::SameLine();
    if (ImGui::Button("L##NBg", ImVec2(22, 20))) g_NormalCanvasBgColor = ImVec4(0.96f, 0.96f, 0.96f, 1);
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Light Gray");
    ImGui::SameLine();
    if (ImGui::Button("D##NBg", ImVec2(22, 20))) g_NormalCanvasBgColor = ImVec4(0.12f, 0.12f, 0.15f, 1);
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Dark");
    ImGui::Spacing();

    // ==================== DESIGN MODE TOGGLE ====================
    ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.3f, 1), "DESIGN MODE");
    ImGui::Separator();
    if (ImGui::Checkbox("Free Design", &g_FreeDesignMode)) {
        // Mode changed
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Enable to move/resize elements freely like Figma.\nDisable for vertical stacked layout.");
    }
    ImGui::Spacing();

    // ==================== BASIC ELEMENTS (Free Design Mode) ====================
    if (g_FreeDesignMode) {
        ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.5f, 1), "ELEMENTS");
        ImGui::Separator();

        // Logo Button
        if (ImGui::Button("+ Logo", ImVec2(-1, 26))) {
            WebSection sec(g_NextSectionId++, SEC_LOGO);
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 150;
            sec.height = 50;
            sec.title = "LOGO";
            sec.bg_color = ImVec4(0.2f, 0.5f, 0.8f, 1.0f);
            sec.text_color = ImVec4(1, 1, 1, 1);
            sec.z_index = (int)g_Sections.size();
            g_Sections.push_back(sec);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
        }

        // Heading Button
        if (ImGui::Button("+ Heading", ImVec2(-1, 26))) {
            WebSection sec(g_NextSectionId++, SEC_HEADING);
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 400;
            sec.height = 60;
            sec.title = "Heading Text";
            sec.title_font_size = 48;
            sec.title_font_weight = 700;
            sec.title_color = ImVec4(0.1f, 0.1f, 0.1f, 1);
            sec.bg_color = ImVec4(0, 0, 0, 0);  // Transparent
            sec.z_index = (int)g_Sections.size();
            g_Sections.push_back(sec);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
        }

        // Text Button
        if (ImGui::Button("+ Text", ImVec2(-1, 26))) {
            WebSection sec(g_NextSectionId++, SEC_TEXT_ELEMENT);
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 300;
            sec.height = 40;
            sec.content = "Your text here";
            sec.content_font_size = 18;
            sec.content_color = ImVec4(0.2f, 0.2f, 0.2f, 1);
            sec.bg_color = ImVec4(0, 0, 0, 0);  // Transparent
            sec.z_index = (int)g_Sections.size();
            g_Sections.push_back(sec);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
        }

        // Button with Action
        if (ImGui::Button("+ Button", ImVec2(-1, 26))) {
            WebSection sec(g_NextSectionId++, SEC_BUTTON_ELEMENT);
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 150;
            sec.height = 45;
            sec.button_text = "Click Me";
            sec.button_link = "#";
            sec.button_bg_color = ImVec4(0.2f, 0.5f, 0.8f, 1.0f);
            sec.button_text_color = ImVec4(1, 1, 1, 1);
            sec.button_font_size = 16;
            sec.button_border_radius = 8;
            sec.z_index = (int)g_Sections.size();
            g_Sections.push_back(sec);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
        }

        ImGui::Spacing();
    }

    // ==================== PAGES MANAGEMENT ====================
    ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.9f, 1), "PAGES");
    ImGui::Separator();

    // Initialize pages if empty
    if (g_NormalPages.empty()) {
        g_NormalPages.push_back(NormalModePage("Home"));
        g_CurrentPageIndex = 0;
    }

    // Page tabs
    ImGui::BeginChild("PageTabs", ImVec2(-1, 35), false, ImGuiWindowFlags_HorizontalScrollbar);
    for (int i = 0; i < (int)g_NormalPages.size(); i++) {
        ImGui::PushID(i);
        bool isSelected = (i == g_CurrentPageIndex);

        if (isSelected) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.6f, 0.9f, 1.0f));
        } else {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.25f, 0.25f, 0.3f, 1.0f));
        }

        char pageLabel[64];
        snprintf(pageLabel, sizeof(pageLabel), "%s##page%d", g_NormalPages[i].name.c_str(), i);
        if (ImGui::Button(pageLabel, ImVec2(0, 25))) {
            // Save current page sections before switching
            if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
                g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
            }
            // Switch to selected page
            g_CurrentPageIndex = i;
            g_Sections = g_NormalPages[i].sections;
            g_SelectedSectionIndex = g_Sections.empty() ? -1 : 0;
        }
        ImGui::PopStyleColor();

        ImGui::SameLine();
        ImGui::PopID();
    }
    ImGui::EndChild();

    // Page management buttons
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
    if (ImGui::Button("+ Add Page", ImVec2(80, 22))) {
        // Save current page first
        if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
            g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
        }
        // Create new page
        char newPageName[32];
        snprintf(newPageName, sizeof(newPageName), "Page %d", (int)g_NormalPages.size() + 1);
        g_NormalPages.push_back(NormalModePage(newPageName));
        g_CurrentPageIndex = (int)g_NormalPages.size() - 1;
        g_Sections.clear();
        g_SelectedSectionIndex = -1;
    }
    ImGui::PopStyleColor();

    ImGui::SameLine();

    // Delete page button (only if more than 1 page)
    if (g_NormalPages.size() > 1) {
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
        if (ImGui::Button("Delete", ImVec2(55, 22))) {
            g_NormalPages.erase(g_NormalPages.begin() + g_CurrentPageIndex);
            if (g_CurrentPageIndex >= (int)g_NormalPages.size()) {
                g_CurrentPageIndex = (int)g_NormalPages.size() - 1;
            }
            g_Sections = g_NormalPages[g_CurrentPageIndex].sections;
            g_SelectedSectionIndex = g_Sections.empty() ? -1 : 0;
        }
        ImGui::PopStyleColor();
    }

    ImGui::SameLine();

    // Rename current page
    if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
        static char renameBuffer[64] = "";
        static bool renaming = false;

        if (!renaming) {
            if (ImGui::Button("Rename", ImVec2(55, 22))) {
                strncpy(renameBuffer, g_NormalPages[g_CurrentPageIndex].name.c_str(), sizeof(renameBuffer) - 1);
                renaming = true;
            }
        } else {
            ImGui::SetNextItemWidth(80);
            if (ImGui::InputText("##renamePage", renameBuffer, sizeof(renameBuffer), ImGuiInputTextFlags_EnterReturnsTrue)) {
                g_NormalPages[g_CurrentPageIndex].name = renameBuffer;
                renaming = false;
            }
            ImGui::SameLine();
            if (ImGui::Button("OK", ImVec2(25, 22))) {
                g_NormalPages[g_CurrentPageIndex].name = renameBuffer;
                renaming = false;
            }
        }
    }

    // Update g_Pages for compatibility (action settings dropdown)
    g_Pages.clear();
    for (const auto& page : g_NormalPages) {
        g_Pages.push_back(page.name);
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "SECTIONS");
    ImGui::Separator();

    struct SB { const char* n; SectionType t; };
    SB btns[] = {{"+ Hero", SEC_HERO}, {"+ Navigation", SEC_NAVBAR}, {"+ Cards", SEC_CARDS}, {"+ Team", SEC_TEAM}, {"+ Pricing", SEC_PRICING},
                 {"+ Stats", SEC_STATS}, {"+ Gallery", SEC_GALLERY}, {"+ Contact", SEC_CONTACT}, {"+ CTA", SEC_CTA}, {"+ Image", SEC_IMAGE}, {"+ Text Box", SEC_TEXTBOX}, {"+ Footer", SEC_FOOTER}};
    for (auto& b : btns) {
        if (ImGui::Button(b.n, ImVec2(-1, 26))) {
            // For these sections, directly create without template picker
            if (b.t == SEC_IMAGE || b.t == SEC_TEXTBOX || b.t == SEC_HERO || b.t == SEC_NAVBAR || b.t == SEC_TEAM || b.t == SEC_FOOTER || b.t == SEC_CARDS || b.t == SEC_PRICING || b.t == SEC_STATS || b.t == SEC_CTA) {
                WebSection sec(g_NextSectionId++, b.t);

                // FREE DESIGN MODE: Set initial position and size
                if (g_FreeDesignMode) {
                    // Calculate Y position based on existing sections
                    float nextY = 20;  // Start offset
                    for (const auto& s : g_Sections) {
                        float sBottom = s.y_position + s.height;
                        if (sBottom > nextY) nextY = sBottom + 20;  // Add gap
                    }
                    sec.x_position = 20;  // Left margin
                    sec.y_position = nextY;
                    sec.width = 760;      // Default width (leaving margins)
                    sec.z_index = (int)g_Sections.size();  // Stack on top
                    sec.use_manual_position = true;  // Enable free positioning

                    // Set specific sizes based on section type
                    switch (b.t) {
                        case SEC_HERO: sec.height = 400; break;
                        case SEC_NAVBAR: sec.height = 60; sec.y_position = 0; break;
                        case SEC_FOOTER: sec.height = 200; break;
                        case SEC_CARDS: sec.height = 350; break;
                        case SEC_CTA: sec.height = 200; break;
                        case SEC_TEXTBOX: sec.height = 400; break;
                        default: sec.height = 300; break;
                    }
                }
                // STACKED MODE: Smart auto-positioning
                else if (!g_Sections.empty()) {
                    // Get the last added section
                    WebSection& lastSec = g_Sections.back();

                    // If last section has width < 100%, try to fill remaining space
                    if (lastSec.section_width_percent < 100.0f) {
                        float remainingSpace = 100.0f - lastSec.section_width_percent;

                        // Set new section width to fill remaining space
                        sec.section_width_percent = remainingSpace;

                        // Determine alignment based on last section's position
                        if (lastSec.horizontal_align == 0) {
                            // Last section is LEFT aligned, place new section on RIGHT
                            sec.horizontal_align = 2;  // Right
                        } else if (lastSec.horizontal_align == 2) {
                            // Last section is RIGHT aligned, place new section on LEFT
                            sec.horizontal_align = 0;  // Left
                        } else {
                            // Last section is CENTER aligned, place new section on RIGHT
                            sec.horizontal_align = 2;  // Right
                        }

                        // FORCE enable manual positioning for side-by-side layout
                        // Calculate Y position based on whether last section uses manual position
                        if (lastSec.use_manual_position) {
                            // Last section already has manual position, use same Y
                            sec.use_manual_position = true;
                            sec.y_position = lastSec.y_position;
                        } else {
                            // Last section doesn't have manual position, calculate current Y
                            // Sum up heights of all previous sections
                            float calculatedY = 0;
                            for (int i = 0; i < (int)g_Sections.size(); i++) {
                                if (i == (int)g_Sections.size() - 1) break; // Stop before last section
                                if (!g_Sections[i].use_manual_position) {
                                    calculatedY += g_Sections[i].height;
                                }
                            }
                            // Enable manual position for BOTH sections
                            lastSec.use_manual_position = true;
                            lastSec.y_position = calculatedY;
                            sec.use_manual_position = true;
                            sec.y_position = calculatedY;
                        }

                        // Match height for better alignment
                        sec.height = lastSec.height;
                    }
                }

                g_Sections.push_back(sec);
                g_SelectedSectionIndex = (int)g_Sections.size() - 1;
                for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
            } else {
                // Open template picker modal for other sections
                g_PickerSectionType = b.t;
                g_ShowTemplatePicker = true;
                g_SelectedStyleIndex = -1;
            }
        }
    }

    // ==================== CONNECTORS SECTION ====================
    ImGui::Spacing();
    ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "CONNECTORS");
    ImGui::Separator();

    // Text Block Connector
    if (ImGui::Button("+ Text Block", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_TEXT_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    // Bar Heading Connector
    if (ImGui::Button("+ Bar Heading", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_BAR_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    // Footer Columns Connector
    if (ImGui::Button("+ Footer Columns", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_FOOTER_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    // Thumbnail Cards Connector
    if (ImGui::Button("+ Thumbnail Cards", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_CARD_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    // Vertical Layout Connector
    if (ImGui::Button("+ Vertical Layout", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_VERTICAL_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Navbar Menu", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_NAVBAR_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Copyright Bar", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_COPYRIGHT_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 760;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Article Cards", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_ARTICLE_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1040;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Contact Form", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_CONTACT_FORM_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 800;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Search Bar", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_SEARCH_CONNECTOR);
        sec.height = 80;
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 800;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Logo", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_LOGO_CONNECTOR);
        sec.height = 100;
        sec.logo_width = 200;
        sec.logo_height = 80;
        sec.logo_alignment = 1;  // Center
        sec.logo_maintain_aspect = true;
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 300;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Bullet Points", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_BULLET_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 800;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Icon", ImVec2(-1, 26))) {
        // Show icon picker popup to select which icon to add
        g_ShowIconPickerPopup = true;
        g_AddingNewIcon = true;
        g_IconPickerTarget = nullptr;  // Not modifying existing icon
    }

    if (ImGui::Button("+ Service Cards", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_SERVICE_CARD_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 900;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Glass Bar", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_GLASS_BAR_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 600;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Story Section", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_STORY_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 900;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Services Section", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_SERVICES_SECTION_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1000;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Clients Grid", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_CLIENTS_GRID_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1000;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Features Grid", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_FEATURES_GRID_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1000;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Process Timeline", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_PROCESS_TIMELINE_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1000;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    if (ImGui::Button("+ Hero Section", ImVec2(-1, 26))) {
        WebSection sec(g_NextSectionId++, SEC_HERO_SECTION_CONNECTOR);
        if (g_FreeDesignMode) {
            float nextY = 20;
            for (const auto& s : g_Sections) {
                float sBottom = s.y_position + s.height;
                if (sBottom > nextY) nextY = sBottom + 20;
            }
            sec.x_position = 20;
            sec.y_position = nextY;
            sec.width = 1000;
            sec.z_index = (int)g_Sections.size();
            sec.use_manual_position = true;
        }
        g_Sections.push_back(sec);
        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
    }

    ImGui::Spacing();
    ImGui::TextColored(ImVec4(0.2f, 0.7f, 0.9f, 1), "QUICK TEMPLATES");
    ImGui::Separator();

    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.9f, 0.4f, 0.1f, 1.0f));  // Orange like OMNiON
    if (ImGui::Button("Create OMNiON Website", ImVec2(-1, 30))) {
        CreateOMNiONWebsite();
    }
    ImGui::PopStyleColor();

    ImGui::Spacing();
    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "LAYERS");
    ImGui::Separator();
    for (int i = 0; i < (int)g_Sections.size(); i++) {
        char lbl[64];
        snprintf(lbl, sizeof(lbl), "%d. %s", i + 1, g_Sections[i].name.c_str());
        if (ImGui::Selectable(lbl, i == g_SelectedSectionIndex)) {
            g_SelectedSectionIndex = i;
            for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == i);
        }
        if (ImGui::BeginPopupContextItem()) {
            if (ImGui::MenuItem("Move Up") && i > 0) std::swap(g_Sections[i], g_Sections[i - 1]);
            if (ImGui::MenuItem("Move Down") && i < (int)g_Sections.size() - 1) std::swap(g_Sections[i], g_Sections[i + 1]);
            ImGui::Separator();
            if (ImGui::MenuItem("Duplicate")) {
                WebSection cp = g_Sections[i];
                cp.id = g_NextSectionId++;
                g_Sections.insert(g_Sections.begin() + i + 1, cp);
            }
            if (ImGui::MenuItem("Delete")) {
                g_Sections.erase(g_Sections.begin() + i);
                g_SelectedSectionIndex = std::min(g_SelectedSectionIndex, (int)g_Sections.size() - 1);
            }
            ImGui::EndPopup();
        }
    }

    // Glass Panel Tool
    ImGui::Spacing();
    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "GLASS PANELS");
    ImGui::Separator();
    if (g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size()) {
        WebSection& sec = g_Sections[g_SelectedSectionIndex];
        if (ImGui::Button("+ Add Glass Panel", ImVec2(-1, 26))) {
            WebSection::GlassPanel gp;
            gp.x = 50;
            gp.y = 50;
            gp.width = 200;
            gp.height = 100;
            gp.text = "Glass Panel";
            gp.text_size = 16;
            gp.text_color = ImVec4(1, 1, 1, 1);
            gp.opacity = 0.25f;
            gp.blur = 10.0f;
            gp.tint = ImVec4(1, 1, 1, 0.15f);
            gp.border_radius = 16.0f;
            gp.selected = false;
            sec.glass_panels.push_back(gp);
        }
        // List glass panels in current section
        for (int gpi = 0; gpi < (int)sec.glass_panels.size(); gpi++) {
            ImGui::PushID(gpi + 10000);
            char gpLabel[64];
            snprintf(gpLabel, sizeof(gpLabel), "Panel %d", gpi + 1);
            if (ImGui::Selectable(gpLabel, sec.glass_panels[gpi].selected)) {
                // Deselect all, select this one
                for (auto& p : sec.glass_panels) p.selected = false;
                sec.glass_panels[gpi].selected = true;
            }
            if (ImGui::BeginPopupContextItem()) {
                if (ImGui::MenuItem("Delete")) {
                    sec.glass_panels.erase(sec.glass_panels.begin() + gpi);
                    gpi--;
                }
                ImGui::EndPopup();
            }
            ImGui::PopID();
        }
    } else {
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 0.7f), "Select a section first");
    }
    ImGui::End();

    // ==================== FIGMA MODE: 3-PANEL LAYOUT ====================
    if (g_FigmaMode) {
        float figma_lpw = 180;  // Left panel width (layers)
        float figma_rpw = 300;  // Right panel width (properties)
        float figma_cw = io.DisplaySize.x - figma_lpw - figma_rpw;  // Center canvas width
        float figma_ch = io.DisplaySize.y - 60;  // Height (below top bar)

        // ==================== FIGMA LEFT PANEL (LAYERS) ====================
        ImGui::SetNextWindowPos(ImVec2(0, 60));
        ImGui::SetNextWindowSize(ImVec2(figma_lpw, figma_ch));
        ImGui::Begin("##FigmaLeftPanel", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);

        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "LAYERS");
        ImGui::Separator();

        // Add layer button
        if (ImGui::Button("+ Add Layer", ImVec2(-1, 26))) {
            WebLayer newLayer;
            newLayer.id = g_FigmaProject.next_layer_id++;
            newLayer.name = "New Layer";
            newLayer.x = 100;
            newLayer.y = 100;
            newLayer.width = 200;
            newLayer.height = 100;
            newLayer.bg_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
            g_FigmaProject.layers.push_back(newLayer);
            SelectLayer(newLayer.id);
        }

        ImGui::Spacing();

        // Toggle between section view and flat layer list
        if (!g_FigmaProject.sections.empty()) {
            ImGui::Checkbox("Section View", &g_FigmaProject.show_sections);
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.4f, 0.4f, 0.4f, 1), "(%zu sections, %zu layers)",
                g_FigmaProject.sections.size(), g_FigmaProject.layers.size());
        } else {
            ImGui::TextColored(ImVec4(0.4f, 0.4f, 0.4f, 1), "LAYER LIST (%zu)", g_FigmaProject.layers.size());
        }
        ImGui::Separator();

        // Helper lambda to render a layer item
        auto renderLayerItem = [&](WebLayer& layer, int index) {
            ImGui::PushID(layer.id);

            // Visibility toggle
            if (ImGui::Checkbox("##vis", &layer.visible)) {}
            ImGui::SameLine();

            // Type icon
            const char* icon = "[D]";
            switch (layer.type) {
                case LAYER_TEXT: icon = "[T]"; break;
                case LAYER_IMAGE: icon = "[I]"; break;
                case LAYER_BUTTON: icon = "[B]"; break;
                case LAYER_INPUT: icon = "[F]"; break;
                default: break;
            }

            char label[128];
            snprintf(label, sizeof(label), "%s %s", icon, layer.name.c_str());

            if (ImGui::Selectable(label, layer.selected)) {
                SelectLayer(layer.id);
            }

            // Right-click context menu
            if (ImGui::BeginPopupContextItem()) {
                if (ImGui::MenuItem("Delete")) {
                    g_FigmaProject.layers.erase(g_FigmaProject.layers.begin() + index);
                    if (g_SelectedLayerId == layer.id) g_SelectedLayerId = -1;
                }
                if (ImGui::MenuItem("Duplicate")) {
                    WebLayer dup = layer;
                    dup.id = g_FigmaProject.next_layer_id++;
                    dup.name = layer.name + " copy";
                    dup.x += 20;
                    dup.y += 20;
                    dup.selected = false;
                    g_FigmaProject.layers.push_back(dup);
                }
                ImGui::EndPopup();
            }

            ImGui::PopID();
        };

        // Section view mode
        if (g_FigmaProject.show_sections && !g_FigmaProject.sections.empty()) {
            for (auto& section : g_FigmaProject.sections) {
                ImGui::PushID(section.id);

                // Section header with expand/collapse
                char sectionLabel[256];
                snprintf(sectionLabel, sizeof(sectionLabel), "%s %s (%zu)",
                    section.expanded ? "v" : ">",
                    section.name.c_str(),
                    section.layer_ids.size());

                // Section header - clickable
                ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.2f, 0.4f, 0.6f, 0.5f));
                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.3f, 0.5f, 0.7f, 0.6f));

                if (ImGui::Selectable(sectionLabel, false, ImGuiSelectableFlags_None)) {
                    section.expanded = !section.expanded;
                }

                // Right-click menu for section
                if (ImGui::BeginPopupContextItem()) {
                    if (ImGui::MenuItem("Select All Layers")) {
                        // Select all layers in this section
                        for (int layerId : section.layer_ids) {
                            for (auto& layer : g_FigmaProject.layers) {
                                if (layer.id == layerId) {
                                    layer.selected = true;
                                    g_SelectedLayerId = layerId;
                                }
                            }
                        }
                    }
                    if (ImGui::MenuItem("Hide Section")) {
                        for (int layerId : section.layer_ids) {
                            for (auto& layer : g_FigmaProject.layers) {
                                if (layer.id == layerId) layer.visible = false;
                            }
                        }
                    }
                    if (ImGui::MenuItem("Show Section")) {
                        for (int layerId : section.layer_ids) {
                            for (auto& layer : g_FigmaProject.layers) {
                                if (layer.id == layerId) layer.visible = true;
                            }
                        }
                    }
                    if (ImGui::MenuItem("Scroll to Section")) {
                        g_FigmaProject.scroll_y = section.y_start;
                    }
                    ImGui::EndPopup();
                }

                ImGui::PopStyleColor(2);

                // Show layers in this section if expanded
                if (section.expanded) {
                    ImGui::Indent(15.0f);
                    for (int layerId : section.layer_ids) {
                        // Find layer by id
                        for (int i = 0; i < (int)g_FigmaProject.layers.size(); i++) {
                            if (g_FigmaProject.layers[i].id == layerId) {
                                renderLayerItem(g_FigmaProject.layers[i], i);
                                break;
                            }
                        }
                    }
                    ImGui::Unindent(15.0f);
                }

                ImGui::PopID();
            }
        } else {
            // Flat layer list (reverse order - top layers first)
            for (int i = g_FigmaProject.layers.size() - 1; i >= 0; i--) {
                renderLayerItem(g_FigmaProject.layers[i], i);
            }
        }

        ImGui::End();  // End FigmaLeftPanel

        // ==================== FIGMA CENTER CANVAS ====================
        ImGui::SetNextWindowPos(ImVec2(figma_lpw, 60));
        ImGui::SetNextWindowSize(ImVec2(figma_cw, figma_ch));
        ImGui::Begin("##FigmaCanvas", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);

        // ==================== TOP TOOLBAR ====================
        float toolbarHeight = 50;
        ImGui::SetCursorPos(ImVec2(0, 0));
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.12f, 0.12f, 0.15f, 1.0f));
        ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 0);
        ImGui::BeginChild("##FigmaTopBar", ImVec2(figma_cw, toolbarHeight), true);

        // Static for load popup
        static bool showLoadPopup = false;
        static std::vector<std::string> savedProjects;

        // Left section: Exit, Save, Load, basic controls
        if (ImGui::Button("Exit")) {
            g_FigmaMode = false;
        }
        ImGui::SameLine();

        // Save button with project name input
        static char projectNameBuf[128] = "Untitled";
        if (g_FigmaProject.name != projectNameBuf) {
            strncpy(projectNameBuf, g_FigmaProject.name.c_str(), sizeof(projectNameBuf));
        }
        ImGui::SetNextItemWidth(120);
        if (ImGui::InputText("##ProjName", projectNameBuf, sizeof(projectNameBuf))) {
            g_FigmaProject.name = projectNameBuf;
        }
        ImGui::SameLine();

        if (ImGui::Button("Save")) {
            std::string savePath = "/Users/imaging/Desktop/Website-Builder-v2.0/figma_projects/" + g_FigmaProject.name + ".json";
            system("mkdir -p /Users/imaging/Desktop/Website-Builder-v2.0/figma_projects");
            FILE* f = fopen(savePath.c_str(), "w");
            if (f) {
                fprintf(f, "{\n  \"project\": {\n");
                fprintf(f, "    \"name\": \"%s\",\n", g_FigmaProject.name.c_str());
                fprintf(f, "    \"canvas_width\": %.0f,\n", g_FigmaProject.canvas_width);
                fprintf(f, "    \"canvas_height\": %.0f,\n", g_FigmaProject.canvas_height);
                fprintf(f, "    \"screenshot_path\": \"%s\"\n", g_FigmaProject.screenshot_path.c_str());
                fprintf(f, "  },\n  \"layers\": [\n");
                for (size_t i = 0; i < g_FigmaProject.layers.size(); i++) {
                    auto& l = g_FigmaProject.layers[i];
                    const char* typeStr = "LAYER_DIV";
                    if (l.type == LAYER_TEXT) typeStr = "LAYER_TEXT";
                    else if (l.type == LAYER_IMAGE) typeStr = "LAYER_IMAGE";
                    else if (l.type == LAYER_BUTTON) typeStr = "LAYER_BUTTON";
                    fprintf(f, "    {\n");
                    fprintf(f, "      \"id\": %d,\n", l.id);
                    fprintf(f, "      \"type\": \"%s\",\n", typeStr);
                    fprintf(f, "      \"name\": \"%s\",\n", l.name.c_str());
                    fprintf(f, "      \"x\": %.0f,\n", l.x);
                    fprintf(f, "      \"y\": %.0f,\n", l.y);
                    fprintf(f, "      \"width\": %.0f,\n", l.width);
                    fprintf(f, "      \"height\": %.0f,\n", l.height);
                    fprintf(f, "      \"text\": \"%s\",\n", l.text.c_str());
                    fprintf(f, "      \"font_size\": %.0f,\n", l.font_size);
                    fprintf(f, "      \"opacity\": %.2f,\n", l.opacity);
                    fprintf(f, "      \"image_path\": \"%s\",\n", l.image_path.c_str());
                    // Save colors as rgb/rgba strings
                    fprintf(f, "      \"bg_color\": \"rgba(%.0f, %.0f, %.0f, %.2f)\",\n",
                        l.bg_color.x * 255, l.bg_color.y * 255, l.bg_color.z * 255, l.bg_color.w);
                    fprintf(f, "      \"text_color\": \"rgba(%.0f, %.0f, %.0f, %.2f)\",\n",
                        l.text_color.x * 255, l.text_color.y * 255, l.text_color.z * 255, l.text_color.w);
                    fprintf(f, "      \"border_color\": \"rgba(%.0f, %.0f, %.0f, %.2f)\",\n",
                        l.border_color.x * 255, l.border_color.y * 255, l.border_color.z * 255, l.border_color.w);
                    fprintf(f, "      \"border_width\": %.0f,\n", l.border_width);
                    fprintf(f, "      \"border_radius\": %.1f\n", l.border_radius);
                    fprintf(f, "    }%s\n", (i < g_FigmaProject.layers.size() - 1) ? "," : "");
                }
                fprintf(f, "  ]\n}\n");
                fclose(f);
                printf("[Figma] Saved project to: %s\n", savePath.c_str());

                // Also save as last project for auto-load
                FILE* lastProj = fopen("/Users/imaging/Desktop/Website-Builder-v2.0/figma_projects/.last_project", "w");
                if (lastProj) {
                    fprintf(lastProj, "%s", savePath.c_str());
                    fclose(lastProj);
                }
            }
        }
        ImGui::SameLine();

        // Load button
        if (ImGui::Button("Load")) {
            savedProjects = GetSavedFigmaProjects();
            ImGui::OpenPopup("Load Project Popup");
        }

        // Load popup - using modal to prevent accidental opening
        if (ImGui::BeginPopup("Load Project Popup")) {
            ImGui::Text("Saved Projects:");
            ImGui::Separator();
            for (const auto& proj : savedProjects) {
                // Extract just the filename
                size_t lastSlash = proj.rfind('/');
                std::string filename = (lastSlash != std::string::npos) ? proj.substr(lastSlash + 1) : proj;
                // Remove .json extension
                if (filename.size() > 5) filename = filename.substr(0, filename.size() - 5);

                if (ImGui::MenuItem(filename.c_str())) {
                    LoadFigmaProject(proj);
                    ImGui::CloseCurrentPopup();
                }
            }
            if (savedProjects.empty()) {
                ImGui::TextDisabled("No saved projects found");
            }
            ImGui::Separator();
            if (ImGui::MenuItem("Cancel")) {
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }

        ImGui::SameLine();

        // Save to Database button
        if (ImGui::Button("Save to DB")) {
            if (g_UseDatabase && g_DBConnection && !g_FigmaProject.name.empty()) {
                // Create permanent storage directory for this template
                std::string permanentDir = "/Users/imaging/Desktop/Website-Builder-v2.0/figma_templates/" + g_FigmaProject.name + "/";
                system(("mkdir -p \"" + permanentDir + "\"").c_str());
                system(("mkdir -p \"" + permanentDir + "images/\"").c_str());

                // Copy screenshot to permanent location
                std::string permanentScreenshotPath = permanentDir + "screenshot.png";
                if (!g_FigmaProject.screenshot_path.empty()) {
                    std::string copyCmd = "cp \"" + g_FigmaProject.screenshot_path + "\" \"" + permanentScreenshotPath + "\"";
                    system(copyCmd.c_str());
                    g_FigmaProject.screenshot_path = permanentScreenshotPath;
                }

                // Copy layer images to permanent locations
                for (size_t i = 0; i < g_FigmaProject.layers.size(); i++) {
                    WebLayer& layer = g_FigmaProject.layers[i];
                    if (!layer.image_path.empty() && layer.image_path.find("/tmp/") != std::string::npos) {
                        // Extract filename from original path
                        size_t lastSlash = layer.image_path.rfind('/');
                        std::string filename = (lastSlash != std::string::npos) ?
                            layer.image_path.substr(lastSlash + 1) : layer.image_path;
                        std::string permanentImagePath = permanentDir + "images/" + filename;
                        std::string copyCmd = "cp \"" + layer.image_path + "\" \"" + permanentImagePath + "\"";
                        system(copyCmd.c_str());
                        layer.image_path = permanentImagePath;
                    }
                }

                // Read screenshot as binary data
                std::vector<unsigned char> screenshotData;
                if (!g_FigmaProject.screenshot_path.empty()) {
                    screenshotData = ReadImageFile(g_FigmaProject.screenshot_path);
                }

                // First, ensure the is_figma_template column exists
                std::string alterQuery = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS is_figma_template BOOLEAN DEFAULT FALSE";
                PGresult* alterResult = PQexec(g_DBConnection, alterQuery.c_str());
                PQclear(alterResult);

                // Create template in database (without is_figma_template in INSERT to avoid issues)
                std::string query = "INSERT INTO templates (template_name, description, project_name) VALUES ('" +
                    SQLEscape(g_FigmaProject.name) + "', 'Figma-style imported template', '" +
                    SQLEscape(g_FigmaProject.name) + "') " +
                    "ON CONFLICT (template_name) DO UPDATE SET description='Figma-style imported template', " +
                    "project_name='" + SQLEscape(g_FigmaProject.name) + "', updated_date=NOW()";

                PGresult* result = PQexec(g_DBConnection, query.c_str());
                if (PQresultStatus(result) != PGRES_COMMAND_OK) {
                    printf("[Figma DB] Error creating template: %s\n", PQerrorMessage(g_DBConnection));
                    PQclear(result);
                } else {
                    PQclear(result);

                    // Get template ID
                    query = "SELECT id FROM templates WHERE template_name='" + SQLEscape(g_FigmaProject.name) + "'";
                    result = PQexec(g_DBConnection, query.c_str());
                    int template_id = 0;
                    if (PQresultStatus(result) == PGRES_TUPLES_OK && PQntuples(result) > 0) {
                        template_id = atoi(PQgetvalue(result, 0, 0));
                    }
                    PQclear(result);

                    if (template_id > 0) {
                        // Delete old figma_layers for this template
                        query = "DELETE FROM figma_layers WHERE template_id=" + std::to_string(template_id);
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Check if figma_layers table exists, create if not
                        query = "CREATE TABLE IF NOT EXISTS figma_layers ("
                                "id SERIAL PRIMARY KEY, "
                                "template_id INTEGER REFERENCES templates(id), "
                                "layer_order INTEGER, "
                                "layer_type INTEGER, "
                                "name VARCHAR(255), "
                                "x REAL, y REAL, width REAL, height REAL, "
                                "text TEXT, "
                                "font_size REAL, "
                                "opacity REAL, "
                                "image_path TEXT, "
                                "image_data BYTEA, "
                                "bg_color VARCHAR(64), "
                                "text_color VARCHAR(64), "
                                "href TEXT, "
                                "onclick_action TEXT, "
                                "action_type VARCHAR(32)"
                                ")";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Add action columns if they don't exist (for existing tables)
                        query = "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS href TEXT";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);
                        query = "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS onclick_action TEXT";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);
                        query = "ALTER TABLE figma_layers ADD COLUMN IF NOT EXISTS action_type VARCHAR(32)";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Add screenshot columns to templates if not exists
                        query = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_screenshot_path TEXT";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        query = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_screenshot_data BYTEA";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        query = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_canvas_width REAL";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        query = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS figma_canvas_height REAL";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        query = "ALTER TABLE templates ADD COLUMN IF NOT EXISTS is_figma_template BOOLEAN DEFAULT FALSE";
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Update template with screenshot and canvas info
                        std::ostringstream updateQuery;
                        updateQuery << "UPDATE templates SET "
                                    << "figma_screenshot_path='" << SQLEscape(g_FigmaProject.screenshot_path) << "', "
                                    << "figma_canvas_width=" << g_FigmaProject.canvas_width << ", "
                                    << "figma_canvas_height=" << g_FigmaProject.canvas_height << ", "
                                    << "is_figma_template=TRUE";
                        if (!screenshotData.empty()) {
                            updateQuery << ", figma_screenshot_data=" << BinaryToHex(screenshotData);
                        }
                        updateQuery << " WHERE id=" << template_id;
                        result = PQexec(g_DBConnection, updateQuery.str().c_str());
                        PQclear(result);

                        // Insert each layer
                        for (size_t i = 0; i < g_FigmaProject.layers.size(); i++) {
                            const auto& l = g_FigmaProject.layers[i];

                            // Read image data if exists
                            std::vector<unsigned char> imgData;
                            if (!l.image_path.empty()) {
                                imgData = ReadImageFile(l.image_path);
                            }

                            std::ostringstream layerQuery;
                            layerQuery << "INSERT INTO figma_layers ("
                                       << "template_id, layer_order, layer_type, name, x, y, width, height, "
                                       << "text, font_size, opacity, image_path, image_data, bg_color, text_color, "
                                       << "href, onclick_action, action_type"
                                       << ") VALUES ("
                                       << template_id << ", " << i << ", " << (int)l.type << ", "
                                       << "'" << SQLEscape(l.name) << "', "
                                       << l.x << ", " << l.y << ", " << l.width << ", " << l.height << ", "
                                       << "'" << SQLEscape(l.text) << "', "
                                       << l.font_size << ", " << l.opacity << ", "
                                       << "'" << SQLEscape(l.image_path) << "', "
                                       << (imgData.empty() ? "NULL" : BinaryToHex(imgData)) << ", "
                                       << "'" << ColorToSQL(l.bg_color) << "', "
                                       << "'" << ColorToSQL(l.text_color) << "', "
                                       << "'" << SQLEscape(l.href) << "', "
                                       << "'" << SQLEscape(l.onclick_action) << "', "
                                       << "'" << SQLEscape(l.action_type) << "'"
                                       << ")";

                            result = PQexec(g_DBConnection, layerQuery.str().c_str());
                            if (PQresultStatus(result) != PGRES_COMMAND_OK) {
                                printf("[Figma DB] Error inserting layer %zu: %s\n", i, PQerrorMessage(g_DBConnection));
                            }
                            PQclear(result);
                        }

                        printf("[Figma DB] Saved template '%s' with %zu layers to database!\n",
                               g_FigmaProject.name.c_str(), g_FigmaProject.layers.size());
                    }
                }
            } else {
                printf("[Figma DB] Database not connected or project name empty\n");
            }
        }

        ImGui::SameLine();
        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // ==================== TOOLS TOOLBAR ====================
        // Tool buttons with visual selection state
        auto ToolButton = [](const char* label, ToolType tool, const char* tooltip) {
            bool isActive = (g_CurrentTool == tool);
            if (isActive) {
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.5f, 0.8f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));
            }
            if (ImGui::Button(label, ImVec2(26, 26))) {
                g_CurrentTool = tool;
            }
            if (isActive) {
                ImGui::PopStyleColor(2);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("%s", tooltip);
            }
            ImGui::SameLine();
        };

        // Basic Tools
        ToolButton("V", TOOL_SELECT, "Select Tool (V) - Select and move elements");
        ToolButton("R", TOOL_RECTANGLE, "Rectangle (R) - Draw rectangle/container");
        ToolButton("F", TOOL_FRAME, "Frame (F) - Create frame/container");

        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Typography Tools
        ToolButton("H", TOOL_HEADING, "Heading (H) - Large title text");
        ToolButton("T", TOOL_TEXT, "Text (T) - Body text");
        ToolButton("P", TOOL_PARAGRAPH, "Paragraph (P) - Paragraph text block");

        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Media & Interactive
        ToolButton("I", TOOL_IMAGE, "Image (I) - Add image placeholder");
        ToolButton("B", TOOL_BUTTON, "Button (B) - Add button element");

        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Branding & Form
        if (ImGui::Button("Logo", ImVec2(36, 26))) {
            g_CurrentTool = TOOL_LOGO;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Logo - Add logo placeholder");
        ImGui::SameLine();

        ToolButton("[]", TOOL_INPUT, "Input (U) - Add form input field");

        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Website Sections dropdown
        if (ImGui::Button("Sections", ImVec2(65, 26))) {
            ImGui::OpenPopup("SectionsPopup");
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("All website sections (same as Normal mode)");
        }
        if (ImGui::BeginPopup("SectionsPopup")) {
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Header & Navigation");
            ImGui::Separator();
            if (ImGui::MenuItem("Hero Section", "")) g_CurrentTool = TOOL_SEC_HERO;
            if (ImGui::MenuItem("Navbar", "")) g_CurrentTool = TOOL_SEC_NAVBAR;
            if (ImGui::MenuItem("CTA (Call to Action)", "")) g_CurrentTool = TOOL_SEC_CTA;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Content Sections");
            ImGui::Separator();
            if (ImGui::MenuItem("About", "")) g_CurrentTool = TOOL_SEC_ABOUT;
            if (ImGui::MenuItem("Services", "")) g_CurrentTool = TOOL_SEC_SERVICES;
            if (ImGui::MenuItem("Features", "")) g_CurrentTool = TOOL_SEC_FEATURES;
            if (ImGui::MenuItem("Cards", "")) g_CurrentTool = TOOL_SEC_CARDS;
            if (ImGui::MenuItem("Team", "")) g_CurrentTool = TOOL_SEC_TEAM;
            if (ImGui::MenuItem("Testimonials", "")) g_CurrentTool = TOOL_SEC_TESTIMONIALS;
            if (ImGui::MenuItem("Stats", "")) g_CurrentTool = TOOL_SEC_STATS;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Media & Blog");
            ImGui::Separator();
            if (ImGui::MenuItem("Gallery", "")) g_CurrentTool = TOOL_SEC_GALLERY;
            if (ImGui::MenuItem("Blog", "")) g_CurrentTool = TOOL_SEC_BLOG;
            if (ImGui::MenuItem("Image (Full Width)", "")) g_CurrentTool = TOOL_SEC_IMAGE;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Forms & Contact");
            ImGui::Separator();
            if (ImGui::MenuItem("Contact", "")) g_CurrentTool = TOOL_SEC_CONTACT;
            if (ImGui::MenuItem("Login", "")) g_CurrentTool = TOOL_SEC_LOGIN;
            if (ImGui::MenuItem("FAQ", "")) g_CurrentTool = TOOL_SEC_FAQ;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Pricing & Footer");
            ImGui::Separator();
            if (ImGui::MenuItem("Pricing", "")) g_CurrentTool = TOOL_SEC_PRICING;
            if (ImGui::MenuItem("Footer", "")) g_CurrentTool = TOOL_SEC_FOOTER;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "Other");
            ImGui::Separator();
            if (ImGui::MenuItem("Text Box", "")) g_CurrentTool = TOOL_SEC_TEXTBOX;
            if (ImGui::MenuItem("Custom Section", "")) g_CurrentTool = TOOL_SEC_CUSTOM;

            ImGui::EndPopup();
        }
        ImGui::SameLine();

        // Show current tool name
        ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1.0f), "[%s]", GetToolName(g_CurrentTool));
        ImGui::SameLine();

        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Undo/Redo buttons
        if (ImGui::Button("Undo", ImVec2(40, 26))) {
            Undo();
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Undo (Ctrl+Z) - %zu states", g_UndoStack.size());
        }
        ImGui::SameLine();
        if (ImGui::Button("Redo", ImVec2(40, 26))) {
            Redo();
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Redo (Ctrl+Shift+Z) - %zu states", g_RedoStack.size());
        }

        ImGui::SameLine();
        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // View toggles
        ImGui::Checkbox("Grid", &g_FigmaProject.show_grid);
        ImGui::SameLine();
        ImGui::Checkbox("Ref", &g_FigmaProject.show_reference);
        if (g_FigmaProject.show_reference) {
            ImGui::SameLine();
            ImGui::SetNextItemWidth(60);
            ImGui::SliderFloat("##RefOp", &g_FigmaProject.reference_opacity, 0.1f, 1.0f, "%.1f");
        }
        ImGui::SameLine();
        ImGui::Checkbox("Bounds", &g_FigmaProject.show_bounds);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Show outlines around all layers");
        }

        ImGui::SameLine();
        ImGui::Checkbox("Preview", &g_FigmaProject.preview_mode);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Preview mode - clicking buttons executes their actions (opens URLs, etc.)");
        }
        if (g_FigmaProject.preview_mode) {
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.3f, 1.0f), "LIVE");
        }

        // Page selector (if multi-page)
        if (g_FigmaProject.pages.size() > 1) {
            ImGui::SameLine();
            ImGui::TextDisabled("|");
            ImGui::SameLine();
            ImGui::Text("Page:");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(150);
            if (ImGui::BeginCombo("##PageSelector", g_FigmaProject.current_page.c_str())) {
                for (const auto& path : g_FigmaProject.page_order) {
                    bool isSelected = (g_FigmaProject.current_page == path);
                    std::string label = path;
                    if (g_FigmaProject.pages.find(path) != g_FigmaProject.pages.end()) {
                        const WebPage& pg = g_FigmaProject.pages.at(path);
                        if (!pg.title.empty()) {
                            label = pg.title + " (" + path + ")";
                        }
                    }
                    if (ImGui::Selectable(label.c_str(), isSelected)) {
                        NavigateToPage(path);
                    }
                    if (isSelected) {
                        ImGui::SetItemDefaultFocus();
                    }
                }
                ImGui::EndCombo();
            }
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "(%zu pages)", g_FigmaProject.pages.size());
        }

        ImGui::SameLine();
        ImGui::TextDisabled("|");
        ImGui::SameLine();

        // Zoom controls (right side)
        ImGui::Text("Zoom:");
        ImGui::SameLine();
        if (ImGui::Button("-##ZoomOut")) {
            g_FigmaProject.zoom = std::max(0.1f, g_FigmaProject.zoom - 0.1f);
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(100);
        float zoomPercent = g_FigmaProject.zoom * 100.0f;
        if (ImGui::SliderFloat("##ZoomSlider", &zoomPercent, 10.0f, 300.0f, "%.0f%%")) {
            g_FigmaProject.zoom = zoomPercent / 100.0f;
        }
        ImGui::SameLine();
        if (ImGui::Button("+##ZoomIn")) {
            g_FigmaProject.zoom = std::min(3.0f, g_FigmaProject.zoom + 0.1f);
        }
        ImGui::SameLine();
        if (ImGui::Button("100%")) {
            g_FigmaProject.zoom = 1.0f;
        }
        ImGui::SameLine();
        if (ImGui::Button("Fit")) {
            g_FigmaProject.zoom = (figma_cw - 100) / g_FigmaProject.canvas_width;
        }

        ImGui::SameLine();
        ImGui::TextDisabled("|");
        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.7f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.6f, 0.8f, 1.0f));
        if (ImGui::Button("Browser")) {
            PreviewFigmaAsHTML();
        }
        ImGui::PopStyleColor(2);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Open preview in Chrome browser");
        }

        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.7f, 0.3f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.8f, 0.4f, 1.0f));
        if (ImGui::Button("Export ImGui")) {
            ExportFigmaToImGui();
        }
        ImGui::PopStyleColor(2);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Export as standalone ImGui C++ application");
        }

        ImGui::EndChild();
        ImGui::PopStyleVar();
        ImGui::PopStyleColor();

        // ==================== CANVAS (below toolbar) ====================
        ImGui::SetCursorPos(ImVec2(0, toolbarHeight));
        ImGui::BeginChild("##FigmaCanvasArea", ImVec2(figma_cw, figma_ch - toolbarHeight), false, ImGuiWindowFlags_NoScrollbar);

        // Render the actual Figma canvas
        RenderFigmaCanvas();

        ImGui::EndChild();

        ImGui::End();  // End FigmaCanvas

        // ==================== FIGMA RIGHT PANEL (PROPERTIES) ====================
        ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x - figma_rpw, 60));
        ImGui::SetNextWindowSize(ImVec2(figma_rpw, figma_ch));
        ImGui::Begin("##FigmaRightPanel", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);

        ImGui::TextColored(ImVec4(0.4f, 0.7f, 1.0f, 1), "PROPERTIES");
        ImGui::Separator();

        WebLayer* selectedLayer = GetLayerById(g_SelectedLayerId);
        if (!selectedLayer) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.3f, 0.7f, 0.5f, 1), "PAGE SETTINGS");
            ImGui::Separator();

            // Page Background Color
            ImGui::Text("Page Background:");
            ImGui::ColorEdit4("##PageBgColor", (float*)&g_FigmaProject.canvas_bg_color, ImGuiColorEditFlags_NoInputs);

            // Quick color presets
            ImGui::Text("Presets:");
            if (ImGui::Button("White##PageBg")) g_FigmaProject.canvas_bg_color = ImVec4(1, 1, 1, 1);
            ImGui::SameLine();
            if (ImGui::Button("Light##PageBg")) g_FigmaProject.canvas_bg_color = ImVec4(0.96f, 0.96f, 0.96f, 1);
            ImGui::SameLine();
            if (ImGui::Button("Dark##PageBg")) g_FigmaProject.canvas_bg_color = ImVec4(0.12f, 0.12f, 0.15f, 1);
            if (ImGui::Button("Blue##PageBg")) g_FigmaProject.canvas_bg_color = ImVec4(0.1f, 0.15f, 0.25f, 1);
            ImGui::SameLine();
            if (ImGui::Button("Cream##PageBg")) g_FigmaProject.canvas_bg_color = ImVec4(1.0f, 0.98f, 0.94f, 1);

            ImGui::Spacing();
            ImGui::Separator();

            // Page Size
            ImGui::Text("Page Size:");
            ImGui::SetNextItemWidth(120);
            ImGui::DragFloat("Width##Page", &g_FigmaProject.canvas_width, 10.0f, 320.0f, 3840.0f, "%.0fpx");
            ImGui::SetNextItemWidth(120);
            ImGui::DragFloat("Height##Page", &g_FigmaProject.canvas_height, 10.0f, 480.0f, 10000.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Select a layer to edit");
            ImGui::TextColored(ImVec4(0.4f, 0.4f, 0.4f, 1), "its properties");
        } else {
            // Layer Name
            ImGui::Text("Name:");
            char nameBuffer[256];
            strncpy(nameBuffer, selectedLayer->name.c_str(), sizeof(nameBuffer));
            ImGui::SetNextItemWidth(-1);
            if (ImGui::InputText("##LayerName", nameBuffer, sizeof(nameBuffer))) {
                selectedLayer->name = nameBuffer;
            }

            ImGui::Spacing();

            // Transform section
            if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen)) {
                ImGui::Text("Position:");
                ImGui::SetNextItemWidth(130);
                ImGui::DragFloat("X##pos", &selectedLayer->x, 1.0f);
                ImGui::SameLine();
                ImGui::SetNextItemWidth(130);
                ImGui::DragFloat("Y##pos", &selectedLayer->y, 1.0f);

                ImGui::Text("Size:");
                ImGui::SetNextItemWidth(130);
                ImGui::DragFloat("W##size", &selectedLayer->width, 1.0f, 1.0f, 10000.0f);
                ImGui::SameLine();
                ImGui::SetNextItemWidth(130);
                ImGui::DragFloat("H##size", &selectedLayer->height, 1.0f, 1.0f, 10000.0f);

                ImGui::Spacing();

                // Alignment tools
                ImGui::Text("Align:");
                if (ImGui::Button("L##AlignL", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_LEFT);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Left");
                ImGui::SameLine();
                if (ImGui::Button("C##AlignCH", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_CENTER_H);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Center Horizontal");
                ImGui::SameLine();
                if (ImGui::Button("R##AlignR", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_RIGHT);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Right");
                ImGui::SameLine();
                ImGui::TextDisabled("|");
                ImGui::SameLine();
                if (ImGui::Button("T##AlignT", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_TOP);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Top");
                ImGui::SameLine();
                if (ImGui::Button("M##AlignCV", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_CENTER_V);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Center Vertical");
                ImGui::SameLine();
                if (ImGui::Button("B##AlignB", ImVec2(30, 22))) AlignSelectedLayers(ALIGN_BOTTOM);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Align Bottom");

                ImGui::Spacing();

                // Z-Order controls
                ImGui::Text("Order (Z):");
                if (ImGui::Button("Front", ImVec2(55, 22))) BringToFront(g_SelectedLayerId);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Bring to Front");
                ImGui::SameLine();
                if (ImGui::Button("Back", ImVec2(55, 22))) SendToBack(g_SelectedLayerId);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Send to Back");
                ImGui::SameLine();
                if (ImGui::Button("+1##zup", ImVec2(30, 22))) MoveLayerUp(g_SelectedLayerId);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move Up");
                ImGui::SameLine();
                if (ImGui::Button("-1##zdn", ImVec2(30, 22))) MoveLayerDown(g_SelectedLayerId);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move Down");
            }

            // Appearance section
            if (ImGui::CollapsingHeader("Appearance", ImGuiTreeNodeFlags_DefaultOpen)) {
                // Note about overlay mode
                if (g_FigmaProject.show_reference && g_FigmaProject.reference_opacity > 0.5f) {
                    ImGui::TextColored(ImVec4(1.0f, 0.7f, 0.0f, 1.0f), "Note: Ref mode hides BG colors");
                }

                ImGui::Text("BG Color:");
                ImGui::SetNextItemWidth(-1);
                ImGui::ColorEdit4("##BGColor", (float*)&selectedLayer->bg_color,
                    ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_DisplayRGB);

                ImGui::Text("Text Color:");
                ImGui::SetNextItemWidth(-1);
                ImGui::ColorEdit4("##TextColor", (float*)&selectedLayer->text_color,
                    ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_DisplayRGB);

                ImGui::Text("Opacity:");
                ImGui::SetNextItemWidth(-1);
                ImGui::SliderFloat("##Opacity", &selectedLayer->opacity, 0.0f, 1.0f, "%.2f");

                ImGui::Text("Border Radius:");
                ImGui::SetNextItemWidth(-1);
                ImGui::DragFloat("##BorderRadius", &selectedLayer->border_radius, 1.0f, 0.0f, 100.0f);
            }

            // Typography section - show for ALL layers (so user can edit/add text to any layer)
            if (ImGui::CollapsingHeader("Typography", ImGuiTreeNodeFlags_DefaultOpen)) {
                ImGui::Text("Text Content:");
                char textBuffer[4096];
                strncpy(textBuffer, selectedLayer->text.c_str(), sizeof(textBuffer));
                textBuffer[sizeof(textBuffer) - 1] = '\0';
                if (ImGui::InputTextMultiline("##TextContent", textBuffer, sizeof(textBuffer), ImVec2(-1, 100))) {
                    selectedLayer->text = textBuffer;
                }

                ImGui::Spacing();

                ImGui::Text("Font Size:");
                ImGui::SetNextItemWidth(-1);
                ImGui::DragFloat("##FontSize", &selectedLayer->font_size, 1.0f, 8.0f, 200.0f);

                ImGui::Text("Font Weight:");
                ImGui::SetNextItemWidth(-1);
                ImGui::DragFloat("##FontWeight", &selectedLayer->font_weight, 10.0f, 100.0f, 900.0f);

                // Quick weight presets
                if (ImGui::Button("Light", ImVec2(55, 22))) selectedLayer->font_weight = 300;
                ImGui::SameLine();
                if (ImGui::Button("Normal", ImVec2(55, 22))) selectedLayer->font_weight = 400;
                ImGui::SameLine();
                if (ImGui::Button("Bold", ImVec2(55, 22))) selectedLayer->font_weight = 700;
                ImGui::SameLine();
                if (ImGui::Button("Black", ImVec2(55, 22))) selectedLayer->font_weight = 900;

                ImGui::Spacing();

                ImGui::Text("Text Align:");
                const char* alignItems[] = {"Left", "Center", "Right"};
                ImGui::SetNextItemWidth(-1);
                ImGui::Combo("##TextAlign", &selectedLayer->text_align, alignItems, 3);

                // Text decoration
                ImGui::Text("Text Style:");
                bool isUnderline = (selectedLayer->text_decoration == "underline");
                bool isStrikethrough = (selectedLayer->text_decoration == "line-through");
                if (ImGui::Checkbox("Underline", &isUnderline)) {
                    selectedLayer->text_decoration = isUnderline ? "underline" : "none";
                }
                ImGui::SameLine();
                if (ImGui::Checkbox("Strikethrough", &isStrikethrough)) {
                    selectedLayer->text_decoration = isStrikethrough ? "line-through" : "none";
                }
            }

            // Image section (for image layers and any layer that can have background image)
            if (selectedLayer->type == LAYER_IMAGE || selectedLayer->type == LAYER_DIV ||
                selectedLayer->type == LAYER_BUTTON) {
                if (ImGui::CollapsingHeader("Image / Media", ImGuiTreeNodeFlags_DefaultOpen)) {
                    // Show current image path
                    if (!selectedLayer->image_path.empty()) {
                        ImGui::TextWrapped("Current: %s", selectedLayer->image_path.c_str());

                        // Preview thumbnail if texture loaded
                        if (selectedLayer->texture_id) {
                            ImGui::Image((ImTextureID)(intptr_t)selectedLayer->texture_id,
                                ImVec2(100, 60), ImVec2(0,0), ImVec2(1,1));
                        }

                        // Remove image button
                        if (ImGui::Button("Remove Image", ImVec2(-1, 25))) {
                            selectedLayer->image_path = "";
                            if (selectedLayer->texture_id) {
                                glDeleteTextures(1, &selectedLayer->texture_id);
                                selectedLayer->texture_id = 0;
                            }
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.0f, 1), "No image loaded");
                    }

                    // Upload Image button
                    ImGui::Spacing();
                    if (ImGui::Button("Upload Image", ImVec2(-1, 30))) {
                        std::string path = OpenFileDialog("Select image (PNG, JPG, WebP)");
                        if (!path.empty()) {
                            // Load the image texture
                            int w, h, n;
                            unsigned char* data = stbi_load(path.c_str(), &w, &h, &n, 4);
                            if (data) {
                                // Delete old texture if exists
                                if (selectedLayer->texture_id) {
                                    glDeleteTextures(1, &selectedLayer->texture_id);
                                }
                                // Create new texture
                                glGenTextures(1, &selectedLayer->texture_id);
                                glBindTexture(GL_TEXTURE_2D, selectedLayer->texture_id);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                stbi_image_free(data);

                                selectedLayer->image_path = path;
                                // Change type to IMAGE if it was DIV
                                if (selectedLayer->type == LAYER_DIV) {
                                    selectedLayer->type = LAYER_IMAGE;
                                }
                                printf("[Upload] Loaded image: %s (%dx%d)\n", path.c_str(), w, h);
                            } else {
                                printf("[Upload] Failed to load: %s\n", path.c_str());
                            }
                        }
                    }

                    // Video upload (for hero/banner type layers)
                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::Text("Video (Hero/Banner):");

                    if (!selectedLayer->video_path.empty()) {
                        ImGui::TextWrapped("Video: %s", selectedLayer->video_path.c_str());
                        if (ImGui::Button("Remove Video", ImVec2(-1, 25))) {
                            selectedLayer->video_path = "";
                        }
                    }

                    if (ImGui::Button("Upload Video", ImVec2(-1, 30))) {
                        std::string path = OpenFileDialog("Select video (MP4, WebM)");
                        if (!path.empty()) {
                            selectedLayer->video_path = path;
                            printf("[Upload] Video set: %s\n", path.c_str());
                        }
                    }
                    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Note: Video plays in browser preview");

                    // Hero Animation (Multiple Images Slideshow)
                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::TextColored(ImVec4(0.5f, 0.8f, 0.5f, 1), "SLIDESHOW ANIMATION");

                    ImGui::Checkbox("Enable Slideshow", &selectedLayer->enable_animation);

                    if (selectedLayer->enable_animation) {
                        ImGui::Text("Speed (seconds per image):");
                        ImGui::SliderFloat("##AnimSpeed", &selectedLayer->animation_speed, 1.0f, 10.0f, "%.1fs");

                        ImGui::Text("Images (%d):", (int)selectedLayer->animation_images.size());

                        // Add image button
                        if (ImGui::Button("+ Add Slideshow Image", ImVec2(-1, 28))) {
                            std::string path = OpenFileDialog("Select slideshow image");
                            if (!path.empty()) {
                                // Load texture
                                int w, h, n;
                                unsigned char* data = stbi_load(path.c_str(), &w, &h, &n, 4);
                                if (data) {
                                    GLuint texId;
                                    glGenTextures(1, &texId);
                                    glBindTexture(GL_TEXTURE_2D, texId);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                    stbi_image_free(data);

                                    selectedLayer->animation_images.push_back(path);
                                    selectedLayer->animation_texture_ids.push_back(texId);
                                    printf("[Animation] Added image: %s\n", path.c_str());
                                }
                            }
                        }

                        // List current images with remove buttons
                        if (!selectedLayer->animation_images.empty()) {
                            ImGui::Spacing();
                            for (int i = 0; i < (int)selectedLayer->animation_images.size(); i++) {
                                ImGui::PushID(i);

                                // Show thumbnail
                                if (i < (int)selectedLayer->animation_texture_ids.size() &&
                                    selectedLayer->animation_texture_ids[i]) {
                                    ImGui::Image((ImTextureID)(intptr_t)selectedLayer->animation_texture_ids[i],
                                        ImVec2(40, 25));
                                    ImGui::SameLine();
                                }

                                // Filename
                                size_t lastSlash = selectedLayer->animation_images[i].rfind('/');
                                std::string filename = (lastSlash != std::string::npos) ?
                                    selectedLayer->animation_images[i].substr(lastSlash + 1) : selectedLayer->animation_images[i];
                                ImGui::Text("%d. %s", i + 1, filename.substr(0, 15).c_str());

                                ImGui::SameLine();
                                if (ImGui::SmallButton("X")) {
                                    // Delete texture
                                    if (i < (int)selectedLayer->animation_texture_ids.size()) {
                                        glDeleteTextures(1, &selectedLayer->animation_texture_ids[i]);
                                        selectedLayer->animation_texture_ids.erase(
                                            selectedLayer->animation_texture_ids.begin() + i);
                                    }
                                    selectedLayer->animation_images.erase(
                                        selectedLayer->animation_images.begin() + i);
                                    // Reset frame if needed
                                    if (selectedLayer->current_frame >= (int)selectedLayer->animation_images.size()) {
                                        selectedLayer->current_frame = 0;
                                    }
                                    ImGui::PopID();
                                    break;
                                }
                                ImGui::PopID();
                            }
                        }
                    }
                }
            }

            // Actions section (for buttons and links)
            if (ImGui::CollapsingHeader("Actions")) {
                // Action Type dropdown
                ImGui::Text("Action Type:");
                const char* actionTypes[] = {"none", "link", "scroll", "email", "phone", "popup", "submit", "button", "script"};
                int currentType = 0;
                for (int i = 0; i < 9; i++) {
                    if (selectedLayer->action_type == actionTypes[i]) {
                        currentType = i;
                        break;
                    }
                }
                ImGui::SetNextItemWidth(-1);
                if (ImGui::Combo("##ActionType", &currentType, actionTypes, 9)) {
                    selectedLayer->action_type = actionTypes[currentType];
                }

                // Href / URL
                ImGui::Text("Link URL:");
                char hrefBuffer[512];
                strncpy(hrefBuffer, selectedLayer->href.c_str(), sizeof(hrefBuffer));
                hrefBuffer[sizeof(hrefBuffer) - 1] = '\0';
                ImGui::SetNextItemWidth(-1);
                if (ImGui::InputText("##HrefInput", hrefBuffer, sizeof(hrefBuffer))) {
                    selectedLayer->href = hrefBuffer;
                    // Auto-detect action type from href
                    if (std::string(hrefBuffer).find("http") == 0) {
                        selectedLayer->action_type = "link";
                    } else if (hrefBuffer[0] == '#') {
                        selectedLayer->action_type = "scroll";
                    } else if (std::string(hrefBuffer).find("mailto:") == 0) {
                        selectedLayer->action_type = "email";
                    } else if (std::string(hrefBuffer).find("tel:") == 0) {
                        selectedLayer->action_type = "phone";
                    }
                }

                // Onclick action (read-only display)
                if (!selectedLayer->onclick_action.empty()) {
                    ImGui::Text("OnClick Script:");
                    ImGui::TextWrapped("%s", selectedLayer->onclick_action.c_str());
                }

                // Test button (only in preview mode)
                ImGui::Spacing();
                if ((!selectedLayer->href.empty() || !selectedLayer->onclick_action.empty()) &&
                    selectedLayer->action_type != "none") {
                    if (ImGui::Button("Test Action", ImVec2(-1, 26))) {
                        ExecuteLayerAction(*selectedLayer);
                    }
                    if (ImGui::IsItemHovered()) {
                        ImGui::SetTooltip("Execute this layer's action (opens URL, etc.)");
                    }
                }

                // Button states section
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                ImGui::Text("Button States:");

                // Disabled checkbox
                ImGui::Checkbox("Disabled", &selectedLayer->disabled);
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Disable this button (grayed out, not clickable)");
                }

                // Element ID (for scroll targets)
                ImGui::Text("Element ID:");
                char elementIdBuffer[128];
                strncpy(elementIdBuffer, selectedLayer->element_id.c_str(), sizeof(elementIdBuffer));
                elementIdBuffer[sizeof(elementIdBuffer) - 1] = '\0';
                ImGui::SetNextItemWidth(-1);
                if (ImGui::InputText("##ElementId", elementIdBuffer, sizeof(elementIdBuffer))) {
                    selectedLayer->element_id = elementIdBuffer;
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("ID used for scroll-to-anchor links (e.g., 'about' for #about)");
                }

                // Hover background color
                ImGui::Text("Hover BG Color:");
                ImGui::SetNextItemWidth(-1);
                ImGui::ColorEdit4("##HoverBg", (float*)&selectedLayer->hover_bg_color,
                    ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Background color when hovering (leave transparent for auto)");
                }

                // Hover scale
                ImGui::Text("Hover Scale:");
                ImGui::SetNextItemWidth(-1);
                ImGui::SliderFloat("##HoverScale", &selectedLayer->hover_scale, 1.0f, 1.2f, "%.2fx");
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Scale factor on hover (1.0 = no change)");
                }
            }

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Lock checkbox
            ImGui::Checkbox("Locked", &selectedLayer->locked);

            ImGui::Spacing();

            // Delete button
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1));
            if (ImGui::Button("Delete Layer", ImVec2(-1, 28))) {
                g_FigmaProject.layers.erase(
                    std::remove_if(g_FigmaProject.layers.begin(), g_FigmaProject.layers.end(),
                        [](const WebLayer& l) { return l.id == g_SelectedLayerId; }),
                    g_FigmaProject.layers.end());
                g_SelectedLayerId = -1;
            }
            ImGui::PopStyleColor();
        }

        ImGui::End();  // End FigmaRightPanel

        // Don't return - let popup dialogs render below
    } else {
        // ==================== NORMAL MODE: SECTION-BASED LAYOUT ====================
        float rpw = (g_SelectedSectionIndex >= 0) ? 300 : 0;
        float cw = io.DisplaySize.x - lpw - rpw, ch = io.DisplaySize.y - 60;
        ImGui::SetNextWindowPos(ImVec2(lpw, 60));
        ImGui::SetNextWindowSize(ImVec2(cw, ch));
        ImGui::Begin("##Canvas", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);
        // Normal section-based rendering
    ImVec2 cp = ImGui::GetCursorScreenPos();
    ImVec2 cs = ImGui::GetContentRegionAvail();
    ImDrawList* dl = ImGui::GetWindowDrawList();

    float ww = std::min(cs.x - 40, 1400.0f) * g_Zoom;  // Wider canvas (1400px max)
    float wx = cp.x + (cs.x - ww) / 2;
    dl->AddRectFilled(ImVec2(wx, cp.y), ImVec2(wx + ww, cp.y + cs.y), ImGui::ColorConvertFloat4ToU32(g_NormalCanvasBgColor));

    float yOff = -g_CanvasScrollY;
    ImVec2 mouse_pos = ImGui::GetMousePos();
    bool mouse_down = ImGui::IsMouseDown(0);
    bool mouse_released = ImGui::IsMouseReleased(0);

    // ==================== COPY-PASTE KEYBOARD SHORTCUTS ====================
    ImGuiIO& io = ImGui::GetIO();
    if (ImGui::IsWindowFocused() || ImGui::IsWindowHovered()) {
        // Ctrl+C - Copy selected section
        if (io.KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_C) && g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size()) {
            g_CopiedSection = g_Sections[g_SelectedSectionIndex];  // Deep copy
            g_HasCopiedSection = true;
        }

        // Ctrl+V - Paste copied section
        if (io.KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_V) && g_HasCopiedSection) {
            WebSection newSection = g_CopiedSection;  // Deep copy from clipboard
            newSection.id = g_NextSectionId++;  // Assign new ID

            // Offset position to avoid exact overlap
            newSection.x_position += 30;
            newSection.y_position += 30;
            newSection.z_index = (int)g_Sections.size();  // Put on top

            // Clear selection and select new section
            for (auto& s : g_Sections) s.selected = false;
            newSection.selected = true;

            g_Sections.push_back(newSection);
            g_SelectedSectionIndex = (int)g_Sections.size() - 1;
        }

        // Delete key - Delete selected section
        if ((ImGui::IsKeyPressed(ImGuiKey_Delete) || ImGui::IsKeyPressed(ImGuiKey_Backspace)) &&
            g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size() &&
            !ImGui::GetIO().WantTextInput) {  // Don't delete when typing in input fields
            g_Sections.erase(g_Sections.begin() + g_SelectedSectionIndex);
            g_SelectedSectionIndex = std::min(g_SelectedSectionIndex, (int)g_Sections.size() - 1);
            if (g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size()) {
                g_Sections[g_SelectedSectionIndex].selected = true;
            }
        }
    }

    // Static variables for resize
    static bool s_ResizingSection = false;
    static int s_ResizeSectionIndex = -1;
    static int s_ResizeHandle = -1;
    static float s_ResizeStartX = 0, s_ResizeStartY = 0;
    static float s_ResizeOrigX = 0, s_ResizeOrigY = 0;
    static float s_ResizeOrigW = 0, s_ResizeOrigH = 0;
    static float s_DragOffsetX = 0;

    // ==================== FREE DESIGN MODE ====================
    if (g_FreeDesignMode) {
        // Sort sections by z_index for proper layering
        std::vector<int> renderOrder(g_Sections.size());
        for (int i = 0; i < (int)g_Sections.size(); i++) renderOrder[i] = i;
        std::sort(renderOrder.begin(), renderOrder.end(), [](int a, int b) {
            return g_Sections[a].z_index < g_Sections[b].z_index;
        });

        // Render all sections in z-order
        for (int idx : renderOrder) {
            auto& sec = g_Sections[idx];

            // Calculate screen position
            float screenX = wx + (sec.x_position * g_Zoom) - g_CanvasScrollX;
            float screenY = cp.y + (sec.y_position * g_Zoom) - g_CanvasScrollY;
            float screenW = sec.width * g_Zoom;
            float screenH = sec.height * g_Zoom;

            // Skip if completely outside canvas
            if (screenX + screenW < wx || screenX > wx + ww ||
                screenY + screenH < cp.y || screenY > cp.y + cs.y) {
                continue;
            }

            // Render section preview at free position
            // RenderSectionPreview renders at: pos.x to pos.x+w, pos.y+yOff to pos.y+yOff+height
            float renderYOff = screenY - cp.y;  // Y offset from canvas top
            RenderSectionPreview(dl, sec, ImVec2(screenX, cp.y), sec.width, renderYOff);

            ImVec2 p1(screenX, screenY);
            ImVec2 p2(screenX + screenW, screenY + screenH);

            // Selection highlight (handles drawn later to be on top)
            if (sec.selected) {
                dl->AddRect(p1, p2, IM_COL32(0, 150, 255, 255), 0, 0, 2.0f);
            }

            // Check mouse hover for selection
            bool isHovered = mouse_pos.x >= p1.x && mouse_pos.x <= p2.x &&
                            mouse_pos.y >= p1.y && mouse_pos.y <= p2.y;

            if (isHovered && !sec.selected) {
                dl->AddRect(p1, p2, IM_COL32(100, 150, 255, 150), 0, 0, 1.0f);
            }

            // Click to select (but not if clicking on resize handle of already selected section)
            // Check if click is on a resize handle area
            bool clickOnResizeHandle = false;
            if (sec.selected) {
                float clickArea = 16;
                ImVec2 handles[8] = {
                    ImVec2(p1.x, p1.y), ImVec2(p1.x + screenW/2, p1.y), ImVec2(p2.x, p1.y),
                    ImVec2(p2.x, p1.y + screenH/2), ImVec2(p2.x, p2.y),
                    ImVec2(p1.x + screenW/2, p2.y), ImVec2(p1.x, p2.y), ImVec2(p1.x, p1.y + screenH/2)
                };
                for (int h = 0; h < 8; h++) {
                    if (mouse_pos.x >= handles[h].x - clickArea && mouse_pos.x <= handles[h].x + clickArea &&
                        mouse_pos.y >= handles[h].y - clickArea && mouse_pos.y <= handles[h].y + clickArea) {
                        clickOnResizeHandle = true;
                        break;
                    }
                }
            }

            if (isHovered && ImGui::IsMouseClicked(0) && !s_ResizingSection && !clickOnResizeHandle) {
                for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = false;
                sec.selected = true;
                g_SelectedSectionIndex = idx;

                // Start dragging (only if not clicking resize handle)
                g_DraggingSection = true;
                g_DraggedSectionIndex = idx;
                g_DragOffsetY = mouse_pos.y - screenY;
                s_DragOffsetX = mouse_pos.x - screenX;
            }
        }

        // Draw resize handles ON TOP of all sections (after all sections rendered)
        // This ensures handles are always visible and clickable
        static int s_HoveredResizeHandle = -1;
        s_HoveredResizeHandle = -1;

        if (g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size()) {
            auto& selectedSec = g_Sections[g_SelectedSectionIndex];

            // Calculate screen position for selected section
            float selScreenX = wx + (selectedSec.x_position * g_Zoom) - g_CanvasScrollX;
            float selScreenY = cp.y + (selectedSec.y_position * g_Zoom) - g_CanvasScrollY;
            float selScreenW = selectedSec.width * g_Zoom;
            float selScreenH = selectedSec.height * g_Zoom;

            ImVec2 sp1(selScreenX, selScreenY);
            ImVec2 sp2(selScreenX + selScreenW, selScreenY + selScreenH);

            // Draw 8 resize handles - LARGER size for easier clicking
            float hs = 12;  // Handle size (increased from 8)
            float clickArea = 16;  // Click detection area (larger than visual)

            ImVec2 handles[8] = {
                ImVec2(sp1.x, sp1.y),                    // 0: top-left
                ImVec2(sp1.x + selScreenW/2, sp1.y),     // 1: top-center
                ImVec2(sp2.x, sp1.y),                    // 2: top-right
                ImVec2(sp2.x, sp1.y + selScreenH/2),     // 3: right-center
                ImVec2(sp2.x, sp2.y),                    // 4: bottom-right
                ImVec2(sp1.x + selScreenW/2, sp2.y),     // 5: bottom-center
                ImVec2(sp1.x, sp2.y),                    // 6: bottom-left
                ImVec2(sp1.x, sp1.y + selScreenH/2)      // 7: left-center
            };

            // Check hover on resize handles FIRST
            for (int h = 0; h < 8; h++) {
                if (mouse_pos.x >= handles[h].x - clickArea && mouse_pos.x <= handles[h].x + clickArea &&
                    mouse_pos.y >= handles[h].y - clickArea && mouse_pos.y <= handles[h].y + clickArea) {
                    s_HoveredResizeHandle = h;
                    break;
                }
            }

            // Draw handles with hover highlighting
            for (int h = 0; h < 8; h++) {
                bool isHovered = (s_HoveredResizeHandle == h);
                ImU32 fillColor = isHovered ? IM_COL32(0, 200, 255, 255) : IM_COL32(255, 255, 255, 255);
                ImU32 borderColor = isHovered ? IM_COL32(0, 100, 200, 255) : IM_COL32(0, 150, 255, 255);
                float drawSize = isHovered ? hs + 2 : hs;

                dl->AddRectFilled(ImVec2(handles[h].x - drawSize/2, handles[h].y - drawSize/2),
                                 ImVec2(handles[h].x + drawSize/2, handles[h].y + drawSize/2), fillColor);
                dl->AddRect(ImVec2(handles[h].x - drawSize/2, handles[h].y - drawSize/2),
                           ImVec2(handles[h].x + drawSize/2, handles[h].y + drawSize/2), borderColor, 0, 0, 2.0f);
            }

            // Set cursor for resize handles
            if (s_HoveredResizeHandle >= 0) {
                switch (s_HoveredResizeHandle) {
                    case 0: case 4: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNWSE); break;
                    case 2: case 6: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNESW); break;
                    case 1: case 5: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS); break;
                    case 3: case 7: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW); break;
                }

                // Start resize when clicking on handle
                if (ImGui::IsMouseClicked(0) && !s_ResizingSection) {
                    s_ResizingSection = true;
                    s_ResizeSectionIndex = g_SelectedSectionIndex;
                    s_ResizeHandle = s_HoveredResizeHandle;
                    s_ResizeStartX = mouse_pos.x;
                    s_ResizeStartY = mouse_pos.y;
                    s_ResizeOrigX = selectedSec.x_position;
                    s_ResizeOrigY = selectedSec.y_position;
                    s_ResizeOrigW = selectedSec.width;
                    s_ResizeOrigH = selectedSec.height;

                    // Cancel any drag that might have started
                    g_DraggingSection = false;
                    g_DraggedSectionIndex = -1;
                }
            }
        }

        // Alignment guide lines (used by both resize and drag)
        static std::vector<std::pair<float, float>> s_AlignLinesV;  // Vertical lines
        static std::vector<std::pair<float, float>> s_AlignLinesH;  // Horizontal lines
        s_AlignLinesV.clear();
        s_AlignLinesH.clear();

        // Handle resize with alignment guides
        if (s_ResizingSection && s_ResizeSectionIndex >= 0) {
            auto& sec = g_Sections[s_ResizeSectionIndex];
            if (mouse_down) {
                float deltaX = (mouse_pos.x - s_ResizeStartX) / g_Zoom;
                float deltaY = (mouse_pos.y - s_ResizeStartY) / g_Zoom;

                float newX = s_ResizeOrigX, newY = s_ResizeOrigY;
                float newW = s_ResizeOrigW, newH = s_ResizeOrigH;

                switch (s_ResizeHandle) {
                    case 0: newX += deltaX; newY += deltaY; newW -= deltaX; newH -= deltaY; break;
                    case 1: newY += deltaY; newH -= deltaY; break;
                    case 2: newY += deltaY; newW += deltaX; newH -= deltaY; break;
                    case 3: newW += deltaX; break;
                    case 4: newW += deltaX; newH += deltaY; break;
                    case 5: newH += deltaY; break;
                    case 6: newX += deltaX; newW -= deltaX; newH += deltaY; break;
                    case 7: newX += deltaX; newW -= deltaX; break;
                }

                if (newW < 50) { newW = 50; }
                if (newH < 30) { newH = 30; }

                // Alignment snapping during resize
                float snapThreshold = 8.0f;
                float canvasWidth = ww / g_Zoom;

                // Calculate edges being resized
                float resizeRight = newX + newW;
                float resizeBottom = newY + newH;

                // Snap resize edges to other sections
                for (int i = 0; i < (int)g_Sections.size(); i++) {
                    if (i == s_ResizeSectionIndex) continue;
                    auto& other = g_Sections[i];

                    float otherLeft = other.x_position;
                    float otherRight = other.x_position + other.width;
                    float otherTop = other.y_position;
                    float otherBottom = other.y_position + other.height;

                    // Snap right edge (handles 2, 3, 4)
                    if (s_ResizeHandle == 2 || s_ResizeHandle == 3 || s_ResizeHandle == 4) {
                        if (std::abs(resizeRight - otherRight) < snapThreshold) {
                            newW = otherRight - newX;
                            s_AlignLinesV.push_back({otherRight, otherRight});
                        } else if (std::abs(resizeRight - otherLeft) < snapThreshold) {
                            newW = otherLeft - newX;
                            s_AlignLinesV.push_back({otherLeft, otherLeft});
                        }
                    }

                    // Snap left edge (handles 0, 6, 7)
                    if (s_ResizeHandle == 0 || s_ResizeHandle == 6 || s_ResizeHandle == 7) {
                        if (std::abs(newX - otherLeft) < snapThreshold) {
                            float oldRight = newX + newW;
                            newX = otherLeft;
                            newW = oldRight - newX;
                            s_AlignLinesV.push_back({otherLeft, otherLeft});
                        } else if (std::abs(newX - otherRight) < snapThreshold) {
                            float oldRight = newX + newW;
                            newX = otherRight;
                            newW = oldRight - newX;
                            s_AlignLinesV.push_back({otherRight, otherRight});
                        }
                    }

                    // Snap bottom edge (handles 4, 5, 6)
                    if (s_ResizeHandle == 4 || s_ResizeHandle == 5 || s_ResizeHandle == 6) {
                        if (std::abs(resizeBottom - otherBottom) < snapThreshold) {
                            newH = otherBottom - newY;
                            s_AlignLinesH.push_back({otherBottom, otherBottom});
                        } else if (std::abs(resizeBottom - otherTop) < snapThreshold) {
                            newH = otherTop - newY;
                            s_AlignLinesH.push_back({otherTop, otherTop});
                        }
                    }

                    // Snap top edge (handles 0, 1, 2)
                    if (s_ResizeHandle == 0 || s_ResizeHandle == 1 || s_ResizeHandle == 2) {
                        if (std::abs(newY - otherTop) < snapThreshold) {
                            float oldBottom = newY + newH;
                            newY = otherTop;
                            newH = oldBottom - newY;
                            s_AlignLinesH.push_back({otherTop, otherTop});
                        } else if (std::abs(newY - otherBottom) < snapThreshold) {
                            float oldBottom = newY + newH;
                            newY = otherBottom;
                            newH = oldBottom - newY;
                            s_AlignLinesH.push_back({otherBottom, otherBottom});
                        }
                    }
                }

                // Re-check minimum sizes after snapping
                if (newW < 50) { newW = 50; }
                if (newH < 30) { newH = 30; }

                sec.x_position = newX;
                sec.y_position = newY;
                sec.width = newW;
                sec.height = newH;
            } else {
                s_ResizingSection = false;
                s_ResizeSectionIndex = -1;
            }
        }

        // Handle free dragging with alignment guides (like Figma)
        if (g_DraggingSection && g_DraggedSectionIndex >= 0 && !s_ResizingSection) {
            auto& sec = g_Sections[g_DraggedSectionIndex];
            if (mouse_down) {
                // Calculate new position based on mouse movement
                float newX = (mouse_pos.x - s_DragOffsetX - wx + g_CanvasScrollX) / g_Zoom;
                float newY = (mouse_pos.y - g_DragOffsetY - cp.y + g_CanvasScrollY) / g_Zoom;

                // Alignment snap threshold (in canvas coordinates)
                float snapThreshold = 8.0f;
                float canvasWidth = ww / g_Zoom;
                float canvasHeight = cs.y / g_Zoom;

                // Get dragged section bounds
                float dragLeft = newX;
                float dragRight = newX + sec.width;
                float dragTop = newY;
                float dragBottom = newY + sec.height;
                float dragCenterX = newX + sec.width / 2;
                float dragCenterY = newY + sec.height / 2;

                // Check alignment with canvas center
                float canvasCenterX = canvasWidth / 2;
                float canvasCenterY = canvasHeight / 2;

                // Snap to canvas center X
                if (std::abs(dragCenterX - canvasCenterX) < snapThreshold) {
                    newX = canvasCenterX - sec.width / 2;
                    s_AlignLinesV.push_back({canvasCenterX, canvasCenterX});
                }
                // Snap to canvas left edge
                if (std::abs(dragLeft) < snapThreshold) {
                    newX = 0;
                    s_AlignLinesV.push_back({0, 0});
                }
                // Snap to canvas center Y
                if (std::abs(dragCenterY - canvasCenterY) < snapThreshold) {
                    newY = canvasCenterY - sec.height / 2;
                    s_AlignLinesH.push_back({canvasCenterY, canvasCenterY});
                }
                // Snap to canvas top edge
                if (std::abs(dragTop) < snapThreshold) {
                    newY = 0;
                    s_AlignLinesH.push_back({0, 0});
                }

                // Check alignment with other sections
                for (int i = 0; i < (int)g_Sections.size(); i++) {
                    if (i == g_DraggedSectionIndex) continue;
                    auto& other = g_Sections[i];

                    float otherLeft = other.x_position;
                    float otherRight = other.x_position + other.width;
                    float otherTop = other.y_position;
                    float otherBottom = other.y_position + other.height;
                    float otherCenterX = other.x_position + other.width / 2;
                    float otherCenterY = other.y_position + other.height / 2;

                    // Update dragged bounds for current newX/newY
                    dragLeft = newX;
                    dragRight = newX + sec.width;
                    dragTop = newY;
                    dragBottom = newY + sec.height;
                    dragCenterX = newX + sec.width / 2;
                    dragCenterY = newY + sec.height / 2;

                    // Vertical alignment (X axis)
                    // Left edge to left edge
                    if (std::abs(dragLeft - otherLeft) < snapThreshold) {
                        newX = otherLeft;
                        s_AlignLinesV.push_back({otherLeft, otherLeft});
                    }
                    // Right edge to right edge
                    else if (std::abs(dragRight - otherRight) < snapThreshold) {
                        newX = otherRight - sec.width;
                        s_AlignLinesV.push_back({otherRight, otherRight});
                    }
                    // Left edge to right edge
                    else if (std::abs(dragLeft - otherRight) < snapThreshold) {
                        newX = otherRight;
                        s_AlignLinesV.push_back({otherRight, otherRight});
                    }
                    // Right edge to left edge
                    else if (std::abs(dragRight - otherLeft) < snapThreshold) {
                        newX = otherLeft - sec.width;
                        s_AlignLinesV.push_back({otherLeft, otherLeft});
                    }
                    // Center to center X
                    else if (std::abs(dragCenterX - otherCenterX) < snapThreshold) {
                        newX = otherCenterX - sec.width / 2;
                        s_AlignLinesV.push_back({otherCenterX, otherCenterX});
                    }

                    // Horizontal alignment (Y axis)
                    // Top edge to top edge
                    if (std::abs(dragTop - otherTop) < snapThreshold) {
                        newY = otherTop;
                        s_AlignLinesH.push_back({otherTop, otherTop});
                    }
                    // Bottom edge to bottom edge
                    else if (std::abs(dragBottom - otherBottom) < snapThreshold) {
                        newY = otherBottom - sec.height;
                        s_AlignLinesH.push_back({otherBottom, otherBottom});
                    }
                    // Top edge to bottom edge
                    else if (std::abs(dragTop - otherBottom) < snapThreshold) {
                        newY = otherBottom;
                        s_AlignLinesH.push_back({otherBottom, otherBottom});
                    }
                    // Bottom edge to top edge
                    else if (std::abs(dragBottom - otherTop) < snapThreshold) {
                        newY = otherTop - sec.height;
                        s_AlignLinesH.push_back({otherTop, otherTop});
                    }
                    // Center to center Y
                    else if (std::abs(dragCenterY - otherCenterY) < snapThreshold) {
                        newY = otherCenterY - sec.height / 2;
                        s_AlignLinesH.push_back({otherCenterY, otherCenterY});
                    }
                }

                // Clamp to reasonable bounds
                sec.x_position = std::max(-500.0f, newX);
                sec.y_position = std::max(-500.0f, newY);
            } else {
                g_DraggingSection = false;
                g_DraggedSectionIndex = -1;
            }
        }

        // Draw alignment guide lines
        if (!s_AlignLinesV.empty() || !s_AlignLinesH.empty()) {
            ImU32 guideColor = IM_COL32(255, 0, 128, 200);  // Magenta/pink like Figma

            // Draw vertical guide lines
            for (auto& line : s_AlignLinesV) {
                float screenLineX = wx + (line.first * g_Zoom) - g_CanvasScrollX;
                dl->AddLine(ImVec2(screenLineX, cp.y), ImVec2(screenLineX, cp.y + cs.y), guideColor, 1.0f);
            }

            // Draw horizontal guide lines
            for (auto& line : s_AlignLinesH) {
                float screenLineY = cp.y + (line.first * g_Zoom) - g_CanvasScrollY;
                dl->AddLine(ImVec2(wx, screenLineY), ImVec2(wx + ww, screenLineY), guideColor, 1.0f);
            }
        }

        // Show empty canvas message
        if (g_Sections.empty()) {
            const char* t = "Click a section to add (Free Design Mode)";
            ImVec2 ts = ImGui::CalcTextSize(t);
            dl->AddText(ImVec2(wx + ww/2 - ts.x/2, cp.y + cs.y/2), IM_COL32(128, 128, 128, 255), t);
        }
    }
    // ==================== STACKED MODE (Original) ====================
    else {

    // Calculate drop target index based on mouse position
    if (g_DraggingSection) {
        g_DropTargetIndex = -1;
        float checkY = -g_CanvasScrollY;
        for (int i = 0; i < (int)g_Sections.size(); i++) {
            float sectionMidY = cp.y + checkY + (g_Sections[i].height * g_Zoom) / 2;
            if (mouse_pos.y < sectionMidY) {
                g_DropTargetIndex = i;
                break;
            }
            checkY += g_Sections[i].height * g_Zoom;
        }
        if (g_DropTargetIndex == -1) {
            g_DropTargetIndex = (int)g_Sections.size();
        }
    }

    // Render sections
    for (int i = 0; i < (int)g_Sections.size(); i++) {
        auto& sec = g_Sections[i];

        // Auto-upgrade old cards to modern style (for Cards and Services sections)
        if ((sec.type == SEC_CARDS || sec.type == SEC_SERVICES || sec.type == SEC_FEATURES) && !sec.items.empty()) {
            for (auto& item : sec.items) {
                // If old card style (0) and no modern properties set, auto-upgrade
                if (item.card_style == 0 && item.icon_emoji.empty()) {
                    item.card_style = 1;  // Set to Service style
                    // Set default icon based on position
                    static const char* default_icons[] = {"‚ö°", "üåê", "üì±", "üíº", "üöÄ", "üéØ"};
                    static ImVec4 default_colors[] = {
                        ImVec4(0.96f, 0.32f, 0.53f, 1.0f),  // Pink
                        ImVec4(0.25f, 0.52f, 1.0f, 1.0f),   // Blue
                        ImVec4(0.20f, 0.73f, 0.42f, 1.0f),  // Green
                        ImVec4(0.96f, 0.55f, 0.23f, 1.0f),  // Orange
                        ImVec4(0.56f, 0.27f, 0.68f, 1.0f),  // Purple
                        ImVec4(0.20f, 0.80f, 0.80f, 1.0f)   // Cyan
                    };
                    int idx = (&item - &sec.items[0]) % 6;
                    item.icon_emoji = default_icons[idx];
                    item.icon_color = default_colors[idx];
                    // Set default bullet points
                    item.bullet_points = {"Feature 1", "Feature 2", "Feature 3"};
                    item.anim_direction = 2;  // Right to left
                    item.anim_progress = 0.0f;  // Start animation
                    item.anim_delay = idx * 0.15f;  // Stagger animation
                }
            }
        }

        // No animation during design time - cards are static in editor
        // Animation only happens in Preview/Export
        for (auto& item : sec.items) {
            item.anim_progress = 1.0f;  // Fully visible, no animation in editor
        }

        // Determine render Y position: manual or auto
        float renderY;
        if (sec.use_manual_position) {
            renderY = (sec.y_position * g_Zoom) - g_CanvasScrollY;
        } else {
            renderY = yOff;
        }

        // Skip rendering dragged section in original position
        if (g_DraggingSection && i == g_DraggedSectionIndex) {
            if (!sec.use_manual_position) {
                yOff += sec.height * g_Zoom;
            }
            continue;
        }

        // Show drop target indicator
        if (g_DraggingSection && i == g_DropTargetIndex) {
            float lineY = cp.y + renderY;
            dl->AddLine(ImVec2(wx, lineY), ImVec2(wx + ww, lineY),
                       IM_COL32(100, 200, 255, 255), 4.0f);
            dl->AddCircleFilled(ImVec2(wx, lineY), 6.0f, IM_COL32(100, 200, 255, 255));
            dl->AddCircleFilled(ImVec2(wx + ww, lineY), 6.0f, IM_COL32(100, 200, 255, 255));
        }

        RenderSectionPreview(dl, sec, ImVec2(wx, cp.y), ww, renderY);
        ImVec2 sm(wx, cp.y + renderY), sx(wx + ww, cp.y + renderY + sec.height * g_Zoom);

        // Selection highlight (resize handles drawn after all sections)
        if (sec.selected) {
            dl->AddRect(sm, sx, IM_COL32(0, 150, 255, 255), 0, 0, 2.0f);
        }

        // Mouse interaction for selection (only if not resizing)
        // Check if clicking on any of the 8 resize handles
        bool clickOnResizeHandle = false;
        if (sec.selected) {
            float clickArea = 14;
            float screenW = sx.x - sm.x;
            float screenH = sx.y - sm.y;
            ImVec2 handles[8] = {
                ImVec2(sm.x, sm.y),                    // 0: top-left
                ImVec2(sm.x + screenW/2, sm.y),       // 1: top-center
                ImVec2(sx.x, sm.y),                    // 2: top-right
                ImVec2(sx.x, sm.y + screenH/2),       // 3: right-center
                ImVec2(sx.x, sx.y),                    // 4: bottom-right
                ImVec2(sm.x + screenW/2, sx.y),       // 5: bottom-center
                ImVec2(sm.x, sx.y),                    // 6: bottom-left
                ImVec2(sm.x, sm.y + screenH/2)        // 7: left-center
            };
            for (int h = 0; h < 8; h++) {
                if (mouse_pos.x >= handles[h].x - clickArea && mouse_pos.x <= handles[h].x + clickArea &&
                    mouse_pos.y >= handles[h].y - clickArea && mouse_pos.y <= handles[h].y + clickArea) {
                    clickOnResizeHandle = true;
                    break;
                }
            }
        }

        if (!s_ResizingSection && !clickOnResizeHandle && ImGui::IsMouseHoveringRect(sm, sx)) {
            if (ImGui::IsMouseClicked(0)) {
                g_SelectedSectionIndex = i;
                for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == i);

                // Start dragging
                g_DraggingSection = true;
                g_DraggedSectionIndex = i;
                g_DragOffsetY = mouse_pos.y - (cp.y + renderY);
            }
        }

        // Only increment yOff for auto-positioned sections
        if (!sec.use_manual_position) {
            yOff += sec.height * g_Zoom;
        }
    }

    // Alignment guide lines for Normal Mode
    static std::vector<float> s_AlignLinesH;
    s_AlignLinesH.clear();

    // Draw resize handles ON TOP of all sections (after all sections rendered)
    // Figma-style 8 handles: 4 corners + 4 mid-points for full width/height control
    static int s_HoveredResizeHandle = -1;
    s_HoveredResizeHandle = -1;

    if (g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size() && !g_DraggingSection) {
        auto& selectedSec = g_Sections[g_SelectedSectionIndex];

        // Calculate screen position for selected section
        float selRenderY;
        float tempYOff = -g_CanvasScrollY;
        for (int si = 0; si < g_SelectedSectionIndex; si++) {
            if (!g_Sections[si].use_manual_position) {
                tempYOff += g_Sections[si].height * g_Zoom;
            }
        }
        if (selectedSec.use_manual_position) {
            selRenderY = (selectedSec.y_position * g_Zoom) - g_CanvasScrollY;
        } else {
            selRenderY = tempYOff;
        }

        // Use section's actual width and position for free design mode
        float selScreenX, selScreenW;
        if (g_FreeDesignMode || selectedSec.use_manual_position) {
            selScreenX = wx + (selectedSec.x_position * g_Zoom);
            selScreenW = selectedSec.width * g_Zoom;
        } else {
            selScreenX = wx;
            selScreenW = ww;
        }
        float selScreenY = cp.y + selRenderY;
        float selScreenH = selectedSec.height * g_Zoom;

        // Figma-style 8 resize handles
        float hs = 10;  // Handle size
        float clickArea = 14;  // Click detection area (larger than visual)

        ImVec2 handles[8] = {
            ImVec2(selScreenX, selScreenY),                          // 0: top-left
            ImVec2(selScreenX + selScreenW/2, selScreenY),           // 1: top-center
            ImVec2(selScreenX + selScreenW, selScreenY),             // 2: top-right
            ImVec2(selScreenX + selScreenW, selScreenY + selScreenH/2), // 3: right-center
            ImVec2(selScreenX + selScreenW, selScreenY + selScreenH),   // 4: bottom-right
            ImVec2(selScreenX + selScreenW/2, selScreenY + selScreenH), // 5: bottom-center
            ImVec2(selScreenX, selScreenY + selScreenH),             // 6: bottom-left
            ImVec2(selScreenX, selScreenY + selScreenH/2)            // 7: left-center
        };

        // Check hover on resize handles FIRST
        for (int h = 0; h < 8; h++) {
            if (mouse_pos.x >= handles[h].x - clickArea && mouse_pos.x <= handles[h].x + clickArea &&
                mouse_pos.y >= handles[h].y - clickArea && mouse_pos.y <= handles[h].y + clickArea) {
                s_HoveredResizeHandle = h;
                break;
            }
        }

        // Draw handles with hover highlighting (Figma-style white squares with blue border)
        for (int h = 0; h < 8; h++) {
            bool isHovered = (s_HoveredResizeHandle == h);
            ImU32 fillColor = isHovered ? IM_COL32(0, 200, 255, 255) : IM_COL32(255, 255, 255, 255);
            ImU32 borderColor = isHovered ? IM_COL32(0, 100, 200, 255) : IM_COL32(0, 150, 255, 255);
            float drawSize = isHovered ? hs + 2 : hs;

            dl->AddRectFilled(ImVec2(handles[h].x - drawSize/2, handles[h].y - drawSize/2),
                             ImVec2(handles[h].x + drawSize/2, handles[h].y + drawSize/2), fillColor);
            dl->AddRect(ImVec2(handles[h].x - drawSize/2, handles[h].y - drawSize/2),
                       ImVec2(handles[h].x + drawSize/2, handles[h].y + drawSize/2), borderColor, 0, 0, 2.0f);
        }

        // Set cursor based on hovered handle
        if (s_HoveredResizeHandle >= 0) {
            switch (s_HoveredResizeHandle) {
                case 0: case 4: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNWSE); break; // TL, BR - diagonal
                case 2: case 6: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNESW); break; // TR, BL - diagonal
                case 1: case 5: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS); break;   // T, B - vertical
                case 3: case 7: ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW); break;   // R, L - horizontal
            }

            // Start resize when clicking on handle
            if (ImGui::IsMouseClicked(0) && !s_ResizingSection) {
                s_ResizingSection = true;
                s_ResizeSectionIndex = g_SelectedSectionIndex;
                s_ResizeHandle = s_HoveredResizeHandle;
                s_ResizeStartX = mouse_pos.x;
                s_ResizeStartY = mouse_pos.y;
                s_ResizeOrigX = selectedSec.x_position;
                s_ResizeOrigY = selectedSec.y_position;
                s_ResizeOrigW = selectedSec.width;
                s_ResizeOrigH = selectedSec.height;

                // Cancel any drag
                g_DraggingSection = false;
                g_DraggedSectionIndex = -1;
            }
        }

        // Show section size indicator
        char sizeText[64];
        snprintf(sizeText, sizeof(sizeText), "W: %.0fpx  H: %.0fpx", selectedSec.width, selectedSec.height);
        dl->AddText(ImVec2(selScreenX + 10, selScreenY + 5), IM_COL32(255, 255, 255, 200), sizeText);
    }

    // Handle resize with full 8-handle support (width and height)
    if (s_ResizingSection && s_ResizeSectionIndex >= 0 && s_ResizeSectionIndex < (int)g_Sections.size()) {
        auto& sec = g_Sections[s_ResizeSectionIndex];
        if (mouse_down) {
            float deltaX = (mouse_pos.x - s_ResizeStartX) / g_Zoom;
            float deltaY = (mouse_pos.y - s_ResizeStartY) / g_Zoom;

            float newX = s_ResizeOrigX;
            float newY = s_ResizeOrigY;
            float newW = s_ResizeOrigW;
            float newH = s_ResizeOrigH;

            // Apply resize based on handle (Figma-style)
            switch (s_ResizeHandle) {
                case 0: // Top-left corner
                    newX = s_ResizeOrigX + deltaX;
                    newY = s_ResizeOrigY + deltaY;
                    newW = s_ResizeOrigW - deltaX;
                    newH = s_ResizeOrigH - deltaY;
                    break;
                case 1: // Top-center (height only)
                    newY = s_ResizeOrigY + deltaY;
                    newH = s_ResizeOrigH - deltaY;
                    break;
                case 2: // Top-right corner
                    newY = s_ResizeOrigY + deltaY;
                    newW = s_ResizeOrigW + deltaX;
                    newH = s_ResizeOrigH - deltaY;
                    break;
                case 3: // Right-center (width only)
                    newW = s_ResizeOrigW + deltaX;
                    break;
                case 4: // Bottom-right corner
                    newW = s_ResizeOrigW + deltaX;
                    newH = s_ResizeOrigH + deltaY;
                    break;
                case 5: // Bottom-center (height only)
                    newH = s_ResizeOrigH + deltaY;
                    break;
                case 6: // Bottom-left corner
                    newX = s_ResizeOrigX + deltaX;
                    newW = s_ResizeOrigW - deltaX;
                    newH = s_ResizeOrigH + deltaY;
                    break;
                case 7: // Left-center (width only)
                    newX = s_ResizeOrigX + deltaX;
                    newW = s_ResizeOrigW - deltaX;
                    break;
            }

            // Enforce minimum sizes
            if (newW < 50) { newW = 50; }
            if (newH < 30) { newH = 30; }
            // Maximum width is canvas width
            float canvasWidth = ww / g_Zoom;
            if (newW > canvasWidth) { newW = canvasWidth; }
            if (newH > 2000) newH = 2000;

            // Snap to other section heights
            float snapThreshold = 8.0f;
            for (int si = 0; si < (int)g_Sections.size(); si++) {
                if (si == s_ResizeSectionIndex) continue;
                if (std::abs(newH - g_Sections[si].height) < snapThreshold) {
                    newH = g_Sections[si].height;
                    s_AlignLinesH.push_back(newH);
                }
                // Snap to other section widths
                if (std::abs(newW - g_Sections[si].width) < snapThreshold) {
                    newW = g_Sections[si].width;
                }
            }

            sec.x_position = newX;
            sec.y_position = newY;
            sec.width = newW;
            sec.height = newH;
        } else {
            s_ResizingSection = false;
            s_ResizeSectionIndex = -1;
        }
    }

    // Draw alignment indicator when heights match
    if (!s_AlignLinesH.empty()) {
        ImU32 guideColor = IM_COL32(255, 0, 128, 200);
        char heightText[32];
        snprintf(heightText, sizeof(heightText), "Matched: %.0fpx", s_AlignLinesH[0]);
        dl->AddText(ImVec2(wx + ww/2 - 40, cp.y + 10), guideColor, heightText);
    }

    // Show drop indicator at end
    if (g_DraggingSection && g_DropTargetIndex == (int)g_Sections.size()) {
        float lineY = cp.y + yOff;
        dl->AddLine(ImVec2(wx, lineY), ImVec2(wx + ww, lineY),
                   IM_COL32(100, 200, 255, 255), 4.0f);
        dl->AddCircleFilled(ImVec2(wx, lineY), 6.0f, IM_COL32(100, 200, 255, 255));
        dl->AddCircleFilled(ImVec2(wx + ww, lineY), 6.0f, IM_COL32(100, 200, 255, 255));
    }

    // Render dragged section at mouse position
    if (g_DraggingSection && g_DraggedSectionIndex >= 0 && g_DraggedSectionIndex < (int)g_Sections.size()) {
        auto& draggedSec = g_Sections[g_DraggedSectionIndex];
        float dragY = mouse_pos.y - cp.y - g_DragOffsetY;

        // Semi-transparent overlay
        dl->AddRectFilled(ImVec2(wx, mouse_pos.y - g_DragOffsetY),
                         ImVec2(wx + ww, mouse_pos.y - g_DragOffsetY + draggedSec.height * g_Zoom),
                         IM_COL32(100, 200, 255, 100));

        RenderSectionPreview(dl, draggedSec, ImVec2(wx, cp.y), ww, dragY);

        // Border around dragged section
        dl->AddRect(ImVec2(wx, mouse_pos.y - g_DragOffsetY),
                   ImVec2(wx + ww, mouse_pos.y - g_DragOffsetY + draggedSec.height * g_Zoom),
                   IM_COL32(100, 200, 255, 255), 0, 0, 3.0f);
    }

    // Handle drop
    if (g_DraggingSection && mouse_released) {
        if (g_DropTargetIndex >= 0 && g_DraggedSectionIndex >= 0) {
            // Reorder sections
            WebSection draggedSection = g_Sections[g_DraggedSectionIndex];
            g_Sections.erase(g_Sections.begin() + g_DraggedSectionIndex);

            int insertIndex = g_DropTargetIndex;
            if (g_DraggedSectionIndex < g_DropTargetIndex) {
                insertIndex--;
            }

            g_Sections.insert(g_Sections.begin() + insertIndex, draggedSection);
            g_SelectedSectionIndex = insertIndex;

            // Update selection
            for (int j = 0; j < (int)g_Sections.size(); j++) {
                g_Sections[j].selected = (j == insertIndex);
            }
        }

        // Reset drag state
        g_DraggingSection = false;
        g_DraggedSectionIndex = -1;
        g_DropTargetIndex = -1;
    }
    if (g_Sections.empty()) {
        const char* t = "Click a section to start";
        ImVec2 ts = ImGui::CalcTextSize(t);
        dl->AddText(ImVec2(wx + ww / 2 - ts.x / 2, cp.y + cs.y / 2), ImGui::ColorConvertFloat4ToU32(ImVec4(0.5f, 0.5f, 0.5f, 1)), t);
    }
    } // End of normal mode block

    // Handle scroll
    if (ImGui::IsWindowHovered()) {
        g_CanvasScrollY -= io.MouseWheel * 40;
        g_CanvasScrollY = std::max(0.0f, g_CanvasScrollY);
    }
    ImGui::End();

    // RIGHT PANEL - PROPERTIES (Same as Website Builder V1)
    if (g_SelectedSectionIndex >= 0 && g_SelectedSectionIndex < (int)g_Sections.size()) {
        WebSection& sec = g_Sections[g_SelectedSectionIndex];
        ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x - rpw, 60));
        ImGui::SetNextWindowSize(ImVec2(rpw, io.DisplaySize.y - 60));
        ImGui::Begin("##Props", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);

        ImGui::TextColored(ImVec4(0.4f, 0.7f, 1.0f, 1), "PROPERTIES");
        ImGui::Separator();

        // IMAGE SECTION OR CONTACT - Image Upload
        if (sec.type == SEC_IMAGE || sec.type == SEC_CONTACT) {
            ImGui::Spacing();
            if (sec.type == SEC_IMAGE) {
                ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.9f, 1), "IMAGE PROPERTIES");
            } else {
                ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.9f, 1), "CONTACT IMAGE");
                ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "(Shows in split layout)");
            }
            ImGui::Separator();

            // Upload image button
            if (ImGui::Button("Upload Image", ImVec2(-1, 35))) {
                std::string path = OpenFileDialog("Select image file");
                if (!path.empty()) {
                    sec.section_image = path;
                    ImageTexture imgTex = LoadTexture(path);
                    sec.img_texture_id = imgTex.id;
                    // Auto-adjust height based on image aspect ratio (only for image sections)
                    if (imgTex.loaded && sec.type == SEC_IMAGE) {
                        float aspect = (float)imgTex.height / (float)imgTex.width;
                        sec.height = 400 * aspect;  // Base width of 400
                    }
                }
            }

            if (!sec.section_image.empty()) {
                ImGui::TextWrapped("Current: %s", sec.section_image.c_str());

                if (sec.type == SEC_IMAGE) {
                    ImGui::Spacing();
                    ImGui::Text("Image Height:");
                    ImGui::SetNextItemWidth(200);
                    ImGui::SliderFloat("##ImgH", &sec.height, 50.0f, 800.0f, "%.0fpx");
                }

                if (ImGui::Button("Remove Image", ImVec2(-1, 25))) {
                    sec.section_image = "";
                    sec.img_texture_id = 0;
                    if (sec.type == SEC_IMAGE) {
                        sec.height = 300;
                    }
                }
            } else {
                if (sec.type == SEC_CONTACT) {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.0f, 1), "No image uploaded (optional)");
                } else {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.0f, 1), "No image uploaded yet");
                }
            }

            // Width and Alignment Controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "WIDTH & POSITION");
            ImGui::Separator();

            ImGui::Text("Width:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##ImgWidth", &sec.section_width_percent, 30.0f, 100.0f, "%.0f%%");
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("30%% = narrow, 50%% = half screen, 100%% = full width");
            }

            ImGui::Text("Horizontal Align:");
            const char* h_align_items[] = {"Left", "Center", "Right"};
            ImGui::Combo("##ImgHAlign", &sec.horizontal_align, h_align_items, 3);
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Position: Left side, Center, or Right side");
            }

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "You can drag this image section up/down to position it anywhere on the page!");
        }
        // TEXT BOX SECTION - Special Properties
        else if (sec.type == SEC_TEXTBOX) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "TEXT BOX PROPERTIES");
            ImGui::Separator();

            // Text content inputs - larger buffers for multiline
            char tb[512], sb[512];
            static char contentBuf[32768];  // 32KB buffer for large text content
            strncpy(tb, sec.title.c_str(), sizeof(tb) - 1);
            tb[sizeof(tb) - 1] = '\0';
            strncpy(sb, sec.subtitle.c_str(), sizeof(sb) - 1);
            sb[sizeof(sb) - 1] = '\0';
            strncpy(contentBuf, sec.content.c_str(), sizeof(contentBuf) - 1);
            contentBuf[sizeof(contentBuf) - 1] = '\0';

            ImGui::Text("Title");
            if (ImGui::InputText("##T", tb, sizeof(tb))) sec.title = tb;

            ImGui::Text("Subtitle");
            if (ImGui::InputText("##S", sb, sizeof(sb))) sec.subtitle = sb;

            ImGui::Text("Content (Multiline - No Limit)");
            if (ImGui::InputTextMultiline("##C", contentBuf, sizeof(contentBuf), ImVec2(-1, 200), ImGuiInputTextFlags_AllowTabInput)) {
                sec.content = contentBuf;
            }

            // Size controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "SIZE");
            ImGui::Separator();

            ImGui::Text("Height:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##TBH", &sec.height, 100.0f, 800.0f, "%.0fpx");

            ImGui::Text("Padding:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##TBP", &sec.padding, 10.0f, 100.0f, "%.0fpx");

            // Margin controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "MARGIN");
            ImGui::Separator();
            ImGui::SliderFloat("Top##TBMargin", &sec.margin_top, 0.0f, 100.0f, "%.0fpx");
            ImGui::SliderFloat("Right##TBMargin", &sec.margin_right, 0.0f, 100.0f, "%.0fpx");
            ImGui::SliderFloat("Bottom##TBMargin", &sec.margin_bottom, 0.0f, 100.0f, "%.0fpx");
            ImGui::SliderFloat("Left##TBMargin", &sec.margin_left, 0.0f, 100.0f, "%.0fpx");

            // Text alignment
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "ALIGNMENT");
            ImGui::Separator();

            const char* align_items[] = {"Left", "Center", "Right"};
            ImGui::Combo("Text Align", &sec.text_align, align_items, 3);

            // Colors
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "COLORS");
            ImGui::Separator();

            ImGui::Text("Background:");
            ImGui::ColorEdit4("##TBBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Title Color:");
            ImGui::ColorEdit4("##TBTitleC", (float*)&sec.title_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Subtitle Color:");
            ImGui::ColorEdit4("##TBSubC", (float*)&sec.subtitle_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Content Color:");
            ImGui::ColorEdit4("##TBContC", (float*)&sec.content_color, ImGuiColorEditFlags_NoInputs);

            // Typography
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "TYPOGRAPHY");
            ImGui::Separator();

            ImGui::Text("Title Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TBTitleFS", &sec.title_font_size, 16.0f, 64.0f, "%.0fpx");

            ImGui::Text("Subtitle Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TBSubFS", &sec.subtitle_font_size, 12.0f, 32.0f, "%.0fpx");

            ImGui::Text("Content Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TBContFS", &sec.content_font_size, 10.0f, 24.0f, "%.0fpx");

            // Width and Alignment Controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "WIDTH & POSITION");
            ImGui::Separator();

            ImGui::Text("Width:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##TBWidth", &sec.section_width_percent, 30.0f, 100.0f, "%.0f%%");
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("30%% = narrow, 50%% = half screen, 100%% = full width");
            }

            ImGui::Text("Horizontal Align:");
            const char* h_align_items_tb[] = {"Left", "Center", "Right"};
            ImGui::Combo("##TBHAlign", &sec.horizontal_align, h_align_items_tb, 3);
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Position: Left side, Center, or Right side");
            }

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "You can drag this text box section up/down to position it anywhere!");
        }
        // ==================== BASIC ELEMENTS PROPERTIES ====================
        // Logo Element Properties
        else if (sec.type == SEC_LOGO) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.5f, 1), "LOGO PROPERTIES");
            ImGui::Separator();

            // Logo Image
            ImGui::Text("Logo Image:");
            if (sec.logo_texture_id > 0) {
                ImGui::Image((ImTextureID)(intptr_t)sec.logo_texture_id, ImVec2(80, 40));
                ImGui::SameLine();
                if (ImGui::Button("Remove##LogoImg")) {
                    glDeleteTextures(1, &sec.logo_texture_id);
                    sec.logo_texture_id = 0;
                    sec.logo_path.clear();
                }
            }

            if (ImGui::Button("Choose Logo Image...##LogoImg")) {
                // Use native file dialog
                char cmd[512];
                snprintf(cmd, sizeof(cmd),
                    "osascript -e 'POSIX path of (choose file of type {\"public.image\"} with prompt \"Select Logo Image\")' 2>/dev/null");
                FILE* fp = popen(cmd, "r");
                if (fp) {
                    char result[1024];
                    if (fgets(result, sizeof(result), fp)) {
                        // Remove trailing newline
                        result[strcspn(result, "\n")] = 0;
                        sec.logo_path = result;

                        // Load the image
                        int w, h, n;
                        unsigned char* imgData = stbi_load(sec.logo_path.c_str(), &w, &h, &n, 4);
                        if (imgData) {
                            if (sec.logo_texture_id > 0) {
                                glDeleteTextures(1, &sec.logo_texture_id);
                            }
                            glGenTextures(1, &sec.logo_texture_id);
                            glBindTexture(GL_TEXTURE_2D, sec.logo_texture_id);
                            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData);
                            stbi_image_free(imgData);
                            printf("[Logo] Loaded image: %s (%dx%d)\n", sec.logo_path.c_str(), w, h);
                        }
                    }
                    pclose(fp);
                }
            }

            if (!sec.logo_path.empty()) {
                ImGui::TextWrapped("Path: %s", sec.logo_path.c_str());
            }

            ImGui::Spacing();
            char logoBuf[128];
            strncpy(logoBuf, sec.title.c_str(), sizeof(logoBuf) - 1);
            logoBuf[sizeof(logoBuf) - 1] = '\0';
            ImGui::Text("Alt Text (Fallback)");
            if (ImGui::InputText("##LogoText", logoBuf, sizeof(logoBuf))) sec.title = logoBuf;

            ImGui::Spacing();
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##LogoBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Width##Logo", &sec.width, 1.0f, 50.0f, 500.0f, "%.0fpx");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Height##Logo", &sec.height, 1.0f, 30.0f, 200.0f, "%.0fpx");
        }
        // Heading Element Properties
        else if (sec.type == SEC_HEADING) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.5f, 1), "HEADING PROPERTIES");
            ImGui::Separator();

            char headingBuf[256];
            strncpy(headingBuf, sec.title.c_str(), sizeof(headingBuf) - 1);
            headingBuf[sizeof(headingBuf) - 1] = '\0';
            ImGui::Text("Heading Text");
            if (ImGui::InputText("##HeadingText", headingBuf, sizeof(headingBuf))) sec.title = headingBuf;

            ImGui::Spacing();
            ImGui::Text("Text Color:");
            ImGui::ColorEdit4("##HeadingC", (float*)&sec.title_color, ImGuiColorEditFlags_NoInputs);
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##HeadingBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##HeadingFS", &sec.title_font_size, 16.0f, 96.0f, "%.0fpx");
            ImGui::Text("Font Weight:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##HeadingFW", &sec.title_font_weight, 100.0f, 900.0f, "%.0f");

            ImGui::Spacing();
            ImGui::Text("Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Width##Heading", &sec.width, 1.0f, 100.0f, 1000.0f, "%.0fpx");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Height##Heading", &sec.height, 1.0f, 30.0f, 200.0f, "%.0fpx");
        }
        // Text Element Properties
        else if (sec.type == SEC_TEXT_ELEMENT) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.5f, 1), "TEXT PROPERTIES");
            ImGui::Separator();

            static char textElementBuf[32768];  // 32KB buffer for large text
            strncpy(textElementBuf, sec.content.c_str(), sizeof(textElementBuf) - 1);
            textElementBuf[sizeof(textElementBuf) - 1] = '\0';
            ImGui::Text("Text Content (Multiline)");
            if (ImGui::InputTextMultiline("##TextContent", textElementBuf, sizeof(textElementBuf), ImVec2(-1, 120), ImGuiInputTextFlags_AllowTabInput)) {
                sec.content = textElementBuf;
            }

            ImGui::Spacing();
            ImGui::Text("Text Color:");
            ImGui::ColorEdit4("##TextC", (float*)&sec.content_color, ImGuiColorEditFlags_NoInputs);
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##TextBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TextFS", &sec.content_font_size, 10.0f, 48.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::Text("Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Width##Text", &sec.width, 1.0f, 50.0f, 800.0f, "%.0fpx");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Height##Text", &sec.height, 1.0f, 20.0f, 300.0f, "%.0fpx");

            // Margin controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "MARGIN");
            ImGui::Separator();
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Top##TextMargin", &sec.margin_top, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Right##TextMargin", &sec.margin_right, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Bottom##TextMargin", &sec.margin_bottom, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Left##TextMargin", &sec.margin_left, 0.0f, 100.0f, "%.0fpx");
        }
        // Button Element Properties (with Action)
        else if (sec.type == SEC_BUTTON_ELEMENT) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.2f, 0.6f, 1.0f, 1), "BUTTON PROPERTIES");
            ImGui::Separator();

            char btnTextBuf[128];
            strncpy(btnTextBuf, sec.button_text.c_str(), sizeof(btnTextBuf) - 1);
            btnTextBuf[sizeof(btnTextBuf) - 1] = '\0';
            ImGui::Text("Button Text");
            if (ImGui::InputText("##BtnText", btnTextBuf, sizeof(btnTextBuf))) sec.button_text = btnTextBuf;

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.2f, 1), "ACTION (Click Behavior)");
            ImGui::Separator();

            char linkBuf[256];
            strncpy(linkBuf, sec.button_link.c_str(), sizeof(linkBuf) - 1);
            linkBuf[sizeof(linkBuf) - 1] = '\0';
            ImGui::Text("Link URL / Action");
            if (ImGui::InputText("##BtnLink", linkBuf, sizeof(linkBuf))) sec.button_link = linkBuf;
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Enter URL (https://...) or action:\n#section - scroll to section\npage.html - navigate to page");
            }

            // Action type dropdown
            static const char* actionTypes[] = {"Link (URL)", "Scroll to Section", "Open Popup", "Submit Form"};
            static int actionType = 0;
            ImGui::Combo("Action Type", &actionType, actionTypes, 4);

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "STYLE");
            ImGui::Separator();

            ImGui::Text("Background:");
            ImGui::ColorEdit4("##BtnBg", (float*)&sec.button_bg_color, ImGuiColorEditFlags_NoInputs);
            ImGui::Text("Text Color:");
            ImGui::ColorEdit4("##BtnTextC", (float*)&sec.button_text_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Font Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##BtnFS", &sec.button_font_size, 10.0f, 32.0f, "%.0fpx");

            ImGui::Text("Border Radius:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##BtnRadius", &sec.button_border_radius, 0.0f, 30.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::Text("Size:");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Width##Btn", &sec.width, 1.0f, 80.0f, 400.0f, "%.0fpx");
            ImGui::SetNextItemWidth(150);
            ImGui::DragFloat("Height##Btn", &sec.height, 1.0f, 30.0f, 100.0f, "%.0fpx");
        }
        // ==================== CONNECTOR PROPERTIES ====================

        // Text Block Connector Properties
        else if (sec.type == SEC_TEXT_CONNECTOR) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "TEXT BLOCK PROPERTIES");
            ImGui::Separator();

            // Background color
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##TextConnBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            // Content width and padding
            ImGui::Spacing();
            ImGui::Text("Content Width:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TCWidth", &sec.text_content_width, 300.0f, 1200.0f, "%.0fpx");

            ImGui::Text("Padding:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TCPad", &sec.text_padding, 10.0f, 100.0f, "%.0fpx");

            ImGui::Text("Height:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##TCH", &sec.height, 50.0f, 600.0f, "%.0fpx");

            // Margin controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "MARGIN");
            ImGui::Separator();
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Top##TCMargin", &sec.margin_top, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Right##TCMargin", &sec.margin_right, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Bottom##TCMargin", &sec.margin_bottom, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Left##TCMargin", &sec.margin_left, 0.0f, 100.0f, "%.0fpx");

            // Text blocks management
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "TEXT BLOCKS");
            ImGui::Separator();

            for (int b = 0; b < (int)sec.text_blocks.size(); b++) {
                ImGui::PushID(b);
                TextBlock& block = sec.text_blocks[b];

                ImGui::Text("Block %d", b + 1);

                // Font size
                ImGui::SetNextItemWidth(100);
                ImGui::SliderFloat("##FS", &block.fontSize, 10.0f, 48.0f, "%.0fpx");
                ImGui::SameLine();
                ImGui::Text("Size");

                // Line spacing
                ImGui::SetNextItemWidth(100);
                ImGui::SliderFloat("##LS", &block.lineSpacing, 1.0f, 3.0f, "%.1f");
                ImGui::SameLine();
                ImGui::Text("Line Spacing");

                // Colors
                ImGui::Text("Text Color:");
                ImGui::ColorEdit4("##TC", (float*)&block.textColor, ImGuiColorEditFlags_NoInputs);
                ImGui::SameLine();
                ImGui::Text("Bold Color:");
                ImGui::ColorEdit4("##BC", (float*)&block.boldColor, ImGuiColorEditFlags_NoInputs);

                // Segments
                for (int s = 0; s < (int)block.segments.size(); s++) {
                    ImGui::PushID(s);
                    TextSegment& seg = block.segments[s];
                    char segBuf[512];
                    strncpy(segBuf, seg.text.c_str(), sizeof(segBuf) - 1);
                    segBuf[sizeof(segBuf) - 1] = '\0';

                    ImGui::SetNextItemWidth(200);
                    if (ImGui::InputText("##Seg", segBuf, sizeof(segBuf))) seg.text = segBuf;
                    ImGui::SameLine();
                    ImGui::Checkbox("Bold##SB", &seg.isBold);
                    ImGui::SameLine();
                    if (ImGui::Button("X##DelSeg")) {
                        block.segments.erase(block.segments.begin() + s);
                        s--;
                    }
                    ImGui::PopID();
                }

                if (ImGui::Button("+ Add Segment")) {
                    TextSegment newSeg;
                    newSeg.text = "New text";
                    block.segments.push_back(newSeg);
                }

                ImGui::Separator();
                ImGui::PopID();
            }

            if (ImGui::Button("+ Add Text Block", ImVec2(-1, 26))) {
                TextBlock newBlock;
                TextSegment seg;
                seg.text = "New text block";
                newBlock.segments.push_back(seg);
                sec.text_blocks.push_back(newBlock);
            }
        }
        // Bar Heading Connector Properties
        else if (sec.type == SEC_BAR_CONNECTOR) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "BAR HEADING PROPERTIES");
            ImGui::Separator();

            ImGui::Text("Background:");
            ImGui::ColorEdit4("##BarSecBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Section Height:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##BarSecH", &sec.height, 30.0f, 200.0f, "%.0fpx");

            for (int i = 0; i < (int)sec.bar_items.size(); i++) {
                ImGui::PushID(i);
                BarItem& bar = sec.bar_items[i];

                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Bar %d", i + 1);

                ImGui::Text("Heading:");
                ImGui::SetNextItemWidth(200);
                ImGui::InputText("##BarHead", bar.heading, sizeof(bar.heading));

                ImGui::Text("Bar Color:");
                ImGui::ColorEdit4("##BarCol", (float*)&bar.barColor, ImGuiColorEditFlags_NoInputs);

                ImGui::Text("Text Color:");
                ImGui::ColorEdit4("##BarTextCol", (float*)&bar.headingColor, ImGuiColorEditFlags_NoInputs);

                ImGui::Text("Bar Width:");
                ImGui::SetNextItemWidth(150);
                ImGui::SliderFloat("##BarW", &bar.barWidth, 200.0f, 1200.0f, "%.0fpx");

                ImGui::Text("Bar Height:");
                ImGui::SetNextItemWidth(150);
                ImGui::SliderFloat("##BarH", &bar.barHeight, 30.0f, 100.0f, "%.0fpx");

                ImGui::Text("Text Size:");
                ImGui::SetNextItemWidth(100);
                ImGui::SliderFloat("##BarTS", &bar.headingSize, 0.8f, 2.5f, "%.1fx");

                ImGui::Text("Boldness:");
                ImGui::SetNextItemWidth(100);
                ImGui::SliderFloat("##BarBold", &bar.headingBoldness, 0.0f, 3.0f, "%.1f");

                ImGui::Text("Padding Left:");
                ImGui::SetNextItemWidth(100);
                ImGui::SliderFloat("##BarPL", &bar.paddingLeft, 10.0f, 100.0f, "%.0fpx");

                ImGui::SameLine(ImGui::GetContentRegionAvail().x - 25);
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1));
                if (ImGui::Button("X##DelBar", ImVec2(22, 18)) && sec.bar_items.size() > 1) {
                    sec.bar_items.erase(sec.bar_items.begin() + i);
                    i--;
                }
                ImGui::PopStyleColor();

                ImGui::Separator();
                ImGui::PopID();
            }

            if (ImGui::Button("+ Add Bar", ImVec2(-1, 26))) {
                sec.bar_items.push_back(BarItem());
            }
        }
        // Footer Columns Connector Properties
        else if (sec.type == SEC_FOOTER_CONNECTOR) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "FOOTER COLUMNS PROPERTIES");
            ImGui::Separator();

            ImGui::Text("Background:");
            ImGui::ColorEdit4("##FootBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Section Height:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##FootH", &sec.height, 100.0f, 500.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "HEADING STYLE");
            ImGui::Separator();

            ImGui::Text("Heading Color:");
            ImGui::ColorEdit4("##FootHeadC", (float*)&sec.footer_heading_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Heading Size:");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("##FootHS", &sec.footer_heading_size, 0.8f, 2.0f, "%.1fx");

            ImGui::Text("Heading Boldness:");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("##FootHB", &sec.footer_heading_boldness, 0.0f, 3.0f, "%.1f");

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "SUBHEADING STYLE");
            ImGui::Separator();

            ImGui::Text("Subheading Color:");
            ImGui::ColorEdit4("##FootSubC", (float*)&sec.footer_subheading_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Subheading Size:");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("##FootSS", &sec.footer_subheading_size, 0.8f, 1.5f, "%.1fx");

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "LAYOUT");
            ImGui::Separator();

            ImGui::Text("Column Width:");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##FootCW", &sec.footer_column_width, 150.0f, 400.0f, "%.0fpx");

            ImGui::Text("Item Spacing:");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("##FootIS", &sec.footer_item_spacing, 4.0f, 20.0f, "%.0fpx");

            // Columns
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "COLUMNS");
            ImGui::Separator();

            for (int c = 0; c < (int)sec.footer_columns.size(); c++) {
                ImGui::PushID(c);
                FooterColumn& col = sec.footer_columns[c];

                ImGui::Text("Column %d:", c + 1);
                ImGui::SetNextItemWidth(200);
                ImGui::InputText("##ColHead", col.heading, sizeof(col.heading));

                // Items in column
                for (int it = 0; it < (int)col.items.size(); it++) {
                    ImGui::PushID(it);
                    char itemBuf[256];
                    strncpy(itemBuf, col.items[it].c_str(), sizeof(itemBuf) - 1);
                    itemBuf[sizeof(itemBuf) - 1] = '\0';
                    ImGui::SetNextItemWidth(180);
                    if (ImGui::InputText("##Item", itemBuf, sizeof(itemBuf))) col.items[it] = itemBuf;
                    ImGui::SameLine();
                    if (ImGui::Button("X##DelItem")) {
                        col.items.erase(col.items.begin() + it);
                        it--;
                    }
                    ImGui::PopID();
                }
                if (ImGui::Button("+ Add Item")) {
                    col.items.push_back("New Item");
                }

                ImGui::SameLine(ImGui::GetContentRegionAvail().x - 60);
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1));
                if (ImGui::Button("Del Col##DC", ImVec2(55, 18)) && sec.footer_columns.size() > 1) {
                    sec.footer_columns.erase(sec.footer_columns.begin() + c);
                    c--;
                }
                ImGui::PopStyleColor();

                ImGui::Separator();
                ImGui::PopID();
            }

            if (ImGui::Button("+ Add Column", ImVec2(-1, 26))) {
                FooterColumn col;
                strcpy(col.heading, "NEW COLUMN");
                col.items.push_back("Item 1");
                sec.footer_columns.push_back(col);
            }
        }
        // Card Connector Properties - EXACT match to original Card_connector
        else if (sec.type == SEC_CARD_CONNECTOR) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "THUMBNAIL CARDS");
            ImGui::Separator();

            // Section settings
            ImGui::Text("Section Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##CardConnBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Cards Per Row:");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120);
            ImGui::SliderInt("##CardPR", &sec.connector_cards_per_row, 1, 20);

            ImGui::Text("Card Spacing:");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120);
            ImGui::SliderFloat("##CardSpacing", &sec.connector_card_spacing, 0.0f, 50.0f, "%.0f");

            ImGui::Text("Section Padding:");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120);
            ImGui::SliderFloat("##CardPadding", &sec.connector_card_padding, 0.0f, 100.0f, "%.0f");

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Card selector
            ImGui::Text("Cards: %d", (int)sec.connector_cards.size());
            ImGui::SameLine();

            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Card")) {
                ThumbnailCard card;
                snprintf(card.heading, sizeof(card.heading), "Card %d", (int)sec.connector_cards.size() + 1);
                sec.connector_cards.push_back(card);
            }
            ImGui::PopStyleColor();

            ImGui::SameLine();

            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
            if (sec.connector_cards.size() > 1) {
                if (ImGui::Button("- Delete Card")) {
                    if (g_SelectedCardIndex >= 0 && g_SelectedCardIndex < (int)sec.connector_cards.size()) {
                        if (sec.connector_cards[g_SelectedCardIndex].textureID)
                            glDeleteTextures(1, &sec.connector_cards[g_SelectedCardIndex].textureID);
                        sec.connector_cards.erase(sec.connector_cards.begin() + g_SelectedCardIndex);
                        if (g_SelectedCardIndex >= (int)sec.connector_cards.size())
                            g_SelectedCardIndex = (int)sec.connector_cards.size() - 1;
                    }
                }
            } else {
                ImGui::BeginDisabled();
                ImGui::Button("- Delete Card");
                ImGui::EndDisabled();
            }
            ImGui::PopStyleColor();

            ImGui::Spacing();

            // Card selector dropdown
            ImGui::Text("Select Card:");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(150);
            char cardLabel[32];
            snprintf(cardLabel, sizeof(cardLabel), "Card %d", g_SelectedCardIndex + 1);
            if (ImGui::BeginCombo("##cardselect", cardLabel)) {
                for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                    bool isSelected = (g_SelectedCardIndex == i);
                    char label[32];
                    snprintf(label, sizeof(label), "Card %d", i + 1);
                    if (ImGui::Selectable(label, isSelected)) {
                        g_SelectedCardIndex = i;
                    }
                    if (isSelected) ImGui::SetItemDefaultFocus();
                }
                ImGui::EndCombo();
            }

            // Ensure valid selection
            if (g_SelectedCardIndex >= (int)sec.connector_cards.size()) g_SelectedCardIndex = (int)sec.connector_cards.size() - 1;
            if (g_SelectedCardIndex < 0) g_SelectedCardIndex = 0;

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            if (sec.connector_cards.size() > 0) {
                ThumbnailCard& card = sec.connector_cards[g_SelectedCardIndex];

                // Image upload button
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.8f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.6f, 0.9f, 1.0f));
                if (ImGui::Button("Upload Image", ImVec2(-1, 40))) {
                    char filename[1024] = {0};
                    FILE* f = popen("osascript -e 'set theFile to choose file of type {\"public.image\"} with prompt \"Select card image\"' -e 'POSIX path of theFile' 2>/dev/null", "r");
                    if (f) {
                        if (fgets(filename, sizeof(filename), f)) {
                            size_t len = strlen(filename);
                            if (len > 0 && filename[len-1] == '\n') filename[len-1] = '\0';
                            if (strlen(filename) > 0) {
                                card.imagePath = filename;
                                int w, h, n;
                                unsigned char* data = stbi_load(filename, &w, &h, &n, 4);
                                if (data) {
                                    if (card.textureID) glDeleteTextures(1, &card.textureID);
                                    glGenTextures(1, &card.textureID);
                                    glBindTexture(GL_TEXTURE_2D, card.textureID);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                    stbi_image_free(data);
                                    card.imageWidth = w;
                                    card.imageHeight = h;
                                }
                            }
                        }
                        pclose(f);
                    }
                }
                ImGui::PopStyleColor(2);

                if (card.textureID != 0) {
                    ImGui::TextColored(ImVec4(0.5f, 0.8f, 0.5f, 1.0f), "Image loaded: %dx%d", card.imageWidth, card.imageHeight);
                } else {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No image selected");
                }

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // Heading input
                ImGui::Text("Heading:");
                ImGui::PushItemWidth(-1);
                ImGui::InputText("##heading", card.heading, sizeof(card.heading));
                ImGui::PopItemWidth();

                // Heading formatting - Bold | Size | Color on one line
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Bold##heading", &card.headingBoldness, 0.0f, 3.0f, "%.1f");
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Size##heading", &card.headingSize, 0.8f, 2.5f, "%.1f");
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::ColorEdit4("##headingColor", (float*)&card.headingColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);
                ImGui::SameLine();
                ImGui::Text("Color");

                ImGui::Spacing();

                // Description input
                ImGui::Text("Description:");
                ImGui::PushItemWidth(-1);
                ImGui::InputTextMultiline("##description", card.description, sizeof(card.description), ImVec2(-1, 100));
                ImGui::PopItemWidth();

                // Description formatting - Bold | Size | Color on one line
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Bold##desc", &card.descriptionBoldness, 0.0f, 3.0f, "%.1f");
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Size##desc", &card.descriptionSize, 0.6f, 2.0f, "%.1f");
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::ColorEdit4("##descColor", (float*)&card.descriptionColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);
                ImGui::SameLine();
                ImGui::Text("Color");

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // Card background color
                ImGui::Text("Card Background:");
                ImGui::SameLine();
                ImGui::ColorEdit4("##cardColor", (float*)&card.cardColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);

                ImGui::Spacing();

                // Card size - Width | Height on one line
                ImGui::Text("Card Size:");
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Width", &card.cardWidth, 150.0f, 500.0f, "%.0f");
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::PushItemWidth(100);
                ImGui::SliderFloat("Height", &card.cardHeight, 80.0f, 600.0f, "%.0f");
                ImGui::PopItemWidth();

                ImGui::Spacing();

                // Card border radius (rectangle vs rounded)
                ImGui::Text("Card Shape:");
                ImGui::PushItemWidth(-1);
                ImGui::SliderFloat("##CardRadius", &card.cardBorderRadius, 0.0f, 30.0f, "%.0f (0=Rectangle)");
                ImGui::PopItemWidth();

                ImGui::Spacing();

                // Image height percentage
                ImGui::Text("Image Size:");
                ImGui::PushItemWidth(-1);
                ImGui::SliderFloat("##ImageHeight", &card.imageHeightPercent, 10.0f, 90.0f, "%.0f%% of card");
                ImGui::PopItemWidth();

                ImGui::Spacing();

                // Border settings
                ImGui::Text("Border Color:");
                ImGui::ColorEdit4("##borderColor", (float*)&card.borderColor, ImGuiColorEditFlags_NoInputs);
                ImGui::SameLine();
                ImGui::Text("Thickness:");
                ImGui::SameLine();
                ImGui::PushItemWidth(80);
                ImGui::SliderFloat("##borderThick", &card.borderThickness, 0.0f, 10.0f, "%.1f");
                ImGui::PopItemWidth();

                ImGui::Spacing();

                // Show/Hide READ MORE button option
                ImGui::Checkbox("Show READ MORE Button", &card.showReadMore);

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // ACTION SETTINGS for this card
                ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.4f, 1), "Card Click Action:");
                RenderActionSettings("cardAction", &card.actionType, card.actionTarget, sizeof(card.actionTarget), g_Sections);

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // Apply Style to All Cards button
                ImGui::TextColored(ImVec4(0.9f, 0.7f, 0.2f, 1), "APPLY TO ALL CARDS");
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.5f, 0.1f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.6f, 0.2f, 1.0f));
                if (ImGui::Button("Apply Size to All", ImVec2(-1, 26))) {
                    for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                        if (i != g_SelectedCardIndex) {
                            sec.connector_cards[i].cardWidth = card.cardWidth;
                            sec.connector_cards[i].cardHeight = card.cardHeight;
                        }
                    }
                }
                if (ImGui::Button("Apply Colors to All", ImVec2(-1, 26))) {
                    for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                        if (i != g_SelectedCardIndex) {
                            sec.connector_cards[i].cardColor = card.cardColor;
                            sec.connector_cards[i].headingColor = card.headingColor;
                            sec.connector_cards[i].descriptionColor = card.descriptionColor;
                            sec.connector_cards[i].borderColor = card.borderColor;
                        }
                    }
                }
                if (ImGui::Button("Apply Font Style to All", ImVec2(-1, 26))) {
                    for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                        if (i != g_SelectedCardIndex) {
                            sec.connector_cards[i].headingSize = card.headingSize;
                            sec.connector_cards[i].headingBoldness = card.headingBoldness;
                            sec.connector_cards[i].descriptionSize = card.descriptionSize;
                            sec.connector_cards[i].descriptionBoldness = card.descriptionBoldness;
                        }
                    }
                }
                if (ImGui::Button("Apply Border to All", ImVec2(-1, 26))) {
                    for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                        if (i != g_SelectedCardIndex) {
                            sec.connector_cards[i].borderColor = card.borderColor;
                            sec.connector_cards[i].borderThickness = card.borderThickness;
                        }
                    }
                }
                ImGui::Spacing();
                if (ImGui::Button("Apply ALL Styles to All Cards", ImVec2(-1, 30))) {
                    for (int i = 0; i < (int)sec.connector_cards.size(); i++) {
                        if (i != g_SelectedCardIndex) {
                            // Size and shape
                            sec.connector_cards[i].cardWidth = card.cardWidth;
                            sec.connector_cards[i].cardHeight = card.cardHeight;
                            sec.connector_cards[i].cardBorderRadius = card.cardBorderRadius;
                            sec.connector_cards[i].imageHeightPercent = card.imageHeightPercent;
                            // Colors
                            sec.connector_cards[i].cardColor = card.cardColor;
                            sec.connector_cards[i].headingColor = card.headingColor;
                            sec.connector_cards[i].descriptionColor = card.descriptionColor;
                            // Font styles
                            sec.connector_cards[i].headingSize = card.headingSize;
                            sec.connector_cards[i].headingBoldness = card.headingBoldness;
                            sec.connector_cards[i].descriptionSize = card.descriptionSize;
                            sec.connector_cards[i].descriptionBoldness = card.descriptionBoldness;
                            // Border
                            sec.connector_cards[i].borderColor = card.borderColor;
                            sec.connector_cards[i].borderThickness = card.borderThickness;
                            // READ MORE visibility
                            sec.connector_cards[i].showReadMore = card.showReadMore;
                        }
                    }
                }
                ImGui::PopStyleColor(2);

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // Clear button
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.3f, 0.3f, 1.0f));
                if (ImGui::Button("Clear Card", ImVec2(-1, 30))) {
                    if (card.textureID != 0) {
                        glDeleteTextures(1, &card.textureID);
                        card.textureID = 0;
                    }
                    card.imagePath.clear();
                    card.heading[0] = '\0';
                    card.description[0] = '\0';
                }
                ImGui::PopStyleColor(2);
            }
        }
        // Vertical Layout Connector Properties - EXACT match to original vertical_connector
        else if (sec.type == SEC_VERTICAL_CONNECTOR) {
            ImGui::Text("Global Styles");
            ImGui::Separator();
            ImGui::Spacing();

            // Background color - inline
            ImGui::Text("Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##bgColor", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();

            // Heading Style - Color | Size | Bold on one line
            ImGui::Text("Heading Style:");
            ImGui::ColorEdit4("##hColor", (float*)&sec.vertical_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::PushItemWidth(70);
            ImGui::SliderFloat("Size##h", &sec.vertical_heading_size, 0.8f, 2.5f, "%.1f");
            ImGui::PopItemWidth();
            ImGui::SameLine();
            ImGui::PushItemWidth(70);
            ImGui::SliderFloat("Bold##h", &sec.vertical_heading_boldness, 0.0f, 3.0f, "%.1f");
            ImGui::PopItemWidth();

            ImGui::Spacing();

            // Description Style - Color | Size | Bold on one line
            ImGui::Text("Description Style:");
            ImGui::ColorEdit4("##dColor", (float*)&sec.vertical_desc_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::PushItemWidth(70);
            ImGui::SliderFloat("Size##d", &sec.vertical_desc_size, 0.6f, 2.0f, "%.1f");
            ImGui::PopItemWidth();
            ImGui::SameLine();
            ImGui::PushItemWidth(70);
            ImGui::SliderFloat("Bold##d", &sec.vertical_desc_boldness, 0.0f, 3.0f, "%.1f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Layout
            ImGui::Text("Layout:");
            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Content Width", &sec.vertical_content_width, 300.0f, 800.0f, "%.0f");
            ImGui::SliderFloat("Vertical Spacing", &sec.vertical_spacing, 5.0f, 50.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();

            // Margin controls
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "MARGIN");
            ImGui::Separator();
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Top##VCMargin", &sec.margin_top, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Right##VCMargin", &sec.margin_right, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Bottom##VCMargin", &sec.margin_bottom, 0.0f, 100.0f, "%.0fpx");
            ImGui::SetNextItemWidth(100);
            ImGui::SliderFloat("Left##VCMargin", &sec.margin_left, 0.0f, 100.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Block Management - Add buttons on one line
            ImGui::Text("Content Blocks:");

            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.3f, 1.0f));
            if (ImGui::Button("+ Heading")) {
                VerticalBlock b;
                b.type = 0;
                strcpy(b.text, "New Heading");
                sec.vertical_blocks.push_back(b);
                g_SelectedVertBlockIndex = (int)sec.vertical_blocks.size() - 1;
            }
            ImGui::SameLine();
            if (ImGui::Button("+ Description")) {
                VerticalBlock b;
                b.type = 1;
                strcpy(b.text, "New description text...");
                sec.vertical_blocks.push_back(b);
                g_SelectedVertBlockIndex = (int)sec.vertical_blocks.size() - 1;
            }
            ImGui::SameLine();
            if (ImGui::Button("+ Image")) {
                std::string path = OpenFileDialog("Select an image");
                if (!path.empty()) {
                    VerticalBlock b;
                    b.type = 2;
                    b.imagePath = path;
                    b.posX = 350.0f;  // Default position (right side)
                    b.posY = 30.0f;
                    b.displayWidth = 150.0f;
                    int w, h, n;
                    unsigned char* data = stbi_load(path.c_str(), &w, &h, &n, 4);
                    if (data) {
                        glGenTextures(1, &b.textureID);
                        glBindTexture(GL_TEXTURE_2D, b.textureID);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                        stbi_image_free(data);
                        b.imageWidth = w;
                        b.imageHeight = h;
                    }
                    sec.vertical_blocks.push_back(b);
                    g_SelectedVertBlockIndex = (int)sec.vertical_blocks.size() - 1;
                }
            }
            ImGui::PopStyleColor();

            ImGui::Spacing();

            // Block list with move up/down and delete
            ImGui::Text("Blocks (%d):", (int)sec.vertical_blocks.size());
            ImGui::BeginChild("BlockList", ImVec2(-1, 150), true);

            int blockToDelete = -1;
            int blockToMoveUp = -1;
            int blockToMoveDown = -1;

            for (int i = 0; i < (int)sec.vertical_blocks.size(); i++) {
                ImGui::PushID(i);

                bool isSelected = (g_SelectedVertBlockIndex == i);
                const char* typeStr = sec.vertical_blocks[i].type == 0 ? "[H]" :
                                      sec.vertical_blocks[i].type == 1 ? "[D]" : "[I]";

                char label[64];
                if (sec.vertical_blocks[i].type == 2) {
                    snprintf(label, sizeof(label), "%s Image", typeStr);
                } else {
                    char preview[30];
                    strncpy(preview, sec.vertical_blocks[i].text, 25);
                    preview[25] = '\0';
                    if (strlen(sec.vertical_blocks[i].text) > 25) strcat(preview, "...");
                    snprintf(label, sizeof(label), "%s %s", typeStr, preview);
                }

                if (ImGui::Selectable(label, isSelected)) {
                    g_SelectedVertBlockIndex = i;
                }

                // Context buttons - move up/down and delete
                ImGui::SameLine(ImGui::GetContentRegionAvail().x - 60);
                if (i > 0 && ImGui::SmallButton("^")) blockToMoveUp = i;
                ImGui::SameLine();
                if (i < (int)sec.vertical_blocks.size() - 1 && ImGui::SmallButton("v")) blockToMoveDown = i;
                ImGui::SameLine();
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                if (ImGui::SmallButton("X")) blockToDelete = i;
                ImGui::PopStyleColor();

                ImGui::PopID();
            }
            ImGui::EndChild();

            // Handle reordering and deletion
            if (blockToMoveUp > 0) {
                std::swap(sec.vertical_blocks[blockToMoveUp], sec.vertical_blocks[blockToMoveUp - 1]);
                if (g_SelectedVertBlockIndex == blockToMoveUp) g_SelectedVertBlockIndex--;
                else if (g_SelectedVertBlockIndex == blockToMoveUp - 1) g_SelectedVertBlockIndex++;
            }
            if (blockToMoveDown >= 0 && blockToMoveDown < (int)sec.vertical_blocks.size() - 1) {
                std::swap(sec.vertical_blocks[blockToMoveDown], sec.vertical_blocks[blockToMoveDown + 1]);
                if (g_SelectedVertBlockIndex == blockToMoveDown) g_SelectedVertBlockIndex++;
                else if (g_SelectedVertBlockIndex == blockToMoveDown + 1) g_SelectedVertBlockIndex--;
            }
            if (blockToDelete >= 0 && sec.vertical_blocks.size() > 1) {
                if (sec.vertical_blocks[blockToDelete].type == 2 && sec.vertical_blocks[blockToDelete].textureID != 0) {
                    glDeleteTextures(1, &sec.vertical_blocks[blockToDelete].textureID);
                }
                sec.vertical_blocks.erase(sec.vertical_blocks.begin() + blockToDelete);
                if (g_SelectedVertBlockIndex >= (int)sec.vertical_blocks.size()) g_SelectedVertBlockIndex = (int)sec.vertical_blocks.size() - 1;
                if (g_SelectedVertBlockIndex < 0) g_SelectedVertBlockIndex = 0;
            }

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Edit selected block
            if (g_SelectedVertBlockIndex >= 0 && g_SelectedVertBlockIndex < (int)sec.vertical_blocks.size()) {
                VerticalBlock& block = sec.vertical_blocks[g_SelectedVertBlockIndex];

                ImGui::Text("Edit Block #%d:", g_SelectedVertBlockIndex + 1);

                if (block.type == 0) {  // Heading
                    ImGui::Text("Type: Heading");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputText("##blockText", block.text, sizeof(block.text));
                    ImGui::PopItemWidth();
                }
                else if (block.type == 1) {  // Description
                    ImGui::Text("Type: Description");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputTextMultiline("##blockText", block.text, sizeof(block.text), ImVec2(-1, 100));
                    ImGui::PopItemWidth();
                }
                else if (block.type == 2) {  // Image
                    ImGui::Text("Type: Image");

                    if (block.textureID != 0) {
                        ImGui::Text("Size: %dx%d", block.imageWidth, block.imageHeight);

                        ImGui::Spacing();
                        ImGui::TextColored(ImVec4(0.5f, 0.8f, 0.5f, 1.0f), "Drag image in preview to move");
                        ImGui::Spacing();

                        // Image size control
                        ImGui::PushItemWidth(150);
                        ImGui::SliderFloat("Display Width", &block.displayWidth, 50.0f, 500.0f, "%.0f");
                        ImGui::PopItemWidth();

                        // Position controls - X and Y sliders
                        ImGui::Text("Position X:");
                        ImGui::PushItemWidth(-1);
                        ImGui::SliderFloat("##imgPosX", &block.posX, 0.0f, 800.0f, "%.0f");
                        ImGui::PopItemWidth();

                        ImGui::Text("Position Y:");
                        ImGui::PushItemWidth(-1);
                        ImGui::SliderFloat("##imgPosY", &block.posY, 0.0f, 500.0f, "%.0f");
                        ImGui::PopItemWidth();

                        ImGui::Spacing();

                        // Preview thumbnail
                        float aspect = (float)block.imageHeight / (float)block.imageWidth;
                        float previewH = 80.0f * aspect;
                        ImGui::Image((ImTextureID)(intptr_t)block.textureID, ImVec2(80, previewH));
                    }

                    // Replace image button
                    if (ImGui::Button("Replace Image")) {
                        std::string path = OpenFileDialog("Select an image");
                        if (!path.empty()) {
                            block.imagePath = path;
                            if (block.textureID != 0) glDeleteTextures(1, &block.textureID);
                            int w, h, n;
                            unsigned char* data = stbi_load(path.c_str(), &w, &h, &n, 4);
                            if (data) {
                                glGenTextures(1, &block.textureID);
                                glBindTexture(GL_TEXTURE_2D, block.textureID);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                stbi_image_free(data);
                                block.imageWidth = w;
                                block.imageHeight = h;
                            }
                        }
                    }

                    // Show upload button if no image loaded
                    if (block.textureID == 0) {
                        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.8f, 1.0f));
                        if (ImGui::Button("Upload Image", ImVec2(-1, 35))) {
                            std::string path = OpenFileDialog("Select an image");
                            if (!path.empty()) {
                                block.imagePath = path;
                                int w, h, n;
                                unsigned char* data = stbi_load(path.c_str(), &w, &h, &n, 4);
                                if (data) {
                                    glGenTextures(1, &block.textureID);
                                    glBindTexture(GL_TEXTURE_2D, block.textureID);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                    stbi_image_free(data);
                                    block.imageWidth = w;
                                    block.imageHeight = h;
                                }
                            }
                        }
                        ImGui::PopStyleColor();
                    }
                }
            }
        }
        // ==================== NAVBAR CONNECTOR PROPERTIES ====================
        else if (sec.type == SEC_NAVBAR_CONNECTOR) {
            ImGui::Text("Navbar Style");
            ImGui::Separator();
            ImGui::Spacing();

            // Colors
            ImGui::Text("Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##navBg", (float*)&sec.navbar_bg_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Hover:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##navHover", (float*)&sec.navbar_hover_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Dropdown:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##navDrop", (float*)&sec.navbar_dropdown_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##navText", (float*)&sec.navbar_text_color, ImGuiColorEditFlags_NoInputs);

            // Text style controls
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "TEXT STYLE");
            ImGui::Separator();
            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Font Scale", &sec.navbar_font_scale, 0.5f, 2.0f, "%.1f");
            ImGui::SliderFloat("Text Bold", &sec.navbar_font_boldness, 0.0f, 3.0f, "%.1f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Layout settings
            ImGui::Text("Layout:");
            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Navbar Height", &sec.navbar_height, 30.0f, 80.0f, "%.0f");
            ImGui::SliderFloat("Padding X", &sec.navbar_padding_x, 0.0f, 30.0f, "%.0f");
            ImGui::SliderFloat("Padding Y", &sec.navbar_padding_y, 0.0f, 30.0f, "%.0f");
            ImGui::SliderFloat("Spacing", &sec.navbar_spacing, 0.0f, 40.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();

            ImGui::Checkbox("Rounded Corners", &sec.navbar_rounded);
            if (sec.navbar_rounded) {
                ImGui::PushItemWidth(150);
                ImGui::SliderFloat("Corner Radius", &sec.navbar_rounding, 0.0f, 20.0f, "%.0f");
                ImGui::PopItemWidth();
            }

            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Font Scale", &sec.navbar_font_scale, 0.7f, 1.5f, "%.1f");
            ImGui::PopItemWidth();

            // Update section height based on navbar height
            sec.height = (int)sec.navbar_height;

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Menu Items Management
            ImGui::Text("Menu Items:");

            // Add new menu item
            static char newMenuName[64] = "";
            ImGui::PushItemWidth(150);
            ImGui::InputText("##newMenu", newMenuName, sizeof(newMenuName));
            ImGui::PopItemWidth();
            ImGui::SameLine();
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Menu") && strlen(newMenuName) > 0) {
                NavbarMenuItem item;
                strncpy(item.label, newMenuName, sizeof(item.label) - 1);
                sec.navbar_items.push_back(item);
                newMenuName[0] = '\0';
            }
            ImGui::PopStyleColor();

            ImGui::Spacing();

            // Menu items list
            static int selectedNavItem = 0;
            if (selectedNavItem >= (int)sec.navbar_items.size()) selectedNavItem = (int)sec.navbar_items.size() - 1;
            if (selectedNavItem < 0) selectedNavItem = 0;

            ImGui::BeginChild("NavMenuList", ImVec2(-1, 120), true);
            int menuToDelete = -1;
            for (int i = 0; i < (int)sec.navbar_items.size(); i++) {
                ImGui::PushID(i);
                char label[128];
                int childCount = (int)sec.navbar_items[i].children.size();
                if (childCount > 0) {
                    snprintf(label, sizeof(label), "%s (%d sub)", sec.navbar_items[i].label, childCount);
                } else {
                    snprintf(label, sizeof(label), "%s", sec.navbar_items[i].label);
                }
                // Use AllowItemOverlap so delete button can be clicked
                if (ImGui::Selectable(label, selectedNavItem == i, ImGuiSelectableFlags_AllowItemOverlap)) {
                    selectedNavItem = i;
                }

                // Delete button
                ImGui::SameLine(ImGui::GetContentRegionAvail().x - 15);
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1.0f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.9f, 0.3f, 0.3f, 1.0f));
                if (sec.navbar_items.size() > 1 && ImGui::SmallButton("X")) {
                    menuToDelete = i;
                }
                ImGui::PopStyleColor(2);
                ImGui::PopID();
            }
            // Delete outside loop to avoid iterator invalidation
            static bool menuWasDeleted = false;
            if (menuToDelete >= 0) {
                sec.navbar_items.erase(sec.navbar_items.begin() + menuToDelete);
                if (selectedNavItem >= (int)sec.navbar_items.size()) selectedNavItem = (int)sec.navbar_items.size() - 1;
                menuWasDeleted = true;
            }
            ImGui::EndChild();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Edit selected menu item
            static int lastSelectedNavItem = -1;
            static int selectedSubItem = -1;
            static char newSubItem[64] = "";

            // Reset sub-item selection when switching menu items or when menu was deleted
            if (lastSelectedNavItem != selectedNavItem || menuWasDeleted) {
                selectedSubItem = -1;
                newSubItem[0] = '\0';
                lastSelectedNavItem = selectedNavItem;
                menuWasDeleted = false;
            }

            if (selectedNavItem >= 0 && selectedNavItem < (int)sec.navbar_items.size()) {
                NavbarMenuItem& item = sec.navbar_items[selectedNavItem];

                ImGui::PushID(selectedNavItem + 5000);  // Unique ID scope for this menu item

                ImGui::Text("Edit Menu: %s", item.label);

                // Edit label
                ImGui::Text("Label:");
                ImGui::PushItemWidth(-1);
                ImGui::InputText("##editLabel", item.label, sizeof(item.label));
                ImGui::PopItemWidth();

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // ACTION SETTINGS for this menu item
                ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.4f, 1), "Click Action:");
                RenderActionSettings("navAction", &item.actionType, item.actionTarget, sizeof(item.actionTarget), g_Sections);

                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();

                // Dropdown items (children)
                ImGui::Text("Dropdown Items:");

                // Add new dropdown item
                ImGui::PushItemWidth(150);
                ImGui::InputText("##newSubInput", newSubItem, sizeof(newSubItem));
                ImGui::PopItemWidth();
                ImGui::SameLine();
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.6f, 1.0f));
                if (ImGui::Button("+ Add Sub##addSubBtn") && strlen(newSubItem) > 0) {
                    item.children.push_back(newSubItem);
                    // Also add default action entries
                    item.childActionTypes.push_back(ACTION_NONE);
                    item.childActionTargets.push_back("");
                    newSubItem[0] = '\0';
                }
                ImGui::PopStyleColor();

                // List of dropdown items
                if (!item.children.empty()) {
                    // Ensure action vectors are synced with children size
                    while (item.childActionTypes.size() < item.children.size()) {
                        item.childActionTypes.push_back(ACTION_NONE);
                        item.childActionTargets.push_back("");
                    }
                    // Trim if too many
                    while (item.childActionTypes.size() > item.children.size()) {
                        item.childActionTypes.pop_back();
                        item.childActionTargets.pop_back();
                    }

                    ImGui::BeginChild("SubItemList", ImVec2(-1, 100), true);
                    int subToDelete = -1;
                    for (int j = 0; j < (int)item.children.size(); j++) {
                        ImGui::PushID(j + 2000);

                        // Selectable sub-item with AllowItemOverlap so button can be clicked
                        bool isSelected = (selectedSubItem == j);
                        if (ImGui::Selectable(item.children[j].c_str(), isSelected, ImGuiSelectableFlags_AllowItemOverlap)) {
                            selectedSubItem = j;
                        }

                        // Delete button on same line
                        ImGui::SameLine(ImGui::GetContentRegionAvail().x - 15);
                        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1.0f));
                        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.9f, 0.3f, 0.3f, 1.0f));
                        if (ImGui::SmallButton("X")) {
                            subToDelete = j;
                        }
                        ImGui::PopStyleColor(2);
                        ImGui::PopID();
                    }
                    if (subToDelete >= 0) {
                        item.children.erase(item.children.begin() + subToDelete);
                        if (subToDelete < (int)item.childActionTypes.size()) {
                            item.childActionTypes.erase(item.childActionTypes.begin() + subToDelete);
                        }
                        if (subToDelete < (int)item.childActionTargets.size()) {
                            item.childActionTargets.erase(item.childActionTargets.begin() + subToDelete);
                        }
                        if (selectedSubItem >= (int)item.children.size()) selectedSubItem = -1;
                        if (selectedSubItem == subToDelete) selectedSubItem = -1;
                    }
                    ImGui::EndChild();

                    // Edit selected sub-item action
                    if (selectedSubItem >= 0 && selectedSubItem < (int)item.children.size()) {
                        ImGui::Spacing();
                        ImGui::TextColored(ImVec4(0.8f, 0.6f, 0.2f, 1), "Sub-Item Action: %s", item.children[selectedSubItem].c_str());

                        // Edit sub-item text
                        static char subEditBuf[256];
                        strncpy(subEditBuf, item.children[selectedSubItem].c_str(), sizeof(subEditBuf) - 1);
                        ImGui::PushItemWidth(150);
                        if (ImGui::InputText("##editSubLabel", subEditBuf, sizeof(subEditBuf))) {
                            item.children[selectedSubItem] = subEditBuf;
                        }
                        ImGui::PopItemWidth();

                        // Action settings for this sub-item
                        static char subTargetBuf[512];
                        strncpy(subTargetBuf, item.childActionTargets[selectedSubItem].c_str(), sizeof(subTargetBuf) - 1);
                        RenderActionSettings("subAction", &item.childActionTypes[selectedSubItem], subTargetBuf, sizeof(subTargetBuf), g_Sections);
                        item.childActionTargets[selectedSubItem] = subTargetBuf;
                    }
                } else {
                    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "No dropdown items");
                    selectedSubItem = -1;
                }

                ImGui::PopID();  // End unique ID scope for this menu item
            }

            // Reset theme button
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();
            if (ImGui::Button("Reset Theme")) {
                sec.navbar_bg_color = ImVec4(0.12f, 0.12f, 0.12f, 1.0f);
                sec.navbar_hover_color = ImVec4(0.26f, 0.26f, 0.26f, 1.0f);
                sec.navbar_dropdown_color = ImVec4(0.18f, 0.18f, 0.18f, 1.0f);
                sec.navbar_text_color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                sec.navbar_height = 42.0f;
                sec.navbar_padding_x = 10.0f;
                sec.navbar_padding_y = 8.0f;
                sec.navbar_spacing = 18.0f;
                sec.navbar_rounding = 4.0f;
                sec.navbar_font_scale = 1.0f;
                sec.navbar_rounded = true;
            }
        }
        // ==================== COPYRIGHT CONNECTOR PROPERTIES ====================
        else if (sec.type == SEC_COPYRIGHT_CONNECTOR) {
            ImGui::Text("Copyright Bar Style");
            ImGui::Separator();
            ImGui::Spacing();

            // Background with opacity control
            ImGui::Text("Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##copyrightBg", (float*)&sec.copyright_bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("BG Opacity", &sec.copyright_bg_opacity, 0.0f, 1.0f, "%.2f");
            ImGui::PopItemWidth();

            ImGui::Spacing();

            ImGui::Text("Text Color:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##copyrightText", (float*)&sec.copyright_text_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Link Color:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##copyrightLink", (float*)&sec.copyright_link_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Font sizes
            ImGui::Text("Typography:");
            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Main Text Size", &sec.copyright_font_size, 8.0f, 20.0f, "%.0f");
            ImGui::SliderFloat("Subtext Size", &sec.copyright_subtext_size, 8.0f, 18.0f, "%.0f");
            ImGui::SliderFloat("Padding", &sec.copyright_padding, 5.0f, 40.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Main copyright text
            ImGui::Text("Main Text:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##copyrightMainText", sec.copyright_text, sizeof(sec.copyright_text));
            ImGui::PopItemWidth();

            // Subtext (company info)
            ImGui::Text("Company Text:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##copyrightSubText", sec.copyright_subtext, sizeof(sec.copyright_subtext));
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Links management
            ImGui::Text("Links:");

            // Add new link
            static char newLinkText[64] = "";
            static char newLinkUrl[128] = "#";
            static bool newLinkBold = true;

            ImGui::PushItemWidth(100);
            ImGui::InputText("##newLinkText", newLinkText, sizeof(newLinkText));
            ImGui::PopItemWidth();
            ImGui::SameLine();
            ImGui::Checkbox("Bold##newLink", &newLinkBold);
            ImGui::SameLine();
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Link") && strlen(newLinkText) > 0) {
                CopyrightLink link;
                strncpy(link.text, newLinkText, sizeof(link.text) - 1);
                strncpy(link.url, newLinkUrl, sizeof(link.url) - 1);
                link.isBold = newLinkBold;
                sec.copyright_links.push_back(link);
                newLinkText[0] = '\0';
                strcpy(newLinkUrl, "#");
                newLinkBold = true;
            }
            ImGui::PopStyleColor();

            // List existing links
            static int selectedCopyrightLink = -1;
            if (!sec.copyright_links.empty()) {
                ImGui::BeginChild("CopyrightLinkList", ImVec2(-1, 80), true);
                int linkToDelete = -1;
                for (int i = 0; i < (int)sec.copyright_links.size(); i++) {
                    ImGui::PushID(i);
                    CopyrightLink& link = sec.copyright_links[i];

                    // Selectable link
                    bool isSelected = (selectedCopyrightLink == i);
                    char linkLabel[300];
                    snprintf(linkLabel, sizeof(linkLabel), "%s%s", link.text, link.isBold ? " [B]" : "");
                    if (ImGui::Selectable(linkLabel, isSelected)) {
                        selectedCopyrightLink = i;
                    }

                    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 20);
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                    if (ImGui::SmallButton("X")) {
                        linkToDelete = i;
                    }
                    ImGui::PopStyleColor();
                    ImGui::PopID();
                }
                if (linkToDelete >= 0) {
                    sec.copyright_links.erase(sec.copyright_links.begin() + linkToDelete);
                    if (selectedCopyrightLink >= (int)sec.copyright_links.size()) selectedCopyrightLink = -1;
                }
                ImGui::EndChild();

                // Edit selected link
                if (selectedCopyrightLink >= 0 && selectedCopyrightLink < (int)sec.copyright_links.size()) {
                    CopyrightLink& link = sec.copyright_links[selectedCopyrightLink];

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.8f, 0.6f, 0.2f, 1), "Edit Link: %s", link.text);

                    ImGui::PushItemWidth(150);
                    ImGui::InputText("##editLinkText", link.text, sizeof(link.text));
                    ImGui::PopItemWidth();
                    ImGui::SameLine();
                    ImGui::Checkbox("Bold##editLink", &link.isBold);

                    // Action settings for this link
                    RenderActionSettings("copyrightLinkAction", &link.actionType, link.url, sizeof(link.url), g_Sections);
                }
            } else {
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "No links added");
                selectedCopyrightLink = -1;
            }

            // Reset button
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();
            if (ImGui::Button("Reset Defaults")) {
                strcpy(sec.copyright_text, "Website under development.");
                strcpy(sec.copyright_subtext, "2025 COMPANY NAME. ALL RIGHTS RESERVED.");
                sec.copyright_bg_color = ImVec4(0.18f, 0.18f, 0.18f, 1.0f);
                sec.copyright_text_color = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
                sec.copyright_link_color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
                sec.copyright_font_size = 11.0f;
                sec.copyright_subtext_size = 10.0f;
                sec.copyright_padding = 15.0f;
                sec.copyright_bg_opacity = 1.0f;
            }
        }
        // Article Cards connector properties
        else if (sec.type == SEC_ARTICLE_CONNECTOR) {
            ImGui::Text("Article Cards Style");
            ImGui::Separator();
            ImGui::Spacing();

            // Layout settings
            ImGui::Text("Layout:");
            ImGui::PushItemWidth(150);
            ImGui::SliderInt("Cards Per Row", &sec.article_cards_per_row, 1, 4);
            ImGui::SliderFloat("Card Spacing", &sec.article_card_spacing, 5.0f, 50.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Text("Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##articleBg", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Article cards management
            ImGui::Text("Article Cards:");

            // Add new card
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Card")) {
                ArticleCard card;
                snprintf(card.heading, sizeof(card.heading), "New Article %d", (int)sec.article_cards.size() + 1);
                sec.article_cards.push_back(card);
            }
            ImGui::PopStyleColor();

            // List existing cards
            static int selectedArticleCard = -1;
            if (!sec.article_cards.empty()) {
                ImGui::BeginChild("ArticleCardList", ImVec2(-1, 100), true);
                int cardToDelete = -1;
                for (int i = 0; i < (int)sec.article_cards.size(); i++) {
                    ImGui::PushID(i);
                    ArticleCard& card = sec.article_cards[i];

                    bool isSelected = (selectedArticleCard == i);
                    char cardLabel[300];
                    snprintf(cardLabel, sizeof(cardLabel), "%d. %s", i + 1, card.heading);

                    // Delete button first (right side)
                    float contentWidth = ImGui::GetContentRegionAvail().x;
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + contentWidth - 25);
                    if (ImGui::SmallButton("X##del")) {
                        cardToDelete = i;
                    }
                    ImGui::PopStyleColor();

                    // Selectable on same line (left side)
                    ImGui::SameLine();
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() - contentWidth + 5);
                    if (ImGui::Selectable(cardLabel, isSelected, 0, ImVec2(contentWidth - 35, 0))) {
                        selectedArticleCard = i;
                    }
                    ImGui::PopID();
                }
                if (cardToDelete >= 0) {
                    sec.article_cards.erase(sec.article_cards.begin() + cardToDelete);
                    if (selectedArticleCard >= (int)sec.article_cards.size()) selectedArticleCard = -1;
                }
                ImGui::EndChild();

                // Edit selected card
                if (selectedArticleCard >= 0 && selectedArticleCard < (int)sec.article_cards.size()) {
                    ArticleCard& card = sec.article_cards[selectedArticleCard];

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.91f, 0.4f, 0.1f, 1), "Editing Card %d", selectedArticleCard + 1);
                    ImGui::Separator();
                    ImGui::Spacing();

                    // Content
                    ImGui::Text("Heading:");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputText("##articleHeading", card.heading, sizeof(card.heading));
                    ImGui::PopItemWidth();

                    ImGui::Text("Date:");
                    ImGui::PushItemWidth(150);
                    ImGui::InputText("##articleDate", card.date, sizeof(card.date));
                    ImGui::PopItemWidth();

                    ImGui::Text("Description:");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputTextMultiline("##articleDesc", card.description, sizeof(card.description), ImVec2(-1, 60));
                    ImGui::PopItemWidth();

                    ImGui::Text("Read More Text:");
                    ImGui::PushItemWidth(150);
                    ImGui::InputText("##articleReadMore", card.readMoreText, sizeof(card.readMoreText));
                    ImGui::PopItemWidth();

                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::Spacing();

                    // Colors
                    ImGui::Text("Colors:");
                    ImGui::Text("Heading:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleHeadingClr", (float*)&card.headingColor, ImGuiColorEditFlags_NoInputs);
                    ImGui::SameLine();
                    ImGui::Text("Date:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleDateClr", (float*)&card.dateColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::Text("Description:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleDescClr", (float*)&card.descriptionColor, ImGuiColorEditFlags_NoInputs);
                    ImGui::SameLine();
                    ImGui::Text("Read More:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleRMClr", (float*)&card.readMoreColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::Text("Card BG:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleCardBg", (float*)&card.cardBgColor, ImGuiColorEditFlags_NoInputs);
                    ImGui::SameLine();
                    ImGui::Text("Accent:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##articleAccent", (float*)&card.accentColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::Spacing();

                    // Sizes
                    ImGui::Text("Sizes:");
                    ImGui::PushItemWidth(100);
                    ImGui::SliderFloat("Card Width", &card.cardWidth, 200.0f, 800.0f, "%.0f");
                    ImGui::SliderFloat("Card Height", &card.cardHeight, 100.0f, 400.0f, "%.0f");
                    ImGui::SliderFloat("Accent Width", &card.accentWidth, 2.0f, 12.0f, "%.0f");
                    ImGui::SliderFloat("Card Padding", &card.cardPadding, 5.0f, 40.0f, "%.0f");
                    ImGui::PopItemWidth();

                    ImGui::Spacing();
                    ImGui::Text("Font Sizes:");
                    ImGui::PushItemWidth(100);
                    ImGui::SliderFloat("Heading##sz", &card.headingSize, 0.6f, 2.0f, "%.1f");
                    ImGui::SameLine();
                    ImGui::SliderFloat("Date##sz", &card.dateSize, 0.5f, 1.5f, "%.1f");
                    ImGui::SliderFloat("Desc##sz", &card.descriptionSize, 0.5f, 1.5f, "%.1f");
                    ImGui::SameLine();
                    ImGui::SliderFloat("ReadMore##sz", &card.readMoreSize, 0.5f, 1.5f, "%.1f");
                    ImGui::PopItemWidth();

                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::Spacing();

                    // Action settings for heading
                    ImGui::TextColored(ImVec4(0.91f, 0.4f, 0.1f, 1), "Heading Action:");
                    RenderActionSettings("articleHeadingAction", &card.headingActionType, card.headingActionTarget, sizeof(card.headingActionTarget), g_Sections);

                    ImGui::Spacing();

                    // Action settings for read more button
                    ImGui::TextColored(ImVec4(0.4f, 0.4f, 0.4f, 1), "Read More Action:");
                    RenderActionSettings("articleReadMoreAction", &card.readMoreActionType, card.readMoreActionTarget, sizeof(card.readMoreActionTarget), g_Sections);
                }
            } else {
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "No cards added");
                selectedArticleCard = -1;
            }
        }
        // Contact Form connector properties
        else if (sec.type == SEC_CONTACT_FORM_CONNECTOR) {
            ImGui::Text("Contact Form Style");
            ImGui::Separator();
            ImGui::Spacing();

            // Title
            ImGui::Text("Form Title:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##formTitle", sec.contact_form_title, sizeof(sec.contact_form_title));
            ImGui::PopItemWidth();

            ImGui::Text("Title Color:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##formTitleClr", (float*)&sec.contact_form_title_color, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("Title Size", &sec.contact_form_title_size, 0.8f, 2.0f, "%.1f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Input styling
            ImGui::Text("Input Style:");
            ImGui::Text("BG:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##inputBg", (float*)&sec.contact_form_input_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##inputText", (float*)&sec.contact_form_input_text, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("Input Height", &sec.contact_form_input_height, 30.0f, 60.0f, "%.0f");
            ImGui::SliderFloat("Textarea Height", &sec.contact_form_textarea_height, 80.0f, 300.0f, "%.0f");
            ImGui::SliderFloat("Field Spacing", &sec.contact_form_spacing, 10.0f, 40.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Submit button styling
            ImGui::Text("Submit Button:");
            ImGui::PushItemWidth(150);
            ImGui::InputText("##submitText", sec.contact_form_submit_text, sizeof(sec.contact_form_submit_text));
            ImGui::PopItemWidth();

            ImGui::Text("BG:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##btnBg", (float*)&sec.contact_form_button_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##btnText", (float*)&sec.contact_form_button_text, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Border:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##btnBorder", (float*)&sec.contact_form_button_border, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("Button Width", &sec.contact_form_button_width, 60.0f, 200.0f, "%.0f");
            ImGui::SliderFloat("Button Height", &sec.contact_form_button_height, 30.0f, 60.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();

            // Submit action
            ImGui::TextColored(ImVec4(0.2f, 0.6f, 0.9f, 1), "Submit Action:");
            RenderActionSettings("contactFormSubmit", &sec.contact_form_submit_action, sec.contact_form_submit_target, sizeof(sec.contact_form_submit_target), g_Sections);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Form fields management
            ImGui::Text("Form Fields:");
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Field")) {
                ContactFormField newField;
                snprintf(newField.label, sizeof(newField.label), "Field %d", (int)sec.contact_form_fields.size() + 1);
                strcpy(newField.placeholder, "Enter value...");
                newField.fieldType = 0;
                newField.width = 0.5f;
                sec.contact_form_fields.push_back(newField);
            }
            ImGui::PopStyleColor();

            static int selectedFormField = -1;
            if (!sec.contact_form_fields.empty()) {
                ImGui::BeginChild("FormFieldList", ImVec2(-1, 100), true);
                int fieldToDelete = -1;
                for (int i = 0; i < (int)sec.contact_form_fields.size(); i++) {
                    ImGui::PushID(i);
                    ContactFormField& field = sec.contact_form_fields[i];

                    bool isSelected = (selectedFormField == i);
                    const char* typeNames[] = {"Text", "Email", "Phone", "Textarea"};
                    char fieldLabel[300];
                    snprintf(fieldLabel, sizeof(fieldLabel), "%d. %s (%s, %.0f%%)", i + 1, field.placeholder, typeNames[field.fieldType], field.width * 100);
                    if (ImGui::Selectable(fieldLabel, isSelected)) {
                        selectedFormField = i;
                    }

                    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 20);
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                    if (ImGui::SmallButton("X") && sec.contact_form_fields.size() > 1) {
                        fieldToDelete = i;
                    }
                    ImGui::PopStyleColor();
                    ImGui::PopID();
                }
                if (fieldToDelete >= 0) {
                    sec.contact_form_fields.erase(sec.contact_form_fields.begin() + fieldToDelete);
                    if (selectedFormField >= (int)sec.contact_form_fields.size()) selectedFormField = -1;
                }
                ImGui::EndChild();

                // Edit selected field
                if (selectedFormField >= 0 && selectedFormField < (int)sec.contact_form_fields.size()) {
                    ContactFormField& field = sec.contact_form_fields[selectedFormField];

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.2f, 0.6f, 0.9f, 1), "Edit Field %d:", selectedFormField + 1);

                    ImGui::PushItemWidth(150);
                    ImGui::InputText("Placeholder##field", field.placeholder, sizeof(field.placeholder));

                    const char* typeOptions[] = {"Text", "Email", "Phone", "Textarea"};
                    ImGui::Combo("Type##field", &field.fieldType, typeOptions, 4);

                    const char* widthOptions[] = {"Half Width (50%)", "Full Width (100%)"};
                    int widthIdx = field.width >= 1.0f ? 1 : 0;
                    if (ImGui::Combo("Width##field", &widthIdx, widthOptions, 2)) {
                        field.width = widthIdx == 1 ? 1.0f : 0.5f;
                    }
                    ImGui::PopItemWidth();
                }
            } else {
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "No fields added");
                selectedFormField = -1;
            }
        }
        // Search Connector properties
        else if (sec.type == SEC_SEARCH_CONNECTOR) {
            ImGui::Text("Search Bar Style");
            ImGui::Separator();
            ImGui::Spacing();

            // Placeholder text
            ImGui::Text("Placeholder:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##searchPlaceholder", sec.search_placeholder, sizeof(sec.search_placeholder));
            ImGui::PopItemWidth();

            // Button text
            ImGui::Text("Button Text:");
            ImGui::PushItemWidth(120);
            ImGui::InputText("##searchBtnText", sec.search_button_text, sizeof(sec.search_button_text));
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Input field styling
            ImGui::Text("Input Field:");
            ImGui::Text("BG:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##searchInputBg", (float*)&sec.search_input_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Border:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##searchInputBorder", (float*)&sec.search_input_border, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##searchInputText", (float*)&sec.search_input_text, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("Input Width", &sec.search_input_width, 200.0f, 800.0f, "%.0f");
            ImGui::SliderFloat("Input Height", &sec.search_input_height, 30.0f, 60.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Button styling
            ImGui::Text("Search Button:");
            ImGui::Text("BG:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##searchBtnBg", (float*)&sec.search_button_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##searchBtnTextClr", (float*)&sec.search_button_text_color, ImGuiColorEditFlags_NoInputs);

            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("Button Width", &sec.search_button_width, 60.0f, 200.0f, "%.0f");
            ImGui::SliderFloat("Border Radius", &sec.search_border_radius, 0.0f, 20.0f, "%.0f");
            ImGui::PopItemWidth();
        }
        // Logo Connector properties
        else if (sec.type == SEC_LOGO_CONNECTOR) {
            ImGui::Text("Logo Settings");
            ImGui::Separator();
            ImGui::Spacing();

            // Upload logo button
            if (ImGui::Button("Upload Logo Image", ImVec2(-1, 35))) {
                std::string path = OpenFileDialog("Select logo image");
                if (!path.empty()) {
                    int w, h, c;
                    unsigned char* data = stbi_load(path.c_str(), &w, &h, &c, 4);
                    if (data) {
                        // Delete old texture if exists
                        if (sec.logo_connector_texture != 0) {
                            glDeleteTextures(1, &sec.logo_connector_texture);
                        }
                        // Create new texture
                        glGenTextures(1, &sec.logo_connector_texture);
                        glBindTexture(GL_TEXTURE_2D, sec.logo_connector_texture);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

                        sec.logo_image_path = path;
                        sec.logo_image_width = w;
                        sec.logo_image_height = h;

                        // Store image data for saving
                        sec.logo_image_data.assign(data, data + w * h * 4);

                        stbi_image_free(data);
                    }
                }
            }

            // Show image info
            if (sec.logo_connector_texture != 0) {
                ImGui::TextColored(ImVec4(0.5f, 0.8f, 0.5f, 1), "Image: %dx%d", sec.logo_image_width, sec.logo_image_height);

                // Clear logo button
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                if (ImGui::Button("Clear Logo", ImVec2(-1, 25))) {
                    if (sec.logo_connector_texture != 0) {
                        glDeleteTextures(1, &sec.logo_connector_texture);
                        sec.logo_connector_texture = 0;
                    }
                    sec.logo_image_path.clear();
                    sec.logo_image_data.clear();
                    sec.logo_image_width = 0;
                    sec.logo_image_height = 0;
                }
                ImGui::PopStyleColor();
            } else {
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "No logo uploaded");
            }

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Logo size
            ImGui::Text("Logo Size:");
            ImGui::PushItemWidth(120);
            ImGui::SliderFloat("Width##logo", &sec.logo_width, 50.0f, 500.0f, "%.0f");
            ImGui::SliderFloat("Height##logo", &sec.logo_height, 30.0f, 300.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Checkbox("Maintain Aspect Ratio", &sec.logo_maintain_aspect);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Logo alignment
            ImGui::Text("Alignment:");
            const char* alignOptions[] = {"Left", "Center", "Right"};
            ImGui::PushItemWidth(100);
            ImGui::Combo("##logoAlign", &sec.logo_alignment, alignOptions, 3);
            ImGui::PopItemWidth();

            // Padding
            ImGui::Text("Padding:");
            ImGui::PushItemWidth(100);
            ImGui::SliderFloat("##logoPad", &sec.logo_padding, 0.0f, 50.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Background color
            ImGui::Text("Background:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##logoBg", (float*)&sec.logo_bg_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "(set alpha > 0 to show)");

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Logo link
            ImGui::Text("Click Link (URL):");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##logoLink", sec.logo_link, sizeof(sec.logo_link));
            ImGui::PopItemWidth();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "(usually homepage URL)");
        }
        // Bullet Connector properties
        else if (sec.type == SEC_BULLET_CONNECTOR) {
            ImGui::Text("Bullet Points");
            ImGui::Separator();
            ImGui::Spacing();

            // Main heading
            ImGui::Text("Main Heading:");
            ImGui::PushItemWidth(-1);
            ImGui::InputTextMultiline("##bulletHeading", sec.bullet_main_heading, sizeof(sec.bullet_main_heading), ImVec2(-1, 50));
            ImGui::PopItemWidth();

            ImGui::Text("Footer Text:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##bulletFooter", sec.bullet_footer_text, sizeof(sec.bullet_footer_text));
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Colors
            ImGui::Text("Colors:");
            ImGui::Text("Heading:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##bulletHeadingClr", (float*)&sec.bullet_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Items:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##bulletItemClr", (float*)&sec.bullet_item_color, ImGuiColorEditFlags_NoInputs);

            // Sizes
            ImGui::PushItemWidth(120);
            ImGui::SliderFloat("Heading Size", &sec.bullet_heading_size, 0.5f, 2.0f, "%.1f");
            ImGui::SliderFloat("Heading Bold", &sec.bullet_heading_boldness, 0.0f, 3.0f, "%.1f");
            ImGui::SliderFloat("Item Size", &sec.bullet_item_size, 0.5f, 2.0f, "%.1f");
            ImGui::SliderFloat("Column Spacing", &sec.bullet_column_spacing, 10.0f, 100.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Columns management
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "COLUMNS");

            // Add column button
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Column", ImVec2(-1, 26))) {
                BulletColumn newCol;
                snprintf(newCol.subheading, sizeof(newCol.subheading), "Column %d", (int)sec.bullet_columns.size() + 1);
                sec.bullet_columns.push_back(newCol);
            }
            ImGui::PopStyleColor();

            // List columns
            static int selectedBulletCol = -1;
            if (!sec.bullet_columns.empty()) {
                ImGui::BeginChild("BulletColList", ImVec2(-1, 80), true);
                int colToDelete = -1;
                for (int i = 0; i < (int)sec.bullet_columns.size(); i++) {
                    ImGui::PushID(i);
                    BulletColumn& col = sec.bullet_columns[i];
                    bool isSelected = (selectedBulletCol == i);
                    char colLabel[300];
                    snprintf(colLabel, sizeof(colLabel), "%d. %s", i + 1, col.subheading);

                    // Delete button first (right side)
                    float contentWidth = ImGui::GetContentRegionAvail().x;
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + contentWidth - 25);
                    if (ImGui::SmallButton("X##del")) {
                        colToDelete = i;
                    }
                    ImGui::PopStyleColor();

                    // Selectable on same line (left side)
                    ImGui::SameLine();
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() - contentWidth + 5);
                    if (ImGui::Selectable(colLabel, isSelected, 0, ImVec2(contentWidth - 35, 0))) {
                        selectedBulletCol = i;
                    }
                    ImGui::PopID();
                }
                if (colToDelete >= 0) {
                    sec.bullet_columns.erase(sec.bullet_columns.begin() + colToDelete);
                    if (selectedBulletCol >= (int)sec.bullet_columns.size()) selectedBulletCol = -1;
                }
                ImGui::EndChild();

                // Edit selected column
                if (selectedBulletCol >= 0 && selectedBulletCol < (int)sec.bullet_columns.size()) {
                    BulletColumn& col = sec.bullet_columns[selectedBulletCol];

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.91f, 0.4f, 0.1f, 1), "Editing Column %d", selectedBulletCol + 1);
                    ImGui::Separator();

                    // Column subheading
                    ImGui::Text("Subheading:");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputText("##colSubheading", col.subheading, sizeof(col.subheading));
                    ImGui::PopItemWidth();

                    // Column style
                    ImGui::Text("Color:");
                    ImGui::SameLine();
                    ImGui::ColorEdit4("##colSubClr", (float*)&col.subheadingColor, ImGuiColorEditFlags_NoInputs);
                    ImGui::PushItemWidth(100);
                    ImGui::SliderFloat("Size##colSub", &col.subheadingSize, 0.5f, 2.0f, "%.1f");
                    ImGui::SliderFloat("Bold##colSub", &col.subheadingBoldness, 0.0f, 3.0f, "%.1f");
                    ImGui::PopItemWidth();

                    ImGui::Spacing();

                    // Bullet items
                    ImGui::Text("Bullet Items:");

                    // Add item button
                    static char newBulletItem[256] = "";
                    ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x - 60);
                    ImGui::InputText("##newItem", newBulletItem, sizeof(newBulletItem));
                    ImGui::PopItemWidth();
                    ImGui::SameLine();
                    if (ImGui::Button("Add", ImVec2(-1, 0)) && strlen(newBulletItem) > 0) {
                        col.bullet_items.push_back(newBulletItem);
                        newBulletItem[0] = '\0';
                    }

                    // List bullet items
                    ImGui::BeginChild("BulletItemsList", ImVec2(-1, 100), true);
                    int itemToDelete = -1;
                    for (int bi = 0; bi < (int)col.bullet_items.size(); bi++) {
                        ImGui::PushID(bi);
                        char itemBuf[256];
                        strncpy(itemBuf, col.bullet_items[bi].c_str(), sizeof(itemBuf) - 1);
                        itemBuf[sizeof(itemBuf) - 1] = '\0';
                        ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x - 30);
                        if (ImGui::InputText("##itemEdit", itemBuf, sizeof(itemBuf))) {
                            col.bullet_items[bi] = itemBuf;
                        }
                        ImGui::PopItemWidth();
                        ImGui::SameLine();
                        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                        if (ImGui::SmallButton("X")) {
                            itemToDelete = bi;
                        }
                        ImGui::PopStyleColor();
                        ImGui::PopID();
                    }
                    if (itemToDelete >= 0) {
                        col.bullet_items.erase(col.bullet_items.begin() + itemToDelete);
                    }
                    ImGui::EndChild();

                    // Apply to all columns button
                    ImGui::Spacing();
                    if (ImGui::Button("Apply Style to All Columns", ImVec2(-1, 26))) {
                        for (int i = 0; i < (int)sec.bullet_columns.size(); i++) {
                            if (i != selectedBulletCol) {
                                sec.bullet_columns[i].subheadingColor = col.subheadingColor;
                                sec.bullet_columns[i].subheadingSize = col.subheadingSize;
                                sec.bullet_columns[i].subheadingBoldness = col.subheadingBoldness;
                            }
                        }
                    }
                }
            }
        }
        // Icon properties
        else if (sec.type == SEC_ICON) {
            ImGui::Text("Icon Element");
            ImGui::Separator();
            ImGui::Spacing();

            // Current icon display and picker button
            ImGui::Text("Current Icon: %s", g_IconNames[sec.icon_type]);

            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.7f, 1.0f));
            if (ImGui::Button("Select Icon...", ImVec2(-1, 30))) {
                g_ShowIconPickerPopup = true;
                g_IconPickerTarget = &sec.icon_type;
            }
            ImGui::PopStyleColor();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Icon properties
            ImGui::Text("Icon Properties:");
            ImGui::PushItemWidth(-1);
            ImGui::SliderFloat("Size##iconSize", &sec.icon_size, 16.0f, 200.0f, "%.0f px");
            ImGui::SliderFloat("Stroke##iconStroke", &sec.icon_stroke_width, 1.0f, 10.0f, "%.1f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Text("Icon Color:");
            ImGui::ColorEdit4("##iconColor", (float*)&sec.icon_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

            ImGui::Spacing();
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##iconBgColor", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);
        }
        // Service Card Connector properties
        else if (sec.type == SEC_SERVICE_CARD_CONNECTOR) {
            ImGui::Text("Service Cards");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::PushItemWidth(120);
            ImGui::SliderInt("Cards per Row", &sec.service_cards_per_row, 1, 6);
            ImGui::SliderFloat("Spacing", &sec.service_card_spacing, 5.0f, 50.0f, "%.0f");
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Text("Background:");
            ImGui::ColorEdit4("##svcBgColor", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "CARDS");

            // Add card button
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            if (ImGui::Button("+ Add Card", ImVec2(-1, 26))) {
                ServiceCard newCard;
                snprintf(newCard.title, sizeof(newCard.title), "Service %d", (int)sec.service_cards.size() + 1);
                snprintf(newCard.badgeText, sizeof(newCard.badgeText), "CATEGORY");
                sec.service_cards.push_back(newCard);
            }
            ImGui::PopStyleColor();

            // List cards
            static int selectedServiceCard = -1;
            if (!sec.service_cards.empty()) {
                ImGui::BeginChild("ServiceCardList", ImVec2(-1, 80), true);
                int cardToDelete = -1;
                for (int i = 0; i < (int)sec.service_cards.size(); i++) {
                    ImGui::PushID(i);
                    ServiceCard& card = sec.service_cards[i];
                    bool isSelected = (selectedServiceCard == i);
                    char cardLabel[300];
                    snprintf(cardLabel, sizeof(cardLabel), "%d. %s", i + 1, card.title);

                    float contentWidth = ImGui::GetContentRegionAvail().x;
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + contentWidth - 25);
                    if (ImGui::SmallButton("X##del")) {
                        cardToDelete = i;
                    }
                    ImGui::PopStyleColor();

                    ImGui::SameLine();
                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() - contentWidth + 5);
                    if (ImGui::Selectable(cardLabel, isSelected, 0, ImVec2(contentWidth - 35, 0))) {
                        selectedServiceCard = i;
                    }
                    ImGui::PopID();
                }
                if (cardToDelete >= 0) {
                    sec.service_cards.erase(sec.service_cards.begin() + cardToDelete);
                    if (selectedServiceCard >= (int)sec.service_cards.size()) selectedServiceCard = -1;
                }
                ImGui::EndChild();

                // Edit selected card
                if (selectedServiceCard >= 0 && selectedServiceCard < (int)sec.service_cards.size()) {
                    ServiceCard& card = sec.service_cards[selectedServiceCard];

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.9f, 0.4f, 0.1f, 1), "Editing Card %d", selectedServiceCard + 1);
                    ImGui::Separator();

                    ImGui::Text("Title:");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputText("##cardTitle", card.title, sizeof(card.title));
                    ImGui::PopItemWidth();

                    ImGui::Text("Badge Text:");
                    ImGui::PushItemWidth(-1);
                    ImGui::InputText("##badgeText", card.badgeText, sizeof(card.badgeText));
                    ImGui::PopItemWidth();

                    ImGui::Text("Badge Color:");
                    ImGui::ColorEdit4("##badgeColor", (float*)&card.badgeColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::Text("Title Color:");
                    ImGui::ColorEdit4("##cardTitleColor", (float*)&card.titleColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::Text("Card Background:");
                    ImGui::ColorEdit4("##cardBgColor", (float*)&card.cardBgColor, ImGuiColorEditFlags_NoInputs);

                    ImGui::PushItemWidth(120);
                    ImGui::SliderFloat("Border Radius", &card.borderRadius, 0.0f, 30.0f, "%.0f");
                    ImGui::PopItemWidth();
                }
            }
        }
        // Glass Bar Connector properties
        else if (sec.type == SEC_GLASS_BAR_CONNECTOR) {
            ImGui::Text("Glass Bar");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Main Text:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##glassText", sec.glass_bar_text, sizeof(sec.glass_bar_text));
            ImGui::PopItemWidth();

            ImGui::Text("Highlight Text:");
            ImGui::PushItemWidth(-1);
            ImGui::InputText("##glassHighlight", sec.glass_bar_highlight, sizeof(sec.glass_bar_highlight));
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Text("Colors:");

            ImGui::Text("Text:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##glassTextClr", (float*)&sec.glass_bar_text_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SameLine();
            ImGui::Text("Highlight:");
            ImGui::SameLine();
            ImGui::ColorEdit4("##glassHighlightClr", (float*)&sec.glass_bar_highlight_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Text("Background:");
            ImGui::ColorEdit4("##glassBgClr", (float*)&sec.glass_bar_bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

            ImGui::Spacing();
            ImGui::Text("Style:");
            ImGui::PushItemWidth(150);
            ImGui::SliderFloat("Opacity", &sec.glass_bar_opacity, 0.0f, 1.0f, "%.2f");
            ImGui::SliderFloat("Border Radius", &sec.glass_bar_border_radius, 0.0f, 50.0f, "%.0f");
            ImGui::SliderFloat("Padding", &sec.glass_bar_padding, 5.0f, 50.0f, "%.0f");
            ImGui::PopItemWidth();
        }
        // Story Connector properties
        else if (sec.type == SEC_STORY_CONNECTOR) {
            ImGui::Text("Story Section");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Section Label:");
            ImGui::InputText("##storyLabel", sec.story_label, sizeof(sec.story_label));

            ImGui::Text("Heading:");
            ImGui::InputText("##storyHeading", sec.story_heading, sizeof(sec.story_heading));

            ImGui::Text("Heading Accent:");
            ImGui::InputText("##storyAccent", sec.story_heading_accent, sizeof(sec.story_heading_accent));

            ImGui::Spacing();
            ImGui::Text("Paragraphs:");
            for (int i = 0; i < 3; i++) {
                char label[32]; snprintf(label, sizeof(label), "##storyPara%d", i);
                ImGui::InputTextMultiline(label, sec.story_paragraphs[i], sizeof(sec.story_paragraphs[i]), ImVec2(-1, 60));
            }
            ImGui::SliderInt("Paragraph Count", &sec.story_paragraph_count, 0, 3);

            ImGui::Spacing();
            ImGui::Text("Feature Badges:");
            for (size_t i = 0; i < sec.story_badges.size() && i < 4; i++) {
                ImGui::PushID((int)i);
                ImGui::InputText("##badgeText", sec.story_badges[i].text, sizeof(sec.story_badges[i].text));
                ImGui::SameLine();
                ImGui::ColorEdit4("##badgeDot", (float*)&sec.story_badges[i].dotColor, ImGuiColorEditFlags_NoInputs);
                ImGui::PopID();
            }
            if (sec.story_badges.size() < 4 && ImGui::Button("+ Add Badge")) {
                sec.story_badges.push_back(StoryFeatureBadge());
            }

            ImGui::Spacing();
            ImGui::Text("Button:");
            ImGui::InputText("##storyBtn", sec.story_button_text, sizeof(sec.story_button_text));

            ImGui::Text("Stats Number:");
            ImGui::InputText("##storyStats", sec.story_stats_number, sizeof(sec.story_stats_number));

            ImGui::Spacing();
            ImGui::Text("Colors:");
            ImGui::ColorEdit4("Label", (float*)&sec.story_label_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Heading", (float*)&sec.story_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent", (float*)&sec.story_accent_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Text", (float*)&sec.story_text_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Button BG", (float*)&sec.story_button_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Stats BG", (float*)&sec.story_stats_bg, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "COLLAGE IMAGES");
            for (int i = 0; i < 3; i++) {
                ImGui::PushID(i + 1000);
                char imgLabel[32]; snprintf(imgLabel, sizeof(imgLabel), "Image %d:", i + 1);
                ImGui::Text("%s", imgLabel);
                if (sec.story_image_textures[i] != 0) {
                    ImGui::Image((ImTextureID)(intptr_t)sec.story_image_textures[i], ImVec2(80, 60));
                    ImGui::SameLine();
                    if (ImGui::Button("Remove")) {
                        glDeleteTextures(1, &sec.story_image_textures[i]);
                        sec.story_image_textures[i] = 0;
                        sec.story_images[i] = "";
                    }
                } else {
                    if (ImGui::Button("Browse...##storyImg")) {
                        std::string selectedPath = OpenImageFileDialog();
                        if (!selectedPath.empty()) {
                            int w, h, c;
                            unsigned char* data = stbi_load(selectedPath.c_str(), &w, &h, &c, 4);
                            if (data) {
                                GLuint tex;
                                glGenTextures(1, &tex);
                                glBindTexture(GL_TEXTURE_2D, tex);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                stbi_image_free(data);
                                sec.story_image_textures[i] = tex;
                                sec.story_images[i] = selectedPath;
                                sec.story_image_widths[i] = w;
                                sec.story_image_heights[i] = h;
                            }
                        }
                    }
                }
                ImGui::PopID();
            }
        }
        // Services Section Connector properties
        else if (sec.type == SEC_SERVICES_SECTION_CONNECTOR) {
            ImGui::Text("Services Section");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Section Label:");
            ImGui::InputText("##svcLabel", sec.services_label, sizeof(sec.services_label));

            ImGui::Text("Heading:");
            ImGui::InputText("##svcHeading", sec.services_heading, sizeof(sec.services_heading));

            ImGui::Text("Heading Accent:");
            ImGui::InputText("##svcAccent", sec.services_heading_accent, sizeof(sec.services_heading_accent));

            ImGui::Text("Subtitle:");
            ImGui::InputText("##svcSubtitle", sec.services_subtitle, sizeof(sec.services_subtitle));

            ImGui::SliderInt("Cards per Row", &sec.services_cards_per_row, 1, 4);
            ImGui::SliderFloat("Card Spacing", &sec.services_card_spacing, 10.0f, 50.0f, "%.0f");

            ImGui::Spacing();
            ImGui::Text("Colors:");
            ImGui::ColorEdit4("Label", (float*)&sec.services_label_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Heading", (float*)&sec.services_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent", (float*)&sec.services_accent_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Cards: %d", (int)sec.services_cards.size());
            if (ImGui::Button("+ Add Card") && sec.services_cards.size() < 9) {
                sec.services_cards.push_back(ServicesSectionCard());
            }
            static int selSvcCard = -1;
            for (size_t i = 0; i < sec.services_cards.size(); i++) {
                ImGui::PushID((int)i);
                char cardLabel[64]; snprintf(cardLabel, sizeof(cardLabel), "Card %d: %s", (int)i+1, sec.services_cards[i].title);
                if (ImGui::Selectable(cardLabel, selSvcCard == (int)i)) selSvcCard = (int)i;
                ImGui::PopID();
            }
            if (selSvcCard >= 0 && selSvcCard < (int)sec.services_cards.size()) {
                auto& card = sec.services_cards[selSvcCard];
                ImGui::InputText("Title", card.title, sizeof(card.title));
                ImGui::InputTextMultiline("Desc", card.description, sizeof(card.description), ImVec2(-1, 50));
                ImGui::SliderInt("Icon", &card.iconType, 0, ICON_COUNT - 1);
                ImGui::SameLine(); ImGui::Text("(%s)", g_IconNames[card.iconType]);
                ImGui::ColorEdit4("Icon BG", (float*)&card.iconBgColor, ImGuiColorEditFlags_NoInputs);
                ImGui::Text("Bullets:");
                for (int b = 0; b < 6; b++) {
                    char bLabel[16]; snprintf(bLabel, sizeof(bLabel), "##b%d", b);
                    ImGui::InputText(bLabel, card.bullets[b], sizeof(card.bullets[b]));
                }
                ImGui::SliderInt("Bullet Count", &card.bulletCount, 0, 6);
                ImGui::InputText("Link Text", card.linkText, sizeof(card.linkText));

                // Card Image
                ImGui::Spacing();
                ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "CARD IMAGE");
                if (card.textureID != 0) {
                    ImGui::Image((ImTextureID)(intptr_t)card.textureID, ImVec2(120, 80));
                    if (ImGui::Button("Remove Image##svc")) {
                        glDeleteTextures(1, &card.textureID);
                        card.textureID = 0;
                        card.imagePath = "";
                    }
                } else {
                    if (ImGui::Button("Browse...##svcImg")) {
                        std::string selectedPath = OpenImageFileDialog();
                        if (!selectedPath.empty()) {
                            int w, h, c;
                            unsigned char* data = stbi_load(selectedPath.c_str(), &w, &h, &c, 4);
                            if (data) {
                                GLuint tex;
                                glGenTextures(1, &tex);
                                glBindTexture(GL_TEXTURE_2D, tex);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                stbi_image_free(data);
                                card.textureID = tex;
                                card.imagePath = selectedPath;
                                card.imageWidth = w;
                                card.imageHeight = h;
                            }
                        }
                    }
                }

                if (ImGui::Button("Delete Card##svc")) {
                    sec.services_cards.erase(sec.services_cards.begin() + selSvcCard);
                    selSvcCard = -1;
                }
            }
        }
        // Clients Grid Connector properties
        else if (sec.type == SEC_CLIENTS_GRID_CONNECTOR) {
            ImGui::Text("Clients Grid");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Section Label:");
            ImGui::InputText("##cliLabel", sec.clients_label, sizeof(sec.clients_label));

            ImGui::Text("Heading:");
            ImGui::InputText("##cliHeading", sec.clients_heading, sizeof(sec.clients_heading));

            ImGui::Text("Heading Accent:");
            ImGui::InputText("##cliAccent", sec.clients_heading_accent, sizeof(sec.clients_heading_accent));

            ImGui::Text("Subtitle:");
            ImGui::InputText("##cliSubtitle", sec.clients_subtitle, sizeof(sec.clients_subtitle));

            ImGui::SliderInt("Items per Row", &sec.clients_per_row, 2, 6);
            ImGui::SliderFloat("Spacing", &sec.clients_card_spacing, 10.0f, 40.0f, "%.0f");

            ImGui::Spacing();
            ImGui::Text("Colors:");
            ImGui::ColorEdit4("Label", (float*)&sec.clients_label_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Heading", (float*)&sec.clients_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent", (float*)&sec.clients_accent_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Clients: %d", (int)sec.clients_items.size());
            if (ImGui::Button("+ Add Client") && sec.clients_items.size() < 12) {
                sec.clients_items.push_back(ClientItem());
            }
            static int selClient = -1;
            for (size_t i = 0; i < sec.clients_items.size(); i++) {
                ImGui::PushID((int)i);
                char cliLabel[64]; snprintf(cliLabel, sizeof(cliLabel), "%d: %s", (int)i+1, sec.clients_items[i].name);
                if (ImGui::Selectable(cliLabel, selClient == (int)i)) selClient = (int)i;
                ImGui::PopID();
            }
            if (selClient >= 0 && selClient < (int)sec.clients_items.size()) {
                auto& cli = sec.clients_items[selClient];
                ImGui::InputText("Name", cli.name, sizeof(cli.name));
                ImGui::InputText("Logo Text", cli.logoText, sizeof(cli.logoText));
                ImGui::Checkbox("Use Text Logo", &cli.useTextLogo);
                ImGui::ColorEdit4("Text Color", (float*)&cli.textColor, ImGuiColorEditFlags_NoInputs);
                ImGui::ColorEdit4("Card BG", (float*)&cli.cardBgColor, ImGuiColorEditFlags_NoInputs);
                if (ImGui::Button("Delete Client")) {
                    sec.clients_items.erase(sec.clients_items.begin() + selClient);
                    selClient = -1;
                }
            }
        }
        // Features Grid Connector properties
        else if (sec.type == SEC_FEATURES_GRID_CONNECTOR) {
            ImGui::Text("Features Grid");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Section Label:");
            ImGui::InputText("##featLabel", sec.features_label, sizeof(sec.features_label));

            ImGui::Text("Heading:");
            ImGui::InputText("##featHeading", sec.features_heading, sizeof(sec.features_heading));

            ImGui::Text("Heading Accent:");
            ImGui::InputText("##featAccent", sec.features_heading_accent, sizeof(sec.features_heading_accent));

            ImGui::Text("Subtitle:");
            ImGui::InputText("##featSubtitle", sec.features_subtitle, sizeof(sec.features_subtitle));

            ImGui::SliderInt("Cards per Row", &sec.features_cards_per_row, 1, 4);
            ImGui::SliderFloat("Spacing", &sec.features_card_spacing, 10.0f, 50.0f, "%.0f");

            ImGui::Spacing();
            ImGui::Text("Colors:");
            ImGui::ColorEdit4("Label", (float*)&sec.features_label_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Heading", (float*)&sec.features_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent", (float*)&sec.features_accent_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Feature Cards: %d", (int)sec.features_cards.size());
            if (ImGui::Button("+ Add Feature") && sec.features_cards.size() < 9) {
                sec.features_cards.push_back(FeatureCardItem());
            }
            static int selFeat = -1;
            for (size_t i = 0; i < sec.features_cards.size(); i++) {
                ImGui::PushID((int)i);
                char fLabel[64]; snprintf(fLabel, sizeof(fLabel), "%d: %s", (int)i+1, sec.features_cards[i].title);
                if (ImGui::Selectable(fLabel, selFeat == (int)i)) selFeat = (int)i;
                ImGui::PopID();
            }
            if (selFeat >= 0 && selFeat < (int)sec.features_cards.size()) {
                auto& feat = sec.features_cards[selFeat];
                ImGui::InputText("Title", feat.title, sizeof(feat.title));
                ImGui::InputTextMultiline("Desc", feat.description, sizeof(feat.description), ImVec2(-1, 50));
                ImGui::SliderInt("Icon", &feat.iconType, 0, ICON_COUNT - 1);
                ImGui::ColorEdit4("Icon BG", (float*)&feat.iconBgColor, ImGuiColorEditFlags_NoInputs);
                ImGui::Text("Checkmarks:");
                for (int c = 0; c < 6; c++) {
                    char cLabel[16]; snprintf(cLabel, sizeof(cLabel), "##c%d", c);
                    ImGui::InputText(cLabel, feat.checkmarks[c], sizeof(feat.checkmarks[c]));
                }
                ImGui::SliderInt("Checkmark Count", &feat.checkmarkCount, 0, 6);
                if (ImGui::Button("Delete Feature")) {
                    sec.features_cards.erase(sec.features_cards.begin() + selFeat);
                    selFeat = -1;
                }
            }
        }
        // Process Timeline Connector properties
        else if (sec.type == SEC_PROCESS_TIMELINE_CONNECTOR) {
            ImGui::Text("Process Timeline");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Section Label:");
            ImGui::InputText("##procLabel", sec.process_label, sizeof(sec.process_label));

            ImGui::Text("Heading:");
            ImGui::InputText("##procHeading", sec.process_heading, sizeof(sec.process_heading));

            ImGui::Text("Heading Accent:");
            ImGui::InputText("##procAccent", sec.process_heading_accent, sizeof(sec.process_heading_accent));

            ImGui::Text("Subtitle:");
            ImGui::InputText("##procSubtitle", sec.process_subtitle, sizeof(sec.process_subtitle));

            ImGui::Spacing();
            ImGui::Text("Colors:");
            ImGui::ColorEdit4("Label", (float*)&sec.process_label_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Heading", (float*)&sec.process_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent", (float*)&sec.process_accent_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Background", (float*)&sec.process_bg_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Line", (float*)&sec.process_line_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::Text("Steps: %d", (int)sec.process_steps.size());
            if (ImGui::Button("+ Add Step") && sec.process_steps.size() < 7) {
                sec.process_steps.push_back(ProcessStep());
            }
            static int selStep = -1;
            for (size_t i = 0; i < sec.process_steps.size(); i++) {
                ImGui::PushID((int)i);
                char sLabel[64]; snprintf(sLabel, sizeof(sLabel), "Step %d: %s", (int)i+1, sec.process_steps[i].title);
                if (ImGui::Selectable(sLabel, selStep == (int)i)) selStep = (int)i;
                ImGui::PopID();
            }
            if (selStep >= 0 && selStep < (int)sec.process_steps.size()) {
                auto& step = sec.process_steps[selStep];
                ImGui::InputText("Title", step.title, sizeof(step.title));
                ImGui::InputTextMultiline("Desc", step.description, sizeof(step.description), ImVec2(-1, 60));
                ImGui::SliderInt("Icon", &step.iconType, 0, ICON_COUNT - 1);
                ImGui::ColorEdit4("Icon BG", (float*)&step.iconBgColor, ImGuiColorEditFlags_NoInputs);
                ImGui::ColorEdit4("Number BG", (float*)&step.numberBgColor, ImGuiColorEditFlags_NoInputs);
                ImGui::ColorEdit4("Card BG", (float*)&step.cardBgColor, ImGuiColorEditFlags_NoInputs);
                if (ImGui::Button("Delete Step")) {
                    sec.process_steps.erase(sec.process_steps.begin() + selStep);
                    selStep = -1;
                }
            }
        }
        // Hero Section Connector properties
        else if (sec.type == SEC_HERO_SECTION_CONNECTOR) {
            ImGui::Text("Hero Section");
            ImGui::Separator();
            ImGui::Spacing();

            // Badge
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "BADGE");
            ImGui::InputText("Badge Text", sec.hero_badge_text, sizeof(sec.hero_badge_text));
            ImGui::SliderInt("Left Icon##badge", &sec.hero_badge_icon_left, 0, ICON_COUNT - 1);
            ImGui::SameLine(); ImGui::Text("(%s)", g_IconNames[sec.hero_badge_icon_left]);
            ImGui::SliderInt("Right Icon##badge", &sec.hero_badge_icon_right, 0, ICON_COUNT - 1);
            ImGui::SameLine(); ImGui::Text("(%s)", g_IconNames[sec.hero_badge_icon_right]);
            ImGui::ColorEdit4("Badge BG", (float*)&sec.hero_badge_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Badge Text", (float*)&sec.hero_badge_text_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Badge Icons", (float*)&sec.hero_badge_icon_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SliderFloat("Badge Radius", &sec.hero_badge_border_radius, 0.0f, 30.0f, "%.0f");

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "HEADING");
            ImGui::InputText("Heading", sec.hero_heading, sizeof(sec.hero_heading));
            ImGui::InputText("Heading Accent", sec.hero_heading_accent, sizeof(sec.hero_heading_accent));
            ImGui::ColorEdit4("Heading Color", (float*)&sec.hero_heading_color, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Accent Color", (float*)&sec.hero_accent_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "DESCRIPTION");
            ImGui::InputTextMultiline("##heroDesc", sec.hero_description, sizeof(sec.hero_description), ImVec2(-1, 80));
            ImGui::ColorEdit4("Description", (float*)&sec.hero_description_color, ImGuiColorEditFlags_NoInputs);

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "BUTTONS");
            ImGui::InputText("Primary Button", sec.hero_btn_primary_text, sizeof(sec.hero_btn_primary_text));
            ImGui::InputText("Primary Target", sec.hero_btn_primary_target, sizeof(sec.hero_btn_primary_target));
            ImGui::ColorEdit4("Primary BG", (float*)&sec.hero_btn_primary_bg, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Primary Text", (float*)&sec.hero_btn_primary_text_color, ImGuiColorEditFlags_NoInputs);

            ImGui::InputText("Secondary Button", sec.hero_btn_secondary_text, sizeof(sec.hero_btn_secondary_text));
            ImGui::InputText("Secondary Target", sec.hero_btn_secondary_target, sizeof(sec.hero_btn_secondary_target));
            ImGui::ColorEdit4("Secondary Border", (float*)&sec.hero_btn_secondary_border, ImGuiColorEditFlags_NoInputs);
            ImGui::ColorEdit4("Secondary Text", (float*)&sec.hero_btn_secondary_text_color, ImGuiColorEditFlags_NoInputs);
            ImGui::SliderFloat("Button Radius", &sec.hero_btn_border_radius, 0.0f, 30.0f, "%.0f");

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "FEATURE BADGES");
            ImGui::Text("Badges: %d", (int)sec.hero_feature_badges.size());
            if (ImGui::Button("+ Add Badge##hero") && sec.hero_feature_badges.size() < 6) {
                sec.hero_feature_badges.push_back(HeroFeatureBadge());
            }
            static int selHeroBadge = -1;
            for (size_t i = 0; i < sec.hero_feature_badges.size(); i++) {
                ImGui::PushID((int)i);
                char bLabel[64]; snprintf(bLabel, sizeof(bLabel), "%d: %s", (int)i+1, sec.hero_feature_badges[i].text);
                if (ImGui::Selectable(bLabel, selHeroBadge == (int)i)) selHeroBadge = (int)i;
                ImGui::PopID();
            }
            if (selHeroBadge >= 0 && selHeroBadge < (int)sec.hero_feature_badges.size()) {
                auto& badge = sec.hero_feature_badges[selHeroBadge];
                ImGui::InputText("Text##heroBadge", badge.text, sizeof(badge.text));
                ImGui::ColorEdit4("Check Color", (float*)&badge.checkColor, ImGuiColorEditFlags_NoInputs);
                if (ImGui::Button("Delete Badge##hero")) {
                    sec.hero_feature_badges.erase(sec.hero_feature_badges.begin() + selHeroBadge);
                    selHeroBadge = -1;
                }
            }

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "STATS");
            ImGui::Text("Stats: %d", (int)sec.hero_stats.size());
            if (ImGui::Button("+ Add Stat##hero") && sec.hero_stats.size() < 6) {
                sec.hero_stats.push_back(HeroStatItem());
            }
            static int selHeroStat = -1;
            for (size_t i = 0; i < sec.hero_stats.size(); i++) {
                ImGui::PushID((int)i + 100);
                char sLabel[64]; snprintf(sLabel, sizeof(sLabel), "%d: %s - %s", (int)i+1, sec.hero_stats[i].number, sec.hero_stats[i].label);
                if (ImGui::Selectable(sLabel, selHeroStat == (int)i)) selHeroStat = (int)i;
                ImGui::PopID();
            }
            if (selHeroStat >= 0 && selHeroStat < (int)sec.hero_stats.size()) {
                auto& stat = sec.hero_stats[selHeroStat];
                ImGui::SliderInt("Icon##heroStat", &stat.iconType, 0, ICON_COUNT - 1);
                ImGui::SameLine(); ImGui::Text("(%s)", g_IconNames[stat.iconType]);
                ImGui::InputText("Number##heroStat", stat.number, sizeof(stat.number));
                ImGui::InputText("Label##heroStat", stat.label, sizeof(stat.label));
                ImGui::ColorEdit4("Icon Color", (float*)&stat.iconColor, ImGuiColorEditFlags_NoInputs);
                ImGui::ColorEdit4("Number Color", (float*)&stat.numberColor, ImGuiColorEditFlags_NoInputs);
                ImGui::ColorEdit4("Label Color", (float*)&stat.labelColor, ImGuiColorEditFlags_NoInputs);
                if (ImGui::Button("Delete Stat##hero")) {
                    sec.hero_stats.erase(sec.hero_stats.begin() + selHeroStat);
                    selHeroStat = -1;
                }
            }

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.9f, 0.6f, 0.2f, 1), "BACKGROUND");
            ImGui::ColorEdit4("Section BG", (float*)&sec.hero_bg_color, ImGuiColorEditFlags_NoInputs);
        }
        // Regular section content
        else {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "CONTENT");
            ImGui::Separator();

            char tb[256], sb[256], cb[512];
            strncpy(tb, sec.title.c_str(), sizeof(tb) - 1);
            tb[sizeof(tb) - 1] = '\0';
            strncpy(sb, sec.subtitle.c_str(), sizeof(sb) - 1);
            sb[sizeof(sb) - 1] = '\0';
            strncpy(cb, sec.content.c_str(), sizeof(cb) - 1);
            cb[sizeof(cb) - 1] = '\0';
            ImGui::Text("Title");
            if (ImGui::InputText("##T", tb, sizeof(tb))) sec.title = tb;
            ImGui::Text("Subtitle");
            if (ImGui::InputText("##S", sb, sizeof(sb))) sec.subtitle = sb;
            if (sec.type == SEC_ABOUT || sec.type == SEC_FOOTER) {
                ImGui::Text("Content");
                if (ImGui::InputTextMultiline("##C", cb, sizeof(cb), ImVec2(-1, 50))) sec.content = cb;
            }
        }

        // Button
        if (sec.type == SEC_HERO || sec.type == SEC_CTA || sec.type == SEC_CONTACT) {
            char btb[128];
            strncpy(btb, sec.button_text.c_str(), sizeof(btb) - 1);
            btb[sizeof(btb) - 1] = '\0';
            ImGui::Text("Button Text");
            if (ImGui::InputText("##BT", btb, sizeof(btb))) sec.button_text = btb;
            ImGui::Text("Button Colors");
            ImGui::ColorEdit4("BG##BB", (float*)&sec.button_bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
            ImGui::SameLine();
            ImGui::ColorEdit4("Text##BT", (float*)&sec.button_text_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

            // Glass button option
            ImGui::Checkbox("Glass Button##GBT", &sec.button_glass_effect);
            if (sec.button_glass_effect) {
                ImGui::SameLine();
                ImGui::SetNextItemWidth(60);
                ImGui::SliderFloat("##GBO", &sec.button_glass_opacity, 0.1f, 0.6f, "%.2f");
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Glass Opacity");
                ImGui::SameLine();
                ImGui::ColorEdit4("##GBTint", (float*)&sec.button_glass_tint, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Glass Tint");
            }
        }

        // Contact Form Size Controls
        if (sec.type == SEC_CONTACT) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "CONTACT FORM SIZES");
            ImGui::Separator();

            ImGui::Text("Input Width:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##CIW", &sec.contact_input_width, 50.0f, 100.0f, "%.0f%%");

            ImGui::Text("Input Height:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##CIH", &sec.contact_input_height, 20.0f, 60.0f, "%.0fpx");

            ImGui::Text("Button Width:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##CBW", &sec.contact_button_width, 30.0f, 100.0f, "%.0f%%");

            ImGui::Text("Button Height:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##CBH", &sec.contact_button_height, 25.0f, 60.0f, "%.0fpx");

            ImGui::Text("Field Spacing:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##CFS", &sec.contact_field_spacing, 20.0f, 60.0f, "%.0fpx");
        }

        // Navigation
        if (sec.type == SEC_NAVBAR) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "NAVIGATION");
            ImGui::Separator();
            ImGui::Text("Nav Background & Text");
            ImGui::ColorEdit4("NavBG", (float*)&sec.nav_bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
            ImGui::SameLine();
            ImGui::ColorEdit4("NavTxt", (float*)&sec.nav_text_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

            // Logo Upload Section
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.9f, 1), "LOGO");
            ImGui::Separator();

            if (ImGui::Button("Upload Logo Image", ImVec2(-1, 35))) {
                std::string path = OpenFileDialog("Select logo image");
                if (!path.empty()) {
                    sec.logo_path = path;
                    ImageTexture imgTex = LoadTexture(path);
                    sec.logo_texture_id = imgTex.id;
                }
            }

            if (!sec.logo_path.empty()) {
                ImGui::TextColored(ImVec4(0.3f, 0.9f, 0.3f, 1), "‚úì Logo loaded");
                if (ImGui::Button("Remove Logo", ImVec2(-1, 25))) {
                    sec.logo_path = "";
                    sec.logo_texture_id = 0;
                }
            }

            ImGui::Text("Logo Size:");
            ImGui::SetNextItemWidth(200);
            ImGui::SliderFloat("##LogoSize", &sec.logo_size, 30.0f, 150.0f, "%.0fpx");

            ImGui::Text("Brand Text Position:");
            const char* positions[] = { "Side (Next to Logo)", "Above Logo", "Below Logo" };
            ImGui::SetNextItemWidth(200);
            ImGui::Combo("##BrandPos", &sec.brand_text_position, positions, 3);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Text("Menu Items");
            for (int i = 0; i < (int)sec.nav_items.size(); i++) {
                ImGui::PushID(i);

                // Label and color
                char lb[64];
                strncpy(lb, sec.nav_items[i].label.c_str(), sizeof(lb) - 1);
                lb[sizeof(lb) - 1] = '\0';
                ImGui::SetNextItemWidth(100);
                if (ImGui::InputText("##L", lb, sizeof(lb))) sec.nav_items[i].label = lb;
                ImGui::SameLine();
                ImGui::ColorEdit4("##NC", (float*)&sec.nav_items[i].text_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
                ImGui::SameLine();
                if (ImGui::Button("X", ImVec2(20, 0))) {
                    sec.nav_items.erase(sec.nav_items.begin() + i);
                    i--;
                    ImGui::PopID();
                    continue;
                }

                // Font Size Control
                ImGui::Text("  Size:");
                ImGui::SameLine();
                ImGui::SetNextItemWidth(120);
                ImGui::SliderFloat("##NFS", &sec.nav_items[i].font_size, 10, 60, "%.0fpx");

                // Font Weight Control
                ImGui::Text("  Weight:");
                ImGui::SameLine();
                ImGui::SetNextItemWidth(120);
                ImGui::SliderFloat("##NFW", &sec.nav_items[i].font_weight, 100, 1200, "%.0f");
                ImGui::SameLine();
                if (ImGui::Button("L##NL", ImVec2(20, 0))) sec.nav_items[i].font_weight = 300;
                ImGui::SameLine();
                if (ImGui::Button("N##NN", ImVec2(20, 0))) sec.nav_items[i].font_weight = 400;
                ImGui::SameLine();
                if (ImGui::Button("B##NB", ImVec2(20, 0))) sec.nav_items[i].font_weight = 700;
                ImGui::SameLine();
                if (ImGui::Button("U##NU", ImVec2(20, 0))) sec.nav_items[i].font_weight = 1100;

                ImGui::Separator();
                ImGui::PopID();
            }
            if (ImGui::Button("+ Add Menu Item", ImVec2(-1, 24))) {
                sec.nav_items.push_back({"Link", "#", "", "", sec.nav_text_color, sec.nav_font_size, sec.nav_font_weight});
            }
        }

        // Typography
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "TYPOGRAPHY");
        ImGui::Separator();

        // Title typography
        ImGui::Text("Title");
        ImGui::ColorEdit4("##TC", (float*)&sec.title_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

        // Font Size Control
        ImGui::Text("  Font Size:");
        ImGui::SetNextItemWidth(200);
        if (ImGui::SliderFloat("##TFS", &sec.title_font_size, 12, 150, "%.0f px")) {
            // Real-time update - no action needed, already updating sec.title_font_size
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##TFSI", &sec.title_font_size, 0, 0, "%.0f");
        if (sec.title_font_size < 12) sec.title_font_size = 12;
        if (sec.title_font_size > 150) sec.title_font_size = 150;

        // Font Weight Control
        ImGui::Text("  Font Weight:");
        ImGui::SetNextItemWidth(200);
        if (ImGui::SliderFloat("##TFW", &sec.title_font_weight, 100, 1200, "%.0f")) {
            // Real-time update
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##TFWI", &sec.title_font_weight, 0, 0, "%.0f");
        if (sec.title_font_weight < 100) sec.title_font_weight = 100;
        if (sec.title_font_weight > 1200) sec.title_font_weight = 1200;

        // Weight Presets
        ImGui::Text("  Quick:");
        ImGui::SameLine();
        if (ImGui::Button("Light##TL", ImVec2(45, 0))) sec.title_font_weight = 300;
        ImGui::SameLine();
        if (ImGui::Button("Normal##TN", ImVec2(50, 0))) sec.title_font_weight = 400;
        ImGui::SameLine();
        if (ImGui::Button("Bold##TB", ImVec2(40, 0))) sec.title_font_weight = 700;
        ImGui::SameLine();
        if (ImGui::Button("Black##TBL", ImVec2(45, 0))) sec.title_font_weight = 900;
        ImGui::SameLine();
        if (ImGui::Button("Ultra##TU", ImVec2(40, 0))) sec.title_font_weight = 1100;

        // Live Preview
        ImGui::Spacing();
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
        ImGui::BeginChild("##TitlePreview", ImVec2(0, 50), true);
        ImGui::PushStyleColor(ImGuiCol_Text, sec.title_color);
        // Scale font for preview (ImGui doesn't support custom font sizes easily, so show as text)
        std::string preview = sec.title.empty() ? "Title Preview" : sec.title;
        ImGui::SetCursorPosY(15);
        ImGui::TextWrapped("%s", preview.c_str());
        char info[64];
        snprintf(info, sizeof(info), "%.0fpx, Weight: %.0f", sec.title_font_size, sec.title_font_weight);
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.6f, 0.6f, 0.6f, 1.0f));
        ImGui::TextWrapped("%s", info);
        ImGui::PopStyleColor();
        ImGui::PopStyleColor();
        ImGui::EndChild();
        ImGui::PopStyleColor();
        ImGui::Spacing();

        // Subtitle typography
        ImGui::Text("Subtitle");
        ImGui::ColorEdit4("##SC", (float*)&sec.subtitle_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

        // Font Size Control
        ImGui::Text("  Font Size:");
        ImGui::SetNextItemWidth(200);
        ImGui::SliderFloat("##SFS", &sec.subtitle_font_size, 10, 100, "%.0f px");
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##SFSI", &sec.subtitle_font_size, 0, 0, "%.0f");
        if (sec.subtitle_font_size < 10) sec.subtitle_font_size = 10;
        if (sec.subtitle_font_size > 100) sec.subtitle_font_size = 100;

        // Font Weight Control
        ImGui::Text("  Font Weight:");
        ImGui::SetNextItemWidth(200);
        ImGui::SliderFloat("##SFW", &sec.subtitle_font_weight, 100, 1200, "%.0f");
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##SFWI", &sec.subtitle_font_weight, 0, 0, "%.0f");
        if (sec.subtitle_font_weight < 100) sec.subtitle_font_weight = 100;
        if (sec.subtitle_font_weight > 1200) sec.subtitle_font_weight = 1200;

        // Weight Presets
        ImGui::Text("  Quick:");
        ImGui::SameLine();
        if (ImGui::Button("Light##SL", ImVec2(45, 0))) sec.subtitle_font_weight = 300;
        ImGui::SameLine();
        if (ImGui::Button("Normal##SN", ImVec2(50, 0))) sec.subtitle_font_weight = 400;
        ImGui::SameLine();
        if (ImGui::Button("Bold##SB", ImVec2(40, 0))) sec.subtitle_font_weight = 700;
        ImGui::SameLine();
        if (ImGui::Button("Black##SBL", ImVec2(45, 0))) sec.subtitle_font_weight = 900;
        ImGui::SameLine();
        if (ImGui::Button("Ultra##SU", ImVec2(40, 0))) sec.subtitle_font_weight = 1100;

        // Live Preview
        ImGui::Spacing();
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
        ImGui::BeginChild("##SubtitlePreview", ImVec2(0, 45), true);
        ImGui::PushStyleColor(ImGuiCol_Text, sec.subtitle_color);
        std::string preview_sub = sec.subtitle.empty() ? "Subtitle Preview" : sec.subtitle;
        ImGui::SetCursorPosY(10);
        ImGui::TextWrapped("%s", preview_sub.c_str());
        char info_sub[64];
        snprintf(info_sub, sizeof(info_sub), "%.0fpx, Weight: %.0f", sec.subtitle_font_size, sec.subtitle_font_weight);
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.6f, 0.6f, 0.6f, 1.0f));
        ImGui::TextWrapped("%s", info_sub);
        ImGui::PopStyleColor();
        ImGui::PopStyleColor();
        ImGui::EndChild();
        ImGui::PopStyleColor();
        ImGui::Spacing();

        // Content typography with enhanced controls
        ImGui::Text("Content");
        ImGui::ColorEdit4("##CC", (float*)&sec.content_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

        // Font Size Control
        ImGui::Text("  Font Size:");
        ImGui::SetNextItemWidth(200);
        if (ImGui::SliderFloat("##CFS", &sec.content_font_size, 10, 80, "%.0f px")) {
            // Real-time update - no action needed
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##CFSI", &sec.content_font_size, 0, 0, "%.0f");
        if (sec.content_font_size < 10) sec.content_font_size = 10;
        if (sec.content_font_size > 80) sec.content_font_size = 80;

        // Font Weight Control
        ImGui::Text("  Font Weight:");
        ImGui::SetNextItemWidth(200);
        if (ImGui::SliderFloat("##CFW", &sec.content_font_weight, 100, 1200, "%.0f")) {
            // Real-time update
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(50);
        ImGui::InputFloat("##CFWI", &sec.content_font_weight, 0, 0, "%.0f");
        if (sec.content_font_weight < 100) sec.content_font_weight = 100;
        if (sec.content_font_weight > 1200) sec.content_font_weight = 1200;

        // Weight Presets
        ImGui::Text("  Presets:");
        ImGui::SameLine();
        if (ImGui::Button("Light##CL", ImVec2(45, 0))) sec.content_font_weight = 300;
        ImGui::SameLine();
        if (ImGui::Button("Normal##CN", ImVec2(50, 0))) sec.content_font_weight = 400;
        ImGui::SameLine();
        if (ImGui::Button("Bold##CB", ImVec2(40, 0))) sec.content_font_weight = 700;
        ImGui::SameLine();
        if (ImGui::Button("Black##CBL", ImVec2(45, 0))) sec.content_font_weight = 900;
        ImGui::SameLine();
        if (ImGui::Button("Ultra##CU", ImVec2(40, 0))) sec.content_font_weight = 1100;

        // Live Preview
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
        ImGui::BeginChild("##ContentPreview", ImVec2(0, 50), true);
        ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_Text, sec.content_color);
        std::string contentPreview = sec.content.empty() ? "Content Preview" : sec.content;
        ImGui::TextWrapped("%s", contentPreview.c_str());
        char contentInfo[64];
        snprintf(contentInfo, sizeof(contentInfo), "%.0fpx, Weight: %.0f", sec.content_font_size, sec.content_font_weight);
        ImGui::TextWrapped("%s", contentInfo);
        ImGui::PopStyleColor();
        ImGui::PopStyleColor();
        ImGui::EndChild();
        ImGui::PopStyleColor();
        ImGui::Spacing();

        // Button typography (for sections with buttons) - enhanced controls
        if (sec.type == SEC_HERO || sec.type == SEC_CTA || sec.type == SEC_CONTACT) {
            ImGui::Text("Button");
            ImGui::ColorEdit4("##BTC", (float*)&sec.button_text_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

            // Font Size Control
            ImGui::Text("  Font Size:");
            ImGui::SetNextItemWidth(200);
            if (ImGui::SliderFloat("##BFS", &sec.button_font_size, 10, 60, "%.0f px")) {
                // Real-time update - no action needed
            }
            ImGui::SameLine();
            ImGui::SetNextItemWidth(50);
            ImGui::InputFloat("##BFSI", &sec.button_font_size, 0, 0, "%.0f");
            if (sec.button_font_size < 10) sec.button_font_size = 10;
            if (sec.button_font_size > 60) sec.button_font_size = 60;

            // Font Weight Control
            ImGui::Text("  Font Weight:");
            ImGui::SetNextItemWidth(200);
            if (ImGui::SliderFloat("##BFW", &sec.button_font_weight, 100, 1200, "%.0f")) {
                // Real-time update
            }
            ImGui::SameLine();
            ImGui::SetNextItemWidth(50);
            ImGui::InputFloat("##BFWI", &sec.button_font_weight, 0, 0, "%.0f");
            if (sec.button_font_weight < 100) sec.button_font_weight = 100;
            if (sec.button_font_weight > 1200) sec.button_font_weight = 1200;

            // Weight Presets
            ImGui::Text("  Presets:");
            ImGui::SameLine();
            if (ImGui::Button("Light##BL", ImVec2(45, 0))) sec.button_font_weight = 300;
            ImGui::SameLine();
            if (ImGui::Button("Normal##BN", ImVec2(50, 0))) sec.button_font_weight = 400;
            ImGui::SameLine();
            if (ImGui::Button("Bold##BB", ImVec2(40, 0))) sec.button_font_weight = 700;
            ImGui::SameLine();
            if (ImGui::Button("Black##BBL", ImVec2(45, 0))) sec.button_font_weight = 900;
            ImGui::SameLine();
            if (ImGui::Button("Ultra##BU", ImVec2(40, 0))) sec.button_font_weight = 1100;

            // Live Preview
            ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
            ImGui::BeginChild("##ButtonPreview", ImVec2(0, 50), true);
            ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_Text, sec.button_text_color);
            std::string buttonPreview = sec.button_text.empty() ? "Button Preview" : sec.button_text;
            ImGui::TextWrapped("%s", buttonPreview.c_str());
            char buttonInfo[64];
            snprintf(buttonInfo, sizeof(buttonInfo), "%.0fpx, Weight: %.0f", sec.button_font_size, sec.button_font_weight);
            ImGui::TextWrapped("%s", buttonInfo);
            ImGui::PopStyleColor();
            ImGui::PopStyleColor();
            ImGui::EndChild();
            ImGui::PopStyleColor();
            ImGui::Spacing();
        }

        // Style
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "STYLE");
        ImGui::Separator();
        ImGui::Text("Background Color");
        ImGui::ColorEdit4("##BGC", (float*)&sec.bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
        ImGui::Text("Height");
        ImGui::SliderFloat("##H", &sec.height, 80, 800);

        // UNIVERSAL WIDTH & POSITION CONTROLS (for ALL sections)
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.3f, 1), "WIDTH & POSITION");
        ImGui::Separator();

        ImGui::Text("Width:");
        ImGui::SetNextItemWidth(200);
        ImGui::SliderFloat("##SecWidth", &sec.section_width_percent, 30.0f, 100.0f, "%.0f%%");
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("30%% = narrow, 50%% = half screen, 100%% = full width");
        }

        ImGui::Text("Horizontal Align:");
        const char* h_align_opts[] = {"Left", "Center", "Right"};
        ImGui::Combo("##SecHAlign", &sec.horizontal_align, h_align_opts, 3);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Position: Left side, Center, or Right side of canvas");
        }

        ImGui::Spacing();
        ImGui::Checkbox("Manual Y Position", &sec.use_manual_position);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Enable to place this section at a specific Y coordinate\n(allows side-by-side layouts)");
        }

        if (sec.use_manual_position) {
            ImGui::Text("Y Position:");
            ImGui::SetNextItemWidth(200);
            ImGui::DragFloat("##ManualY", &sec.y_position, 1.0f, 0.0f, 5000.0f, "%.0fpx");
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Vertical position from top of page (0 = top)");
            }
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.0f, 1), "Tip: Use same Y position for side-by-side sections!");
        }

        // Cards
        if ((sec.type == SEC_CARDS || sec.type == SEC_SERVICES || sec.type == SEC_FEATURES || sec.type == SEC_PRICING ||
             sec.type == SEC_TEAM || sec.type == SEC_TESTIMONIALS || sec.type == SEC_STATS)) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "CARD LAYOUT");
            ImGui::Separator();
            ImGui::Text("Card Size");
            ImGui::SetNextItemWidth(80);
            ImGui::DragFloat("Width##CW", &sec.card_width, 5, 150, 500, "%.0f");
            ImGui::SameLine();
            ImGui::SetNextItemWidth(80);
            ImGui::DragFloat("Height##CH", &sec.card_height, 5, 100, 500, "%.0f");
            ImGui::Text("Cards Per Row");
            ImGui::SetNextItemWidth(80);
            ImGui::DragInt("##CPR", &sec.cards_per_row, 1, 1, 6);

            ImGui::Spacing();
            ImGui::Text("Heading to Cards Spacing");
            ImGui::SetNextItemWidth(150);
            ImGui::SliderFloat("##HCSpacing", &sec.heading_to_cards_spacing, 10.0f, 150.0f, "%.0fpx");
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Adjust space between section heading and cards\n10px = Very close\n40px = Normal (default)\n100px = Very spacious");
            }

            if (!sec.items.empty()) {
                ImGui::Spacing();
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "ITEMS (%d)", (int)sec.items.size());
                ImGui::Separator();
                int deleteIndex = -1;
                for (int i = 0; i < (int)sec.items.size(); i++) {
                    ImGui::PushID(i);
                    auto& it = sec.items[i];
                    char itb[128], idb[256];
                    strncpy(itb, it.title.c_str(), sizeof(itb) - 1);
                    itb[sizeof(itb) - 1] = '\0';
                    strncpy(idb, it.description.c_str(), sizeof(idb) - 1);
                    idb[sizeof(idb) - 1] = '\0';
                    ImGui::Text("Item %d", i + 1);
                    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 25);
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1));
                    if (ImGui::Button("X##DEL", ImVec2(22, 18))) deleteIndex = i;
                    ImGui::PopStyleColor();
                    if (ImGui::InputText("##IT", itb, sizeof(itb))) it.title = itb;
                    if (ImGui::InputText("##ID", idb, sizeof(idb))) it.description = idb;
                    if (sec.type == SEC_PRICING) {
                        char pb[64];
                        strncpy(pb, it.price.c_str(), sizeof(pb) - 1);
                        pb[sizeof(pb) - 1] = '\0';
                        if (ImGui::InputText("##IP", pb, sizeof(pb))) it.price = pb;
                    }
                    ImGui::Text("Colors");
                    ImGui::ColorEdit4("BG##IB", (float*)&it.bg_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
                    ImGui::SameLine();
                    ImGui::ColorEdit4("Title##ITC", (float*)&it.title_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
                    ImGui::SameLine();
                    ImGui::ColorEdit4("Desc##IDC", (float*)&it.desc_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

                    // Font controls for Title
                    ImGui::Text("Title Font:");
                    ImGui::SetNextItemWidth(100);
                    ImGui::SliderFloat("Size##TFS", &it.title_font_size, 10, 80, "%.0fpx");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(100);
                    ImGui::SliderFloat("Weight##TFW", &it.title_font_weight, 100, 1200, "%.0f");
                    ImGui::SameLine();
                    if (ImGui::Button("L##TL", ImVec2(18, 0))) it.title_font_weight = 300;
                    ImGui::SameLine();
                    if (ImGui::Button("N##TN", ImVec2(18, 0))) it.title_font_weight = 400;
                    ImGui::SameLine();
                    if (ImGui::Button("B##TB", ImVec2(18, 0))) it.title_font_weight = 700;
                    ImGui::SameLine();
                    if (ImGui::Button("U##TU", ImVec2(18, 0))) it.title_font_weight = 1100;

                    // Font controls for Description
                    ImGui::Text("Desc Font:");
                    ImGui::SetNextItemWidth(100);
                    ImGui::SliderFloat("Size##DFS", &it.desc_font_size, 10, 60, "%.0fpx");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(100);
                    ImGui::SliderFloat("Weight##DFW", &it.desc_font_weight, 100, 1200, "%.0f");
                    ImGui::SameLine();
                    if (ImGui::Button("L##DL", ImVec2(18, 0))) it.desc_font_weight = 300;
                    ImGui::SameLine();
                    if (ImGui::Button("N##DN", ImVec2(18, 0))) it.desc_font_weight = 400;
                    ImGui::SameLine();
                    if (ImGui::Button("B##DB", ImVec2(18, 0))) it.desc_font_weight = 700;
                    ImGui::SameLine();
                    if (ImGui::Button("U##DU", ImVec2(18, 0))) it.desc_font_weight = 1100;

                    // Glass Effect
                    ImGui::Checkbox("Glass Effect##IGE", &it.glass_effect);
                    if (it.glass_effect) {
                        // Opacity and Tint
                        ImGui::Text("Opacity");
                        ImGui::SameLine();
                        ImGui::SetNextItemWidth(70);
                        ImGui::SliderFloat("##IGO", &it.glass_opacity, 0.1f, 0.8f, "%.2f");
                        ImGui::SameLine();
                        ImGui::ColorEdit4("Tint##IGT", (float*)&it.glass_tint, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);

                        // Border radius and width
                        ImGui::Text("Border");
                        ImGui::SameLine();
                        ImGui::SetNextItemWidth(50);
                        ImGui::DragFloat("R##IGBR", &it.glass_border_radius, 0.5f, 0, 50, "%.0f");
                        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Border Radius");
                        ImGui::SameLine();
                        ImGui::SetNextItemWidth(40);
                        ImGui::DragFloat("W##IGBW", &it.glass_border_width, 0.1f, 0, 5, "%.1f");
                        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Border Width");
                        ImGui::SameLine();
                        ImGui::ColorEdit4("##IGBC", (float*)&it.glass_border_color, ImGuiColorEditFlags_NoInputs);
                        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Border Color");

                        // Highlight/shine effect
                        ImGui::Checkbox("Highlight##IGH", &it.glass_highlight);
                        if (it.glass_highlight) {
                            ImGui::SameLine();
                            ImGui::SetNextItemWidth(60);
                            ImGui::SliderFloat("##IGHO", &it.glass_highlight_opacity, 0.1f, 0.6f, "%.2f");
                        }
                    }

                    // Modern Card Style Controls
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.3f, 0.6f, 1.0f, 1), "MODERN CARD STYLE");
                    const char* card_styles[] = {"Classic", "Service (Icon + Bullets)", "Portfolio (Thumbnail + Tags)"};
                    ImGui::SetNextItemWidth(200);
                    ImGui::Combo("Style##CS", &it.card_style, card_styles, 3);

                    // Service Card Controls (card_style == 1)
                    if (it.card_style == 1) {
                        ImGui::Text("Icon:");
                        ImGui::SameLine();
                        ImGui::ColorEdit4("Color##IC", (float*)&it.icon_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
                        ImGui::SameLine();
                        char icon_buf[32];
                        strncpy(icon_buf, it.icon_emoji.c_str(), sizeof(icon_buf) - 1);
                        icon_buf[sizeof(icon_buf) - 1] = '\0';
                        ImGui::SetNextItemWidth(80);
                        if (ImGui::InputText("Emoji##IE", icon_buf, sizeof(icon_buf))) it.icon_emoji = icon_buf;

                        // Quick icon buttons
                        ImGui::Text("Quick:");
                        ImGui::SameLine();
                        if (ImGui::Button("‚ö°##Q1", ImVec2(30, 0))) it.icon_emoji = "‚ö°";
                        ImGui::SameLine();
                        if (ImGui::Button("üåê##Q2", ImVec2(30, 0))) it.icon_emoji = "üåê";
                        ImGui::SameLine();
                        if (ImGui::Button("üì±##Q3", ImVec2(30, 0))) it.icon_emoji = "üì±";
                        ImGui::SameLine();
                        if (ImGui::Button("üíº##Q4", ImVec2(30, 0))) it.icon_emoji = "üíº";
                        ImGui::SameLine();
                        if (ImGui::Button("üöÄ##Q5", ImVec2(30, 0))) it.icon_emoji = "üöÄ";

                        // Bullet points editor
                        ImGui::Text("Bullet Points:");
                        if (it.bullet_points.size() < 3) {
                            it.bullet_points.resize(3, "");
                        }
                        for (int bp = 0; bp < 3; bp++) {
                            char bp_buf[128];
                            strncpy(bp_buf, it.bullet_points[bp].c_str(), sizeof(bp_buf) - 1);
                            bp_buf[sizeof(bp_buf) - 1] = '\0';
                            ImGui::PushID(bp);
                            ImGui::SetNextItemWidth(230);
                            if (ImGui::InputText("##BP", bp_buf, sizeof(bp_buf))) {
                                it.bullet_points[bp] = bp_buf;
                            }
                            ImGui::PopID();
                        }
                    }

                    // Portfolio Card Controls (card_style == 2)
                    if (it.card_style == 2) {
                        ImGui::Text("Category Badge:");
                        char badge_buf[64];
                        strncpy(badge_buf, it.category_badge.c_str(), sizeof(badge_buf) - 1);
                        badge_buf[sizeof(badge_buf) - 1] = '\0';
                        ImGui::SetNextItemWidth(200);
                        if (ImGui::InputText("##CB", badge_buf, sizeof(badge_buf))) {
                            it.category_badge = badge_buf;
                        }

                        // Tech tags editor
                        ImGui::Text("Tech Tags:");
                        if (it.tech_tags.size() < 3) {
                            it.tech_tags.resize(3, "");
                        }
                        for (int tt = 0; tt < 3; tt++) {
                            char tt_buf[64];
                            strncpy(tt_buf, it.tech_tags[tt].c_str(), sizeof(tt_buf) - 1);
                            tt_buf[sizeof(tt_buf) - 1] = '\0';
                            ImGui::PushID(100 + tt);
                            ImGui::SetNextItemWidth(150);
                            if (ImGui::InputText("##TT", tt_buf, sizeof(tt_buf))) {
                                it.tech_tags[tt] = tt_buf;
                            }
                            ImGui::PopID();
                        }
                    }

                    // Animation controls (for all modern cards)
                    if (it.card_style > 0) {
                        ImGui::Text("Animation:");
                        const char* anim_dirs[] = {"None", "Left to Right", "Right to Left"};
                        ImGui::SetNextItemWidth(150);
                        ImGui::Combo("Direction##AD", &it.anim_direction, anim_dirs, 3);
                        ImGui::SameLine();
                        ImGui::SetNextItemWidth(60);
                        ImGui::SliderFloat("Delay##ADL", &it.anim_delay, 0.0f, 1.0f, "%.2fs");

                        // Reset animation button
                        if (ImGui::Button("Reset Animation##RA", ImVec2(120, 0))) {
                            it.anim_progress = 0.0f;
                        }
                    }

                    ImGui::Separator();
                    ImGui::PopID();
                }
                if (deleteIndex >= 0 && sec.items.size() > 1) sec.items.erase(sec.items.begin() + deleteIndex);
            }
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.3f, 1));
            if (ImGui::Button("+ Add Card", ImVec2(-1, 26))) {
                sec.items.push_back({"New Card", "Description", "", "", "",
                    ImVec4(1,1,1,1), ImVec4(0.1f,0.1f,0.1f,1), ImVec4(0.4f,0.4f,0.4f,1), 20, 14, 600, 400, 0, 0, 0,
                    false, 0.25f, 10.0f, ImVec4(0.1f,0.15f,0.25f,1),
                    15.0f, 1.5f, ImVec4(1,1,1,0.2f), true, 0.3f});
            }
            ImGui::PopStyleColor();
        }

        // Glass Panels section in right panel
        if (!sec.glass_panels.empty()) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "GLASS PANELS (%d)", (int)sec.glass_panels.size());
            ImGui::Separator();

            // Find selected glass panel
            int selectedGlassPanel = -1;
            for (int gpi = 0; gpi < (int)sec.glass_panels.size(); gpi++) {
                if (sec.glass_panels[gpi].selected) {
                    selectedGlassPanel = gpi;
                    break;
                }
            }

            if (selectedGlassPanel >= 0) {
                WebSection::GlassPanel& gp = sec.glass_panels[selectedGlassPanel];
                ImGui::Text("Panel %d Settings", selectedGlassPanel + 1);

                // Text content
                char gpText[256];
                strncpy(gpText, gp.text.c_str(), sizeof(gpText) - 1);
                gpText[sizeof(gpText) - 1] = '\0';
                ImGui::Text("Text");
                if (ImGui::InputTextMultiline("##GPT", gpText, sizeof(gpText), ImVec2(-1, 60))) gp.text = gpText;

                // Position
                ImGui::Text("Position (X, Y)");
                ImGui::SetNextItemWidth(70);
                ImGui::DragFloat("##GPX", &gp.x, 1, 0, 1000, "%.0f");
                ImGui::SameLine();
                ImGui::SetNextItemWidth(70);
                ImGui::DragFloat("##GPY", &gp.y, 1, 0, 1000, "%.0f");

                // Size
                ImGui::Text("Size (W, H)");
                ImGui::SetNextItemWidth(70);
                ImGui::DragFloat("##GPW", &gp.width, 1, 50, 800, "%.0f");
                ImGui::SameLine();
                ImGui::SetNextItemWidth(70);
                ImGui::DragFloat("##GPH", &gp.height, 1, 30, 500, "%.0f");

                // Glass settings
                ImGui::Text("Glass Opacity");
                ImGui::SliderFloat("##GPO", &gp.opacity, 0.1f, 0.8f, "%.2f");

                ImGui::Text("Glass Tint");
                ImGui::ColorEdit4("##GPTint", (float*)&gp.tint, ImGuiColorEditFlags_NoInputs);

                ImGui::Text("Border Radius");
                ImGui::SliderFloat("##GPBR", &gp.border_radius, 0, 32, "%.0fpx");

                // Text settings
                ImGui::Text("Text Size & Color");
                ImGui::SetNextItemWidth(60);
                ImGui::DragFloat("##GPTS", &gp.text_size, 1, 10, 48, "%.0fpx");
                ImGui::SameLine();
                ImGui::ColorEdit4("##GPTC", (float*)&gp.text_color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
            } else {
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 0.7f), "Select a panel from left");
            }
        }

        // ========================================================================
        // IMAGES SECTION
        // ========================================================================
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "IMAGES");
        ImGui::Separator();

        // Background image upload - Available for all sections EXCEPT Hero and CTA
        // (Hero/CTA use animation images instead)
        if (sec.type != SEC_HERO && sec.type != SEC_CTA) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "BACKGROUND IMAGE");
            ImGui::Separator();
            if (ImGui::Button("Upload Background Image", ImVec2(-1, 25))) {
                std::string path = OpenFileDialog("Select background image (JPG, PNG, etc.)");
                if (!path.empty()) {
                    sec.background_image = path;
                    ImageTexture bgTex = LoadTexture(path);
                    sec.bg_texture_id = bgTex.id;
                    sec.use_bg_image = true;
                }
            }
            if (sec.use_bg_image && !sec.background_image.empty()) {
                ImGui::TextWrapped("Image: %s", sec.background_image.c_str());
                ImGui::Checkbox("Show Background", &sec.use_bg_image);
                if (sec.use_bg_image) {
                    ImGui::Text("Overlay Opacity:");
                    ImGui::SliderFloat("##BGOverlay", &sec.bg_overlay_opacity, 0.0f, 1.0f, "%.2f");
                    if (ImGui::IsItemHovered()) {
                        ImGui::SetTooltip("Add dark overlay on background (0=transparent, 1=dark)");
                    }
                }
                if (ImGui::Button("Remove Background", ImVec2(-1, 20))) {
                    sec.background_image = "";
                    sec.bg_texture_id = 0;
                    sec.use_bg_image = false;
                }
            }
        }

        // Hero Animation Images (for Hero and CTA sections only)
        if (sec.type == SEC_HERO || sec.type == SEC_CTA) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.8f, 0.5f, 1), "HERO ANIMATION (Slideshow)");
            ImGui::Separator();

            ImGui::Checkbox("Enable Hero Animation", &sec.enable_hero_animation);

            if (sec.enable_hero_animation) {
                ImGui::Text("Animation Speed (seconds per image):");
                ImGui::SetNextItemWidth(200);
                ImGui::SliderFloat("##AnimSpeed", &sec.hero_animation_speed, 1.0f, 10.0f, "%.1fs");

                ImGui::Spacing();
                ImGui::Text("Animation Images (%d images)", (int)sec.hero_animation_images.size());

                if (ImGui::Button("Add Images to Animation", ImVec2(-1, 30))) {
                    std::vector<std::string> paths = OpenMultipleFilesDialog();
                    for (const auto& path : paths) {
                        sec.hero_animation_images.push_back(path);
                        ImageTexture tex = LoadTexture(path);
                        sec.hero_animation_texture_ids.push_back(tex.id);
                    }
                    // Reset animation when images are added
                    sec.current_animation_frame = 0;
                    sec.animation_timer = 0.0f;
                }

                if (!sec.hero_animation_images.empty()) {
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Manage Animation Images:");

                    for (int i = 0; i < (int)sec.hero_animation_images.size(); i++) {
                        ImGui::PushID(i);
                        ImGui::BulletText("Image %d", i + 1);
                        ImGui::SameLine(ImGui::GetContentRegionAvail().x - 25);
                        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.3f, 0.3f, 1));
                        if (ImGui::Button("X", ImVec2(22, 18))) {
                            sec.hero_animation_images.erase(sec.hero_animation_images.begin() + i);
                            if (i < (int)sec.hero_animation_texture_ids.size()) {
                                sec.hero_animation_texture_ids.erase(sec.hero_animation_texture_ids.begin() + i);
                            }
                            i--;
                            // Reset animation frame if needed
                            if (sec.current_animation_frame >= (int)sec.hero_animation_images.size()) {
                                sec.current_animation_frame = 0;
                            }
                        }
                        ImGui::PopStyleColor();
                        ImGui::PopID();
                    }

                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "Tip: You can add 4, 6, 8, or any number of images!");
                }
            }
        }

        // Gallery images upload (for Gallery section)
        if (sec.type == SEC_GALLERY) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "GALLERY CONTROLS");
            ImGui::Separator();

            // Image Size Controls (always visible)
            ImGui::Text("Image Box Size");
            ImGui::SliderFloat("Width", &sec.card_width, 200.0f, 1200.0f, "%.0fpx");
            ImGui::SliderFloat("Height", &sec.card_height, 200.0f, 1200.0f, "%.0fpx");
            ImGui::SliderFloat("Spacing", &sec.card_spacing, 10.0f, 80.0f, "%.0fpx");

            ImGui::Spacing();
            ImGui::Text("Gallery Images (%d)", (int)sec.gallery_images.size());
            if (ImGui::Button("Add Images to Gallery", ImVec2(-1, 25))) {
                std::vector<std::string> paths = OpenMultipleFilesDialog();
                for (const auto& path : paths) {
                    sec.gallery_images.push_back(path);
                    ImageTexture tex = LoadTexture(path);
                    sec.gallery_texture_ids.push_back(tex.id);
                }
            }
            if (!sec.gallery_images.empty()) {
                ImGui::Spacing();
                ImGui::Text("Gallery Layout");
                ImGui::SliderInt("Columns", &sec.gallery_columns, 1, 6);
                ImGui::SliderFloat("Gallery Spacing", &sec.gallery_spacing, 5.0f, 50.0f, "%.0fpx");
                ImGui::Checkbox("Lightbox Effect", &sec.gallery_lightbox);

                ImGui::Spacing();
                ImGui::Text("Manage Images:");
                for (int i = 0; i < (int)sec.gallery_images.size(); i++) {
                    ImGui::PushID(i);
                    ImGui::BulletText("Image %d", i + 1);
                    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 25);
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1));
                    if (ImGui::Button("X", ImVec2(22, 18))) {
                        sec.gallery_images.erase(sec.gallery_images.begin() + i);
                        if (i < (int)sec.gallery_texture_ids.size()) {
                            sec.gallery_texture_ids.erase(sec.gallery_texture_ids.begin() + i);
                        }
                        i--;
                    }
                    ImGui::PopStyleColor();
                    ImGui::PopID();
                }
            }
        }

        // Section image (for other sections)
        if (sec.type != SEC_HERO && sec.type != SEC_CTA && sec.type != SEC_GALLERY) {
            ImGui::Text("Section Image");
            if (ImGui::Button("Upload Section Image", ImVec2(-1, 25))) {
                std::string path = OpenFileDialog("Select section image");
                if (!path.empty()) {
                    sec.section_image = path;
                    ImageTexture imgTex = LoadTexture(path);
                    sec.img_texture_id = imgTex.id;
                }
            }
            if (!sec.section_image.empty()) {
                ImGui::TextWrapped("Current: %s", sec.section_image.c_str());
                if (ImGui::Button("Remove Image", ImVec2(-1, 20))) {
                    sec.section_image = "";
                    sec.img_texture_id = 0;
                }
            }
        }

        // ========================================================================
        // MOVEABLE IMAGES SECTION - REMOVED PER USER REQUEST
        // ========================================================================
        // (Feature hidden from UI but data structure preserved for backward compatibility)

        // ========================================================================
        // ANIMATION SECTION
        // ========================================================================
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "ANIMATION");
        ImGui::Separator();

        ImGui::Text("Animation Type");
        int anim_idx = (int)sec.animation_type;
        if (ImGui::Combo("##AnimType", &anim_idx, g_AnimationNames, IM_ARRAYSIZE(g_AnimationNames))) {
            sec.animation_type = (AnimationType)anim_idx;
        }

        if (sec.animation_type != ANIM_NONE) {
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.3f, 1), "‚úì Animation Active");
            ImGui::Spacing();

            // Different UI for carousel vs. other animations
            if (sec.animation_type == ANIM_CAROUSEL) {
                ImGui::Text("Scroll Speed");
                ImGui::SliderFloat("##AnimDur", &sec.animation_duration, 1.0f, 20.0f, "%.1fs");
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Time for complete scroll cycle\n1s = very fast, 20s = very slow");
                }

                ImGui::Spacing();
                ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.3f, 1), "‚Ñπ Carousel Mode:");
                ImGui::Text("  ‚Ä¢ All cards scroll together");
                ImGui::Text("  ‚Ä¢ Right to left continuously");
                ImGui::Text("  ‚Ä¢ Seamless infinite loop");
                if (sec.items.size() > 0) {
                    ImGui::Text("  ‚Ä¢ %d cards in carousel", (int)sec.items.size());
                }
            } else {
                ImGui::Text("Card Animation Duration");
                ImGui::SliderFloat("##AnimDur", &sec.animation_duration, 0.1f, 30.0f, "%.1fs");
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("How long each card takes to animate\n0.1s = very fast, 30s = very slow");
                }

                ImGui::Text("Stagger Delay (between cards)");
                ImGui::SliderFloat("##StaggerDelay", &sec.card_stagger_delay, 0.05f, 3.0f, "%.2fs");
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Time delay before next card starts animating\n0.05s = almost together, 3s = slow sequence");
                }

                ImGui::Text("Start Delay (seconds)");
                ImGui::SliderFloat("##AnimDelay", &sec.animation_delay, 0.0f, 10.0f, "%.1fs");
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Wait before starting first card animation");
                }

                ImGui::Checkbox("Continuous Loop", &sec.animation_repeat);
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Cards will animate continuously in sequence\nNO sudden restart - smooth cycle!");
                }

                // Show animation preview info
                if (sec.items.size() > 0) {
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.8f, 1), "Card Sequence Info:");
                    float totalTime = sec.animation_duration + (sec.items.size() * sec.card_stagger_delay);
                    ImGui::Text("  ‚Ä¢ %d cards animate one by one", (int)sec.items.size());
                    ImGui::Text("  ‚Ä¢ %.2fs delay between each card", sec.card_stagger_delay);
                    ImGui::Text("  ‚Ä¢ Total cycle: %.1f seconds", totalTime);
                }
            }

            ImGui::Spacing();
            if (ImGui::Button("Reset Animation", ImVec2(-1, 25))) {
                // Reset animation states
                AnimationEngine::ResetAllAnimations();
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Restart animation from beginning");
            }
        }

        // ========================================================================
        // TEXT EDITOR SECTION
        // ========================================================================
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "TEXT EDITOR");
        ImGui::Separator();

        char rich_text[2048];
        strncpy(rich_text, sec.content.c_str(), sizeof(rich_text) - 1);
        rich_text[sizeof(rich_text) - 1] = '\0';
        ImGui::Text("Rich Text Content");
        if (ImGui::InputTextMultiline("##RichText", rich_text, sizeof(rich_text),
                                       ImVec2(-1, 150),
                                       ImGuiInputTextFlags_AllowTabInput)) {
            sec.content = rich_text;
        }

        // Text formatting helpers
        if (ImGui::Button("Bold", ImVec2(60, 20))) {
            std::string wrapped = "<b>" + sec.content + "</b>";
            if (wrapped.length() < sizeof(rich_text)) sec.content = wrapped;
        }
        ImGui::SameLine();
        if (ImGui::Button("Italic", ImVec2(60, 20))) {
            std::string wrapped = "<i>" + sec.content + "</i>";
            if (wrapped.length() < sizeof(rich_text)) sec.content = wrapped;
        }
        ImGui::SameLine();
        if (ImGui::Button("Underline", ImVec2(70, 20))) {
            std::string wrapped = "<u>" + sec.content + "</u>";
            if (wrapped.length() < sizeof(rich_text)) sec.content = wrapped;
        }

        ImGui::Spacing();
        ImGui::Spacing();

        // Copy/Paste buttons
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "COPY / PASTE");
        ImGui::Separator();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.5f, 0.7f, 1));
        if (ImGui::Button("Copy Section (Ctrl+C)", ImVec2(-1, 26))) {
            g_CopiedSection = sec;  // Deep copy
            g_HasCopiedSection = true;
        }
        ImGui::PopStyleColor();

        if (g_HasCopiedSection) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1));
            if (ImGui::Button("Paste Section (Ctrl+V)", ImVec2(-1, 26))) {
                WebSection newSection = g_CopiedSection;
                newSection.id = g_NextSectionId++;
                newSection.x_position += 30;
                newSection.y_position += 30;
                newSection.z_index = (int)g_Sections.size();
                for (auto& s : g_Sections) s.selected = false;
                newSection.selected = true;
                g_Sections.push_back(newSection);
                g_SelectedSectionIndex = (int)g_Sections.size() - 1;
            }
            ImGui::PopStyleColor();
        } else {
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "(No section copied)");
        }

        ImGui::Spacing();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1));
        if (ImGui::Button("Delete Section", ImVec2(-1, 28))) {
            g_Sections.erase(g_Sections.begin() + g_SelectedSectionIndex);
            g_SelectedSectionIndex = std::min(g_SelectedSectionIndex, (int)g_Sections.size() - 1);
        }
        ImGui::PopStyleColor();
        ImGui::End();
    }
    } // end of else block for non-Figma mode

    // Export success
    if (g_ShowExportSuccess) {
        g_ExportSuccessTimer -= io.DeltaTime;
        if (g_ExportSuccessTimer <= 0) g_ShowExportSuccess = false;
        else {
            ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x / 2 - 150, io.DisplaySize.y - 80));
            ImGui::SetNextWindowSize(ImVec2(300, 50));
            ImGui::Begin("##Exp", nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);
            ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.3f, 1), "Exported ImGui Website!");
            ImGui::Text("%s", g_ExportPath.c_str());
            ImGui::End();
        }
    }

    // Template Gallery
    static int g_TemplateToDelete = -1;
    static std::string g_TemplateToDeleteName = "";
    static bool g_OpenDeletePopup = false;

    if (g_ShowTemplateGallery) {
        ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x / 2 - 400, io.DisplaySize.y / 2 - 300), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSize(ImVec2(800, 600), ImGuiCond_FirstUseEver);
        ImGui::Begin("Template Gallery", &g_ShowTemplateGallery);

        ImGui::TextColored(ImVec4(0.3f, 0.5f, 0.8f, 1), "Choose a template to start with:");
        ImGui::Separator();
        ImGui::Spacing();

        // Open delete popup if flagged (must be done outside PushID scope)
        if (g_OpenDeletePopup) {
            ImGui::OpenPopup("Confirm Delete Template");
            g_OpenDeletePopup = false;
        }

        // Delete confirmation popup (must be at window level, not inside loop)
        if (ImGui::BeginPopupModal("Confirm Delete Template", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
            ImGui::Text("Are you sure you want to delete template:");
            ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.5f, 1), "\"%s\"?", g_TemplateToDeleteName.c_str());
            ImGui::Spacing();
            ImGui::Text("This action cannot be undone.");
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            if (ImGui::Button("Delete", ImVec2(120, 30))) {
                // Delete from database
                if (g_UseDatabase && g_DBConnection && g_TemplateToDelete >= 0 && g_TemplateToDelete < (int)g_AvailableTemplates.size()) {
                    std::string templateName = g_AvailableTemplates[g_TemplateToDelete].name;

                    // Get template ID first
                    std::string query = "SELECT id FROM templates WHERE template_name='" + SQLEscape(templateName) + "'";
                    PGresult* result = PQexec(g_DBConnection, query.c_str());
                    if (PQresultStatus(result) == PGRES_TUPLES_OK && PQntuples(result) > 0) {
                        int templateId = atoi(PQgetvalue(result, 0, 0));
                        PQclear(result);

                        // Delete figma_layers first (foreign key constraint)
                        query = "DELETE FROM figma_layers WHERE template_id=" + std::to_string(templateId);
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Delete sections
                        query = "DELETE FROM sections WHERE template_id=" + std::to_string(templateId);
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        // Delete template
                        query = "DELETE FROM templates WHERE id=" + std::to_string(templateId);
                        result = PQexec(g_DBConnection, query.c_str());
                        PQclear(result);

                        printf("[Template Gallery] Deleted template: %s (ID: %d)\n", templateName.c_str(), templateId);

                        // Refresh template list
                        LoadAvailableTemplates();
                    } else {
                        PQclear(result);
                    }
                }
                g_TemplateToDelete = -1;
                g_TemplateToDeleteName = "";
                ImGui::CloseCurrentPopup();
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 30))) {
                g_TemplateToDelete = -1;
                g_TemplateToDeleteName = "";
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }

        // Display templates in a grid
        int columns = 3;
        float buttonWidth = (800 - 40) / columns - 10;

        if (g_AvailableTemplates.empty()) {
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "No templates found.");
            ImGui::Text("Create a website and click 'Save Template' to save it.");
        } else {
            for (size_t i = 0; i < g_AvailableTemplates.size(); i++) {
                const auto& tmpl = g_AvailableTemplates[i];

                ImGui::PushID(i);
                ImGui::BeginGroup();

                // Template card/button
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.3f, 0.4f, 1));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.4f, 0.6f, 1));
                if (ImGui::Button(tmpl.name.c_str(), ImVec2(buttonWidth - 25, 80))) {
                    if (LoadTemplate(tmpl.filename)) {
                        g_ShowTemplateGallery = false;
                    }
                }
                ImGui::PopStyleColor(2);

                // Delete button (small X on same line)
                ImGui::SameLine();
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.3f, 0.3f, 1));
                if (ImGui::Button("X", ImVec2(20, 80))) {
                    g_TemplateToDelete = i;
                    g_TemplateToDeleteName = tmpl.name;
                    g_OpenDeletePopup = true;  // Flag to open popup on next frame
                }
                ImGui::PopStyleColor(2);

                // Description
                ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + buttonWidth);
                ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "%s", tmpl.description.c_str());
                ImGui::PopTextWrapPos();

                // Date
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "%s", tmpl.created_date.c_str());

                ImGui::EndGroup();
                ImGui::PopID();

                // Layout in columns
                if ((i + 1) % columns != 0 && i < g_AvailableTemplates.size() - 1) {
                    ImGui::SameLine();
                }
            }
        }

        ImGui::Spacing();
        ImGui::Separator();
        if (ImGui::Button("Close", ImVec2(120, 30))) {
            g_ShowTemplateGallery = false;
        }

        ImGui::End();
    }

    // Save Template Dialog
    if (g_ShowSaveTemplate) {
        ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x / 2 - 250, io.DisplaySize.y / 2 - 150));
        ImGui::SetNextWindowSize(ImVec2(500, 300));
        ImGui::Begin("Save Template", &g_ShowSaveTemplate);

        ImGui::TextColored(ImVec4(0.3f, 0.5f, 0.8f, 1), "Save current design as a template");
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::Text("Template Name:");
        ImGui::SetNextItemWidth(-1);
        ImGui::InputText("##TemplateName", g_TemplateNameBuffer, sizeof(g_TemplateNameBuffer));

        ImGui::Spacing();
        ImGui::Text("Description:");
        ImGui::SetNextItemWidth(-1);
        ImGui::InputTextMultiline("##TemplateDesc", g_TemplateDescBuffer, sizeof(g_TemplateDescBuffer), ImVec2(-1, 100));

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        bool canSave = strlen(g_TemplateNameBuffer) > 0;

        if (!canSave) {
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
        }

        if (ImGui::Button("Save Template", ImVec2(150, 35)) && canSave) {
            if (SaveTemplate(g_TemplateNameBuffer, g_TemplateDescBuffer)) {
                g_ShowSaveTemplate = false;
                // Show success message
                g_ShowExportSuccess = true;
                g_ExportSuccessTimer = 2.0f;
                g_ExportPath = "Template saved: " + std::string(g_TemplateNameBuffer);
            }
        }

        if (!canSave) {
            ImGui::PopStyleVar();
        }

        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(100, 35))) {
            g_ShowSaveTemplate = false;
        }

        if (!canSave) {
            ImGui::TextColored(ImVec4(0.8f, 0.3f, 0.3f, 1), "Please enter a template name");
        }

        ImGui::End();
    }

    // ==================== SAVE TEMPLATE POPUP (Global - Unified Save) ====================
    if (g_ShowSaveImGuiTemplatePopup) {
        static char templateSaveName[256] = "";
        static bool nameInitialized = false;

        // Initialize name from project name once
        if (!nameInitialized) {
            if (!g_FigmaProject.name.empty()) {
                strncpy(templateSaveName, g_FigmaProject.name.c_str(), sizeof(templateSaveName));
            } else if (!g_ProjectName.empty()) {
                strncpy(templateSaveName, g_ProjectName.c_str(), sizeof(templateSaveName));
            }
            nameInitialized = true;
        }

        ImGui::SetNextWindowSize(ImVec2(400, 160), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

        if (ImGui::Begin("Save Template", &g_ShowSaveImGuiTemplatePopup, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize)) {
            ImGui::TextColored(ImVec4(0.2f, 0.8f, 0.4f, 1), "Save your design to database");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("Template Name:");
            ImGui::SetNextItemWidth(-1);
            ImGui::InputText("##SaveTemplateName", templateSaveName, sizeof(templateSaveName));

            ImGui::Spacing();
            // Show sections count for Normal mode, layers for Figma mode
            if (!g_FigmaMode && !g_Sections.empty()) {
                ImGui::TextDisabled("Sections: %zu", g_Sections.size());
            } else if (!g_FigmaProject.layers.empty()) {
                ImGui::TextDisabled("Layers: %zu", g_FigmaProject.layers.size());
            }

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // Save button (green)
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.7f, 0.4f, 1.0f));
            if (ImGui::Button("Save", ImVec2(120, 30))) {
                if (strlen(templateSaveName) > 0) {
                    // Save everything to database (both templates/sections AND imgui_templates)
                    bool saved = false;

                    // Always save to templates/sections table first (for Template Gallery)
                    if (!g_FigmaMode && !g_Sections.empty()) {
                        saved = SaveTemplate(templateSaveName, "User designed template");
                    }

                    // Also save to imgui_templates (unified save)
                    if (SaveAsImGuiTemplate(templateSaveName)) {
                        saved = true;
                    }

                    if (saved) {
                        printf("[Save] Template '%s' saved to database!\n", templateSaveName);
                        templateSaveName[0] = '\0';
                        nameInitialized = false;
                        g_ShowSaveImGuiTemplatePopup = false;
                        // Refresh template lists
                        LoadAvailableTemplates();
                        g_ImGuiTemplatesList = GetImGuiTemplates();
                    }
                }
            }
            ImGui::PopStyleColor(2);

            ImGui::SameLine();

            if (ImGui::Button("Cancel", ImVec2(100, 30))) {
                templateSaveName[0] = '\0';
                nameInitialized = false;
                g_ShowSaveImGuiTemplatePopup = false;
            }
        }
        ImGui::End();
    }

    // ==================== COPY TEMPLATE POPUP ====================
    if (g_ShowCopyTemplatePopup) {
        static char copyTemplateName[256] = "";
        static bool copyNameInitialized = false;

        // Initialize name with current project name + " - Copy"
        if (!copyNameInitialized) {
            snprintf(copyTemplateName, sizeof(copyTemplateName), "%s - Copy", g_ProjectName.c_str());
            copyNameInitialized = true;
        }

        ImGui::SetNextWindowSize(ImVec2(400, 180), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

        if (ImGui::Begin("Copy Template", &g_ShowCopyTemplatePopup, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize)) {
            ImGui::TextColored(ImVec4(0.8f, 0.5f, 0.2f, 1), "Create a copy of current template");
            ImGui::Separator();
            ImGui::Spacing();

            ImGui::Text("New Template Name:");
            ImGui::SetNextItemWidth(-1);
            ImGui::InputText("##CopyTemplateName", copyTemplateName, sizeof(copyTemplateName));

            ImGui::Spacing();
            ImGui::Spacing();

            bool canCopy = strlen(copyTemplateName) > 0;

            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.5f, 0.2f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.9f, 0.6f, 0.3f, 1.0f));

            if (!canCopy) {
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
            }

            if (ImGui::Button("Copy Template", ImVec2(150, 30)) && canCopy) {
                // Check database connection
                if (!g_DBConnection || !g_UseDatabase) {
                    printf("[Copy Template] ERROR: Database not connected!\n");
                } else {
                    // Sync current page back to g_NormalPages
                    if (g_CurrentPageIndex >= 0 && g_CurrentPageIndex < (int)g_NormalPages.size()) {
                        g_NormalPages[g_CurrentPageIndex].sections = g_Sections;
                    }

                    // Save to database as new template
                    bool savedToSections = false;
                    bool savedToImGui = false;

                    // Save to templates/sections tables (main database storage)
                    if (!g_Sections.empty() || !g_NormalPages.empty()) {
                        savedToSections = SaveTemplate(copyTemplateName, "Copy of " + g_ProjectName);
                        if (savedToSections) {
                            printf("[Copy Template] Saved to templates/sections table: %s\n", copyTemplateName);
                        }
                    }

                    // Also save to imgui_templates table
                    savedToImGui = SaveAsImGuiTemplate(copyTemplateName);
                    if (savedToImGui) {
                        printf("[Copy Template] Saved to imgui_templates table: %s\n", copyTemplateName);
                    }

                    if (savedToSections || savedToImGui) {
                        printf("[Copy Template] SUCCESS - Template copied to database: %s\n", copyTemplateName);

                        // Refresh template lists from database
                        LoadAvailableTemplates();
                        g_ImGuiTemplatesList = GetImGuiTemplates();

                        copyTemplateName[0] = '\0';
                        copyNameInitialized = false;
                        g_ShowCopyTemplatePopup = false;
                    } else {
                        printf("[Copy Template] ERROR: Failed to save template to database!\n");
                    }
                }
            }

            if (!canCopy) {
                ImGui::PopStyleVar();
            }
            ImGui::PopStyleColor(2);

            ImGui::SameLine();

            if (ImGui::Button("Cancel", ImVec2(100, 30))) {
                copyTemplateName[0] = '\0';
                copyNameInitialized = false;
                g_ShowCopyTemplatePopup = false;
            }
        }
        ImGui::End();
    }

    // ==================== ICON PICKER POPUP ====================
    if (g_ShowIconPickerPopup) {
        ImGui::SetNextWindowSize(ImVec2(500, 420), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

        if (ImGui::Begin("Select Icon", &g_ShowIconPickerPopup, ImGuiWindowFlags_NoCollapse)) {
            ImGui::TextColored(ImVec4(0.2f, 0.6f, 0.9f, 1), g_AddingNewIcon ? "Select an icon to add:" : "Choose an icon:");
            ImGui::Separator();
            ImGui::Spacing();

            // Grid layout for icons
            float iconButtonSize = 70.0f;
            float iconDisplaySize = 32.0f;
            int iconsPerRow = 6;

            ImGui::BeginChild("IconGrid", ImVec2(-1, 320), true);

            for (int i = 0; i < ICON_COUNT; i++) {
                ImGui::PushID(i);

                // Calculate position in grid
                int col = i % iconsPerRow;
                if (col > 0) {
                    ImGui::SameLine();
                }

                // Create a button with icon preview
                ImVec2 cursorPos = ImGui::GetCursorScreenPos();
                bool isSelected = (g_IconPickerTarget && *g_IconPickerTarget == i);

                // Highlight selected icon
                if (isSelected) {
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.5f, 0.8f, 1.0f));
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));
                }

                if (ImGui::Button("##iconBtn", ImVec2(iconButtonSize, iconButtonSize))) {
                    if (g_AddingNewIcon) {
                        // Create new icon section with selected icon
                        WebSection sec(g_NextSectionId++, SEC_ICON);
                        sec.icon_type = i;
                        if (g_FreeDesignMode) {
                            float nextY = 20;
                            for (const auto& s : g_Sections) {
                                float sBottom = s.y_position + s.height;
                                if (sBottom > nextY) nextY = sBottom + 20;
                            }
                            sec.x_position = 20;
                            sec.y_position = nextY;
                            sec.width = 100;
                            sec.height = 100;
                            sec.z_index = (int)g_Sections.size();
                            sec.use_manual_position = true;
                        } else {
                            sec.height = 100;
                        }
                        g_Sections.push_back(sec);
                        g_SelectedSectionIndex = (int)g_Sections.size() - 1;
                        for (int j = 0; j < (int)g_Sections.size(); j++) g_Sections[j].selected = (j == g_SelectedSectionIndex);
                        g_AddingNewIcon = false;
                    } else if (g_IconPickerTarget) {
                        // Update existing icon
                        *g_IconPickerTarget = i;
                    }
                    g_ShowIconPickerPopup = false;
                    g_IconPickerTarget = nullptr;
                }

                if (isSelected) {
                    ImGui::PopStyleColor(2);
                }

                // Draw icon on top of button
                ImDrawList* dl = ImGui::GetWindowDrawList();
                float iconCenterX = cursorPos.x + iconButtonSize / 2;
                float iconCenterY = cursorPos.y + iconButtonSize / 2 - 8;
                ImU32 iconColor = isSelected ? IM_COL32(255, 255, 255, 255) : IM_COL32(200, 200, 200, 255);
                DrawIcon(dl, i, iconCenterX, iconCenterY, iconDisplaySize, iconColor, 2.0f);

                // Draw icon name below
                ImVec2 textSize = ImGui::CalcTextSize(g_IconNames[i]);
                float textX = cursorPos.x + (iconButtonSize - textSize.x) / 2;
                float textY = cursorPos.y + iconButtonSize - 18;
                dl->AddText(ImVec2(textX, textY), IM_COL32(180, 180, 180, 255), g_IconNames[i]);

                ImGui::PopID();
            }

            ImGui::EndChild();

            ImGui::Spacing();
            if (ImGui::Button("Cancel", ImVec2(-1, 28))) {
                g_ShowIconPickerPopup = false;
                g_IconPickerTarget = nullptr;
                g_AddingNewIcon = false;
            }
        }
        ImGui::End();
    }

    // ==================== IMGUI TEMPLATES POPUP (Global - works from any mode) ====================
    if (g_ShowImGuiTemplatesPopup) {
        ImGui::SetNextWindowSize(ImVec2(550, 450), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

        if (ImGui::Begin("ImGui Templates", &g_ShowImGuiTemplatesPopup, ImGuiWindowFlags_NoCollapse)) {
            ImGui::TextColored(ImVec4(0.6f, 0.2f, 0.7f, 1), "Saved ImGui Templates");
            ImGui::SameLine();
            ImGui::TextDisabled("(%zu templates)", g_ImGuiTemplatesList.size());
            ImGui::Separator();

            if (g_ImGuiTemplatesList.empty()) {
                ImGui::Spacing();
                ImGui::TextDisabled("No ImGui templates saved yet.");
                ImGui::Spacing();
                ImGui::TextWrapped("To save an ImGui template:");
                ImGui::BulletText("Import a Figma design (URL or API)");
                ImGui::BulletText("Click 'Save Template' in top bar");
                ImGui::Spacing();
            } else {
                // Refresh button
                if (ImGui::Button("Refresh List")) {
                    g_ImGuiTemplatesList = GetImGuiTemplates();
                }
                ImGui::Separator();

                // Template list with scrolling
                ImGui::BeginChild("ImGuiTemplateList", ImVec2(0, -35), true);

                for (size_t i = 0; i < g_ImGuiTemplatesList.size(); i++) {
                    const auto& tmpl = g_ImGuiTemplatesList[i];
                    ImGui::PushID(tmpl.id);

                    // Template row
                    ImGui::BeginGroup();

                    // Name (bold style)
                    ImGui::TextColored(ImVec4(1, 1, 1, 1), "%s", tmpl.name.c_str());

                    // Info line
                    ImGui::TextDisabled("   %d layers  |  %.0f x %.0f px",
                        tmpl.layer_count, tmpl.canvas_width, tmpl.canvas_height);

                    ImGui::EndGroup();

                    // Buttons on the right
                    ImGui::SameLine(400);

                    // Load button (green)
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.3f, 1.0f));
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.7f, 0.4f, 1.0f));
                    if (ImGui::Button("Load", ImVec2(60, 24))) {
                        if (LoadImGuiTemplate(tmpl.id)) {
                            g_ShowImGuiTemplatesPopup = false;
                            g_FigmaMode = true;
                        }
                    }
                    ImGui::PopStyleColor(2);

                    ImGui::SameLine();

                    // Delete button (red)
                    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.7f, 0.2f, 0.2f, 1.0f));
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.3f, 0.3f, 1.0f));
                    if (ImGui::Button("Delete", ImVec2(60, 24))) {
                        DeleteImGuiTemplate(tmpl.id);
                        g_ImGuiTemplatesList = GetImGuiTemplates();
                    }
                    ImGui::PopStyleColor(2);

                    ImGui::PopID();

                    ImGui::Spacing();
                    ImGui::Separator();
                }

                ImGui::EndChild();
            }

            // Close button at bottom
            if (ImGui::Button("Close", ImVec2(-1, 28))) {
                g_ShowImGuiTemplatesPopup = false;
            }
        }
        ImGui::End();
    }

    // URL Import Dialog
    if (g_ShowURLImportDialog) {
        ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x / 2 - 320, io.DisplaySize.y / 2 - 250));
        ImGui::SetNextWindowSize(ImVec2(640, 500));
        ImGui::Begin("Import from URL", &g_ShowURLImportDialog, ImGuiWindowFlags_NoResize);

        ImGui::TextColored(ImVec4(0.9f, 0.5f, 0.2f, 1), "Import website design from URL");
        ImGui::Separator();
        ImGui::Spacing();

        // Import Method Selection (Tabs)
        ImGui::Text("Import Method:");
        ImGui::SameLine();

        // Tab buttons - save state before button clicks to avoid push/pop mismatch
        bool isLiveScrape = (g_ImportMethod == 0);
        bool isLocalDownload = (g_ImportMethod == 1);
        bool isFigmaStyle = (g_ImportMethod == 2);
        bool isFigmaDesign = (g_ImportMethod == 3);

        if (isLiveScrape) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.5f, 0.8f, 1.0f));
        }
        if (ImGui::Button("Live Scrape", ImVec2(90, 28))) {
            g_ImportMethod = 0;
        }
        if (isLiveScrape) {
            ImGui::PopStyleColor();
        }

        ImGui::SameLine();

        if (isLocalDownload) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.3f, 0.7f, 0.4f, 1.0f));
        }
        if (ImGui::Button("Local Download", ImVec2(95, 28))) {
            g_ImportMethod = 1;
        }
        if (isLocalDownload) {
            ImGui::PopStyleColor();
        }

        ImGui::SameLine();

        if (isFigmaStyle) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.3f, 0.6f, 1.0f));
        }
        if (ImGui::Button("Figma-Style", ImVec2(85, 28))) {
            g_ImportMethod = 2;
        }
        if (isFigmaStyle) {
            ImGui::PopStyleColor();
        }

        ImGui::SameLine();

        if (isFigmaDesign) {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.3f, 0.9f, 1.0f));
        }
        if (ImGui::Button("Figma Design", ImVec2(90, 28))) {
            g_ImportMethod = 3;
        }
        if (isFigmaDesign) {
            ImGui::PopStyleColor();
        }

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        // Different input for Figma Design vs others
        if (g_ImportMethod == 3) {
            // FIGMA DESIGN - Show API Token and File URL
            ImGui::TextColored(ImVec4(0.7f, 0.4f, 1.0f, 1), "Figma Design Import (Direct API)");
            ImGui::Indent(10);
            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Import designs directly from your Figma account");
            ImGui::Unindent(10);

            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // API Token
            ImGui::Text("Figma API Token:");
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "(Settings > Account > Personal Access Tokens)");
            ImGui::SetNextItemWidth(-1);
            ImGui::InputText("##FigmaAPIToken", g_FigmaAPIToken, sizeof(g_FigmaAPIToken), ImGuiInputTextFlags_Password);

            ImGui::Spacing();

            // File URL
            ImGui::Text("Figma File URL or Key:");
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "(e.g., figma.com/file/ABC123/...)");
            ImGui::SetNextItemWidth(-1);
            ImGui::InputText("##FigmaFileURL", g_FigmaFileURL, sizeof(g_FigmaFileURL));

            ImGui::Spacing();

            // Help section
            ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.3f, 1), "How to get your API Token:");
            ImGui::Indent(15);
            ImGui::BulletText("Go to Figma.com > Settings > Account");
            ImGui::BulletText("Scroll to 'Personal Access Tokens'");
            ImGui::BulletText("Click 'Create new token'");
            ImGui::BulletText("Copy and paste the token above");
            ImGui::Unindent(15);

            ImGui::Spacing();

            ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.3f, 1), "What gets imported:");
            ImGui::Indent(15);
            ImGui::BulletText("All frames and components");
            ImGui::BulletText("Text layers with fonts & colors");
            ImGui::BulletText("Shapes with fills & strokes");
            ImGui::BulletText("Images (rendered from Figma)");
            ImGui::Unindent(15);

        } else {
            // Standard URL input for other methods
            ImGui::Text("Enter URL:");
            ImGui::SetNextItemWidth(-1);
            ImGui::InputText("##URLInput", g_URLImportBuffer, sizeof(g_URLImportBuffer));
        }

        ImGui::Spacing();

        if (g_ImportMethod == 0) {
            // LIVE SCRAPE OPTIONS
            ImGui::TextColored(ImVec4(0.5f, 0.7f, 1.0f, 1), "Live Scrape Mode");
            ImGui::Indent(10);
            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Scrapes website in real-time using browser automation");
            ImGui::Unindent(10);

            ImGui::Spacing();

            // Timeout control
            ImGui::Text("Scraping Timeout:");
            ImGui::SetNextItemWidth(350);
            ImGui::SliderInt("##TimeoutSlider", &g_URLImportTimeout, 60, 600, "%d seconds");
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "(%d min %d sec)", g_URLImportTimeout / 60, g_URLImportTimeout % 60);

            ImGui::Indent(15);
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1), "Recommended: 3-5 min for most sites");
            ImGui::Unindent(15);

            ImGui::Spacing();

            // Stealth Browser MCP option
            ImGui::Checkbox("Use Stealth Browser (bypasses anti-bot protection)", &g_URLImportUseStealth);
            ImGui::Indent(15);
            if (g_URLImportUseStealth) {
                ImGui::TextColored(ImVec4(0.4f, 0.8f, 0.4f, 1), "Stealth mode: Bypasses bot detection");
            } else {
                ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Standard Playwright browser");
            }
            ImGui::Unindent(15);

        } else if (g_ImportMethod == 1) {
            // LOCAL DOWNLOAD OPTIONS
            ImGui::TextColored(ImVec4(0.4f, 0.9f, 0.5f, 1), "Local Download Mode (More Accurate)");
            ImGui::Indent(10);
            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Downloads entire website locally, then parses HTML/CSS files");
            ImGui::Unindent(10);

            ImGui::Spacing();

            // Benefits
            ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.3f, 1), "Benefits:");
            ImGui::Indent(15);
            ImGui::BulletText("All images downloaded (no lazy loading issues)");
            ImGui::BulletText("Actual CSS files parsed (not computed styles)");
            ImGui::BulletText("No timeout issues");
            ImGui::BulletText("Can analyze complex sites offline");
            ImGui::Unindent(15);

            ImGui::Spacing();

            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Uses wget to mirror the website");
        } else if (g_ImportMethod == 2) {
            // FIGMA-STYLE OPTIONS
            ImGui::TextColored(ImVec4(0.9f, 0.4f, 0.7f, 1), "Figma-Style Mode (Pixel Perfect)");
            ImGui::Indent(10);
            ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1), "Extracts every element with exact positions like Figma");
            ImGui::Unindent(10);

            ImGui::Spacing();

            // Benefits
            ImGui::TextColored(ImVec4(0.8f, 0.8f, 0.3f, 1), "Benefits:");
            ImGui::Indent(15);
            ImGui::BulletText("Pixel-perfect layout preservation");
            ImGui::BulletText("Every element as a draggable layer");
            ImGui::BulletText("Screenshot overlay for reference");
            ImGui::BulletText("Edit like Figma/Sketch");
            ImGui::Unindent(15);

            ImGui::Spacing();

            ImGui::TextColored(ImVec4(0.9f, 0.7f, 0.3f, 1), "Note: Opens in Figma-style editor mode");
        }

        ImGui::Spacing();

        if (!g_URLImportStatus.empty() || !g_FigmaImportStatus.empty()) {
            std::string status = (g_ImportMethod == 2) ? g_FigmaImportStatus : g_URLImportStatus;
            ImVec4 color = ImVec4(0.7f, 0.7f, 0.7f, 1);
            if (status.find("Error") != std::string::npos) {
                color = ImVec4(1, 0.3f, 0.3f, 1);
            } else if (status.find("Warning") != std::string::npos) {
                color = ImVec4(1, 0.8f, 0.2f, 1);
            } else if (status.find("Success") != std::string::npos) {
                color = ImVec4(0.3f, 1, 0.3f, 1);
            }

            ImGui::TextColored(color, "%s", status.c_str());

            if (g_URLImportInProgress || g_FigmaImportInProgress) {
                ImGui::ProgressBar(g_URLImportProgress);
            }
        }

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        // Different validation for Figma Design vs others
        bool can_import = false;
        if (g_ImportMethod == 3) {
            // Figma Design: need API token and file URL
            can_import = strlen(g_FigmaAPIToken) > 10 && strlen(g_FigmaFileURL) > 5 && !g_URLImportInProgress && !g_FigmaImportInProgress;
        } else {
            can_import = strlen(g_URLImportBuffer) > 10 && !g_URLImportInProgress && !g_FigmaImportInProgress;
        }

        if (!can_import) {
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
        }

        // Import button text changes based on method
        const char* importBtnText = "Import";
        if (g_ImportMethod == 0) importBtnText = "Import (Live)";
        else if (g_ImportMethod == 1) importBtnText = "Import (Download)";
        else if (g_ImportMethod == 2) importBtnText = "Import (Figma)";
        else if (g_ImportMethod == 3) importBtnText = "Import from Figma";

        if (ImGui::Button(importBtnText, ImVec2(150, 35)) && can_import) {
            if (g_ImportMethod == 0) {
                // Live Scrape
                g_URLImportInProgress = true;
                bool success = ImportFromURL(std::string(g_URLImportBuffer), g_URLImportTimeout, g_URLImportUseStealth);
                g_URLImportInProgress = false;
            } else if (g_ImportMethod == 1) {
                // Local Download
                g_URLImportInProgress = true;
                bool success = ImportFromLocalDownload(std::string(g_URLImportBuffer));
                g_URLImportInProgress = false;
            } else if (g_ImportMethod == 2) {
                // Figma-style (from URL)
                bool success = ImportFigmaLayers(std::string(g_URLImportBuffer));
                if (success) {
                    g_ShowURLImportDialog = false;  // Close dialog on success
                }
            } else if (g_ImportMethod == 3) {
                // Figma Design (from Figma API)
                g_FigmaImportInProgress = true;
                g_FigmaImportStatus = "Connecting to Figma API...";

                // Build command to run Python script
                std::string outputDir = "/tmp/figma_import";
                system(("mkdir -p \"" + outputDir + "\"").c_str());
                system(("rm -rf \"" + outputDir + "\"/*").c_str());

                std::string cmd = "cd /Users/imaging/Desktop/Website-Builder-v2.0 && "
                                  "source playwright_env/bin/activate && "
                                  "python3 figma_api_import.py \"" + std::string(g_FigmaAPIToken) + "\" "
                                  "\"" + std::string(g_FigmaFileURL) + "\" \"" + outputDir + "\" 2>&1";

                printf("[FigmaDesign] Running: %s\n", cmd.c_str());

                FILE* pipe = popen(cmd.c_str(), "r");
                if (pipe) {
                    char buffer[256];
                    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                        printf("%s", buffer);
                        std::string line(buffer);
                        if (line.find("Error") != std::string::npos || line.find("error") != std::string::npos) {
                            g_FigmaImportStatus = "Error: " + line;
                        } else if (line.find("COMPLETE") != std::string::npos) {
                            g_FigmaImportStatus = "Import complete!";
                        }
                    }
                    int result = pclose(pipe);

                    // Now load the layers.json just like ImportFigmaLayers does
                    std::string jsonPath = outputDir + "/layers.json";
                    FILE* jsonFile = fopen(jsonPath.c_str(), "r");
                    if (jsonFile) {
                        // Read JSON file
                        fseek(jsonFile, 0, SEEK_END);
                        long fileSize = ftell(jsonFile);
                        fseek(jsonFile, 0, SEEK_SET);
                        std::string jsonContent(fileSize, '\0');
                        fread(&jsonContent[0], 1, fileSize, jsonFile);
                        fclose(jsonFile);

                        // Parse and load (reuse existing parsing logic)
                        g_FigmaProject = FigmaProject(); // Reset

                        // Parse project name
                        size_t namePos = jsonContent.find("\"name\":");
                        if (namePos != std::string::npos) {
                            size_t start = jsonContent.find("\"", namePos + 7) + 1;
                            size_t end = jsonContent.find("\"", start);
                            g_FigmaProject.name = jsonContent.substr(start, end - start);
                        }

                        // Parse canvas dimensions
                        size_t widthPos = jsonContent.find("\"canvas_width\":");
                        if (widthPos != std::string::npos) {
                            g_FigmaProject.canvas_width = std::stof(jsonContent.substr(widthPos + 15, 10));
                        }
                        size_t heightPos = jsonContent.find("\"canvas_height\":");
                        if (heightPos != std::string::npos) {
                            g_FigmaProject.canvas_height = std::stof(jsonContent.substr(heightPos + 16, 10));
                        }

                        // Load screenshot if exists
                        std::string screenshotPath = outputDir + "/images/screenshot.png";
                        int sw, sh, sn;
                        unsigned char* sdata = stbi_load(screenshotPath.c_str(), &sw, &sh, &sn, 4);
                        if (sdata) {
                            glGenTextures(1, &g_FigmaProject.screenshot_texture_id);
                            glBindTexture(GL_TEXTURE_2D, g_FigmaProject.screenshot_texture_id);
                            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, sw, sh, 0, GL_RGBA, GL_UNSIGNED_BYTE, sdata);
                            stbi_image_free(sdata);
                            g_FigmaProject.screenshot_path = screenshotPath;
                            printf("[FigmaDesign] Loaded screenshot: %dx%d\n", sw, sh);
                        }

                        // Parse layers (simplified - look for each layer object)
                        size_t layersStart = jsonContent.find("\"layers\":");
                        if (layersStart != std::string::npos) {
                            size_t pos = layersStart;
                            int layerCount = 0;

                            while (layerCount < 500) {
                                size_t idPos = jsonContent.find("\"id\":", pos + 1);
                                if (idPos == std::string::npos || idPos > jsonContent.length() - 100) break;

                                WebLayer layer;
                                layer.id = layerCount + 1;
                                layer.visible = true;

                                // Helper to parse float
                                auto parseFloat = [&](const char* key, float defaultVal = 0) -> float {
                                    size_t keyPos = jsonContent.find(key, idPos);
                                    if (keyPos != std::string::npos && keyPos < idPos + 2000) {
                                        size_t valStart = keyPos + strlen(key);
                                        while (valStart < jsonContent.length() && (jsonContent[valStart] == ' ' || jsonContent[valStart] == ':')) valStart++;
                                        try {
                                            return std::stof(jsonContent.substr(valStart, 20));
                                        } catch (...) {}
                                    }
                                    return defaultVal;
                                };

                                // Helper to parse string
                                auto parseString = [&](const char* key) -> std::string {
                                    size_t keyPos = jsonContent.find(key, idPos);
                                    if (keyPos != std::string::npos && keyPos < idPos + 2000) {
                                        size_t start = jsonContent.find("\"", keyPos + strlen(key)) + 1;
                                        size_t end = jsonContent.find("\"", start);
                                        if (end > start && end - start < 1000) {
                                            return jsonContent.substr(start, end - start);
                                        }
                                    }
                                    return "";
                                };

                                layer.x = parseFloat("\"x\":");
                                layer.y = parseFloat("\"y\":");
                                layer.width = parseFloat("\"width\":", 100);
                                layer.height = parseFloat("\"height\":", 100);
                                layer.z_index = (int)parseFloat("\"z_index\":");
                                layer.font_size = parseFloat("\"font_size\":", 16);
                                layer.border_radius = parseFloat("\"border_radius\":");
                                layer.opacity = parseFloat("\"opacity\":", 1.0f);

                                layer.name = parseString("\"name\":");
                                layer.text = parseString("\"text\":");
                                layer.image_path = parseString("\"image_path\":");

                                // Parse type
                                std::string typeStr = parseString("\"type\":");
                                if (typeStr == "LAYER_TEXT") layer.type = LAYER_TEXT;
                                else if (typeStr == "LAYER_IMAGE") layer.type = LAYER_IMAGE;
                                else if (typeStr == "LAYER_BUTTON") layer.type = LAYER_BUTTON;
                                else if (typeStr == "LAYER_INPUT") layer.type = LAYER_INPUT;
                                else layer.type = LAYER_DIV;

                                // Parse colors from rgb/rgba strings
                                auto parseRGBA = [](const std::string& colorStr) -> ImVec4 {
                                    if (colorStr.empty()) return ImVec4(0, 0, 0, 0);

                                    int r = 0, g = 0, b = 0;
                                    float a = 1.0f;

                                    // Parse "rgba(r, g, b, a)" format
                                    if (colorStr.find("rgba(") == 0 || colorStr.find("rgba") != std::string::npos) {
                                        if (sscanf(colorStr.c_str(), "rgba(%d, %d, %d, %f)", &r, &g, &b, &a) >= 3 ||
                                            sscanf(colorStr.c_str(), "rgba(%d,%d,%d,%f)", &r, &g, &b, &a) >= 3) {
                                            return ImVec4(r / 255.0f, g / 255.0f, b / 255.0f, a);
                                        }
                                    }
                                    // Parse "rgb(r, g, b)" format
                                    else if (colorStr.find("rgb(") == 0 || colorStr.find("rgb") != std::string::npos) {
                                        if (sscanf(colorStr.c_str(), "rgb(%d, %d, %d)", &r, &g, &b) == 3 ||
                                            sscanf(colorStr.c_str(), "rgb(%d,%d,%d)", &r, &g, &b) == 3) {
                                            return ImVec4(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f);
                                        }
                                    }
                                    return ImVec4(0, 0, 0, 0);
                                };

                                std::string bgColorStr = parseString("\"bg_color\":");
                                std::string textColorStr = parseString("\"text_color\":");
                                std::string borderColorStr = parseString("\"border_color\":");

                                layer.bg_color = parseRGBA(bgColorStr);
                                layer.text_color = parseRGBA(textColorStr);
                                layer.border_color = parseRGBA(borderColorStr);
                                layer.border_width = parseFloat("\"border_width\":", 0);

                                // Load image texture if needed
                                if (layer.type == LAYER_IMAGE && !layer.image_path.empty()) {
                                    int w, h, n;
                                    unsigned char* data = stbi_load(layer.image_path.c_str(), &w, &h, &n, 4);
                                    if (data) {
                                        glGenTextures(1, &layer.texture_id);
                                        glBindTexture(GL_TEXTURE_2D, layer.texture_id);
                                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                                        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                                        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
                                        stbi_image_free(data);
                                    }
                                }

                                // Debug: print parsed colors for first 5 layers
                                if (layerCount < 5) {
                                    printf("[FigmaDesign] Layer %d '%s': bg=(%.2f,%.2f,%.2f,%.2f)\n",
                                        layer.id, layer.name.c_str(),
                                        layer.bg_color.x, layer.bg_color.y, layer.bg_color.z, layer.bg_color.w);
                                }

                                g_FigmaProject.layers.push_back(layer);
                                layerCount++;
                                pos = idPos + 5;
                            }

                            printf("[FigmaDesign] Loaded %d layers\n", layerCount);
                            g_FigmaImportStatus = "Success! Imported " + std::to_string(layerCount) + " layers from Figma";
                        }

                        g_FigmaMode = true;
                        RewriteFigmaActionsToInternal();
                        g_ShowURLImportDialog = false;
                    } else {
                        g_FigmaImportStatus = "Error: Could not read layers.json";
                    }
                } else {
                    g_FigmaImportStatus = "Error: Could not run Figma API script";
                }
                g_FigmaImportInProgress = false;
            }
        }

        if (!can_import) {
            ImGui::PopStyleVar();
        }

        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(100, 35))) {
            g_ShowURLImportDialog = false;
        }

        // Validation messages
        if (g_ImportMethod == 3) {
            if (strlen(g_FigmaAPIToken) == 0) {
                ImGui::TextColored(ImVec4(1, 0.5f, 0, 1), "Please enter your Figma API token");
            } else if (strlen(g_FigmaFileURL) == 0) {
                ImGui::TextColored(ImVec4(1, 0.5f, 0, 1), "Please enter the Figma file URL or key");
            }
        } else if (!can_import && strlen(g_URLImportBuffer) > 0 && strlen(g_URLImportBuffer) < 10) {
            ImGui::TextColored(ImVec4(1, 0.5f, 0, 1), "Please enter a valid URL (http:// or https://)");
        }

        ImGui::End();
    }
}

// ============================================================================
// MAIN
// ============================================================================
// Modern Service Card (Screenshot 1 style: icon + bullet points)
void DrawModernServiceCard(ImDrawList* dl, float x, float y, float w, float h,
                          const std::string& title, const std::string& subtitle,
                          const std::vector<std::string>& bullets, const std::string& icon_emoji,
                          ImVec4 icon_color, ImVec4 text_color, float anim_progress) {
    // Animation: slide in from right
    float slideOffset = (1.0f - anim_progress) * 150.0f;
    x += slideOffset;
    float alpha = anim_progress;

    // Card shadow (soft, modern)
    dl->AddRectFilled(ImVec2(x + 2, y + 8), ImVec2(x + w + 2, y + h + 8),
                     IM_COL32(0, 0, 0, (int)(15 * alpha)), 16.0f);

    // Card background (white)
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h),
                     IM_COL32(255, 255, 255, (int)(255 * alpha)), 16.0f);

    // Card border (light gray, complete border)
    dl->AddRect(ImVec2(x, y), ImVec2(x + w, y + h),
               IM_COL32(230, 230, 230, (int)(255 * alpha)), 16.0f, 0, 1.0f);

    // Decorative blob and icon box removed

    // Title (bold, dark) - starts from top now
    ImFont* font = ImGui::GetFont();
    float textY = y + 32;
    ImVec2 title_size = font->CalcTextSizeA(22.0f, FLT_MAX, w - 48, title.c_str());
    dl->AddText(font, 22.0f, ImVec2(x + 24, textY),
               IM_COL32(18, 18, 18, (int)(255 * alpha)), title.c_str(), nullptr, w - 48);
    textY += title_size.y + 10;

    // Subtitle (gray)
    ImVec2 sub_size = font->CalcTextSizeA(15.0f, FLT_MAX, w - 48, subtitle.c_str());
    dl->AddText(font, 15.0f, ImVec2(x + 24, textY),
               IM_COL32(115, 115, 128, (int)(255 * alpha)), subtitle.c_str(), nullptr, w - 48);
    textY += sub_size.y + 18;

    // Bullet points with icons
    for (size_t i = 0; i < bullets.size() && i < 3; i++) {
        // Bullet icon (small dark circle)
        dl->AddCircleFilled(ImVec2(x + 30, textY + 7), 3, IM_COL32(60, 60, 67, (int)(255 * alpha)));

        // Bullet text
        dl->AddText(font, 14.0f, ImVec2(x + 42, textY),
                   IM_COL32(60, 60, 67, (int)(255 * alpha)), bullets[i].c_str(), nullptr, w - 66);
        textY += 24;
    }

    // "Learn More" link with arrow at bottom
    textY = y + h - 40;
    dl->AddText(font, 15.0f, ImVec2(x + 24, textY),
               IM_COL32(0, 112, 243, (int)(255 * alpha)), "Learn More ‚Üí");
}

// Modern Portfolio Card (Screenshot 2 style: thumbnail + tags)
void DrawModernPortfolioCard(ImDrawList* dl, float x, float y, float w, float h,
                             const std::string& title, const std::string& subtitle,
                             const std::vector<std::string>& tech_tags, const std::string& badge_text,
                             GLuint thumbnail_id, ImVec4 text_color, float anim_progress) {
    // Animation: slide in from right
    float slideOffset = (1.0f - anim_progress) * 150.0f;
    x += slideOffset;
    float alpha = anim_progress;

    // Card shadow (soft, modern)
    dl->AddRectFilled(ImVec2(x + 2, y + 8), ImVec2(x + w + 2, y + h + 8),
                     IM_COL32(0, 0, 0, (int)(15 * alpha)), 20.0f);

    // Card background (white)
    dl->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h),
                     IM_COL32(255, 255, 255, (int)(255 * alpha)), 16.0f);

    // Thumbnail image at top (rounded corners)
    float thumbnailH = h * 0.5f;  // 50% of card height
    if (thumbnail_id != 0) {
        // Clip to rounded rectangle for image
        dl->PushClipRect(ImVec2(x + 1, y + 1), ImVec2(x + w - 1, y + thumbnailH), true);
        dl->AddImage((ImTextureID)(intptr_t)thumbnail_id,
                    ImVec2(x, y), ImVec2(x + w, y + thumbnailH));
        dl->PopClipRect();
    } else {
        // Placeholder gradient if no image
        dl->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + w, y + thumbnailH),
                                    IM_COL32(100, 149, 237, (int)(255 * alpha)),
                                    IM_COL32(135, 206, 250, (int)(255 * alpha)),
                                    IM_COL32(135, 206, 250, (int)(255 * alpha)),
                                    IM_COL32(100, 149, 237, (int)(255 * alpha)));
    }

    // Category badge (overlaying bottom-left of image)
    if (!badge_text.empty()) {
        ImFont* font = ImGui::GetFont();
        ImVec2 badge_size = font->CalcTextSizeA(13.0f, FLT_MAX, 0.0f, badge_text.c_str());
        float badgeW = badge_size.x + 20;
        float badgeH = 26;
        float badgeX = x + 16;
        float badgeY = y + thumbnailH - badgeH - 12;

        // Badge background (blue pill)
        dl->AddRectFilled(ImVec2(badgeX, badgeY), ImVec2(badgeX + badgeW, badgeY + badgeH),
                         IM_COL32(0, 112, 243, (int)(255 * alpha)), badgeH / 2);

        // Badge text (white)
        dl->AddText(font, 13.0f, ImVec2(badgeX + 10, badgeY + 6),
                   IM_COL32(255, 255, 255, (int)(255 * alpha)), badge_text.c_str());
    }

    // Content area (below thumbnail)
    float contentY = y + thumbnailH + 24;
    ImFont* font = ImGui::GetFont();

    // Title (bold, dark)
    ImVec2 title_size = font->CalcTextSizeA(20.0f, FLT_MAX, w - 48, title.c_str());
    dl->AddText(font, 20.0f, ImVec2(x + 24, contentY),
               IM_COL32(18, 18, 18, (int)(255 * alpha)), title.c_str(), nullptr, w - 48);
    contentY += title_size.y + 10;

    // Subtitle (gray)
    ImVec2 sub_size = font->CalcTextSizeA(14.0f, FLT_MAX, w - 48, subtitle.c_str());
    dl->AddText(font, 14.0f, ImVec2(x + 24, contentY),
               IM_COL32(115, 115, 128, (int)(255 * alpha)), subtitle.c_str(), nullptr, w - 48);
    contentY += sub_size.y + 16;

    // Technology tags (blue pills)
    float tagX = x + 24;
    for (size_t i = 0; i < tech_tags.size() && i < 3; i++) {
        ImVec2 tag_size = font->CalcTextSizeA(12.0f, FLT_MAX, 0.0f, tech_tags[i].c_str());
        float tagW = tag_size.x + 16;
        float tagH = 24;

        // Tag background (light blue pill)
        dl->AddRectFilled(ImVec2(tagX, contentY), ImVec2(tagX + tagW, contentY + tagH),
                         IM_COL32(225, 238, 255, (int)(255 * alpha)), tagH / 2);

        // Tag text (blue)
        dl->AddText(font, 12.0f, ImVec2(tagX + 8, contentY + 6),
                   IM_COL32(0, 112, 243, (int)(255 * alpha)), tech_tags[i].c_str());

        tagX += tagW + 8;  // Space between tags
    }

    // "View Project" link with arrow at bottom
    float linkY = y + h - 40;
    dl->AddText(font, 15.0f, ImVec2(x + 24, linkY),
               IM_COL32(0, 112, 243, (int)(255 * alpha)), "View Project ‚Üí");
}

static void glfw_error_callback(int e, const char* d) { fprintf(stderr, "GLFW Error %d: %s\n", e, d); }

int main(int, char**) {
    glfwSetErrorCallback(glfw_error_callback);
    if (!glfwInit()) return 1;
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

    g_Window = glfwCreateWindow(1400, 900, "ImGui Website Designer", nullptr, nullptr);
    if (!g_Window) return 1;
    glfwMakeContextCurrent(g_Window);
    glfwSwapInterval(1);

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    // Enable smooth scrolling for Mac trackpad (two-finger scrolling)
    io.MouseWheelH = 0.0f;  // Horizontal scroll support
    io.ConfigMacOSXBehaviors = true;  // Enable Mac-specific behaviors

    io.Fonts->AddFontFromFileTTF("/System/Library/Fonts/SFNS.ttf", 14.0f);
    if (io.Fonts->Fonts.empty()) io.Fonts->AddFontDefault();

    ImGui::StyleColorsDark();
    ImGui_ImplGlfw_InitForOpenGL(g_Window, true);
    ImGui_ImplOpenGL3_Init("#version 150");

    // Initialize PostgreSQL database connection (will fallback to JSON if fails)
    if (!InitDatabase()) {
        printf("PostgreSQL not available, using JSON files for templates\n");
    }

    g_Pages = {"Home"};

    while (!glfwWindowShouldClose(g_Window)) {
        glfwPollEvents();
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        RenderUI();
        RenderTemplatePicker();  // Render template picker modal
        ImGui::Render();
        int dw, dh;
        glfwGetFramebufferSize(g_Window, &dw, &dh);
        glViewport(0, 0, dw, dh);
        glClearColor(0.08f, 0.08f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        glfwSwapBuffers(g_Window);
    }

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwDestroyWindow(g_Window);
    CloseDatabase();  // Close PostgreSQL connection
    glfwTerminate();
    return 0;
}
